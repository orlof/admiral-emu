140
CONTROL_SIGNAL
1
CONTROL_VALUE
2
DICT_ITEM_KEY
1
DICT_ITEM_VALUE
2
EDIT_BUFFER_SIZE
0x0400
FALSE
0
FLOAT_EXP
1
FLOAT_EXP_BIAS
0x8000
FLOAT_HIGH
2
FLOAT_LOW
3
FLOAT_TYPE
0
FLOAT_TYPE_DBZ
0
FLOAT_TYPE_NAN
0x8000
FLOAT_TYPE_NINF
3
FLOAT_TYPE_NNUM
2
FLOAT_TYPE_NZERO
1
FLOAT_TYPE_PINF
-3
FLOAT_TYPE_PNUM
-2
FLOAT_TYPE_PZERO
-1
FLOPPY__MBR__DIR_HEAD
MEM_FLOPPY_START + 2
FLOPPY__MBR__DIR_TAIL
MEM_FLOPPY_START + 3
FLOPPY__MBR__FREE_HEAD
MEM_FLOPPY_START
FLOPPY__MBR__FREE_TAIL
MEM_FLOPPY_START + 1
FLOPPY__MBR__SECTOR
0x00
FLOPPY__SECTOR__DATA
MEM_FLOPPY_START + 1
FLOPPY__SECTOR__NEXT
MEM_FLOPPY_START
FLOPPY__STATE__BUSY
0x03
FLOPPY__STATE__NO_MEDIA
0x00
FLOPPY__STATE__READY
0x01
FLOPPY__STATE__READY_WP
0x02
FONT_COLOR
0x7000
FPV_EXPONENT
-3
FPV_EXPONENT_MODIFIER
-4
FPV_EXPONENT_NEGATIVE
-2
FPV_STATE
-5
FP_STATE_DECIMAL_POINT
8
FP_STATE_DIGIT_DECIMAL
16
FP_STATE_DIGIT_WHOLE
4
FP_STATE_E
32
FP_STATE_EXPONENT_DIGIT
128
FP_STATE_EXPONENT_SIGN
64
FP_STATE_SIGN
2
FP_STATE_START
1
HANDLE_NEXT
3
HANDLE_PTR
0
HANDLE_SIZE
2
HANDLE_TYPE
1
HEAP_GC_TRIGGER
40
HISTORY_SIZE
5
INODE__LENGTH
0
INODE__SECTOR__HEAD
1
INODE__SECTOR__TAIL
2
INODE__SIZE
3
INT_DATA
1
INT_DIVISION_QUOTIENT
1
INT_DIVISION_REMAINDER
2
INT_LEN
0
KEY_BS
0x10
KEY_CTRL
0x91
KEY_CTRL_C
0x8043
KEY_CTRL_MASK
0x8000
KEY_CTRL_X
0x8058
KEY_DEL
0x13
KEY_DOWN
0x81
KEY_INSERT
0x12
KEY_LEFT
0x82
KEY_NEWLINE
0x11
KEY_RIGHT
0x83
KEY_SHIFT
0x90
KEY_SHIFT_MASK
0x4000
KEY_UP
0x80
LEXER__END
5
LEXER__INDENT_CURRENT
2
LEXER__INDENT_TARGET
1
LEXER__START
4
LEXER__STR
0
LEXER__TOKEN
3
MEM_CODE_SIZE
0x4000
MEM_FLOPPY_END
MEM_SCREEN_START
MEM_FLOPPY_SIZE
0x200
MEM_FLOPPY_START
MEM_FLOPPY_END - MEM_FLOPPY_SIZE
MEM_HEAP_END
MEM_FLOPPY_START
MEM_HEAP_START
MEM_CODE_SIZE
MEM_SCREEN_END
MEM_STACK_START
MEM_SCREEN_SIZE
0x480
MEM_SCREEN_START
MEM_SCREEN_END - MEM_SCREEN_SIZE
MEM_STACK_END
0x10000
MEM_STACK_SIZE
0x2000
MEM_STACK_START
MEM_STACK_END - MEM_STACK_SIZE
PROTOTYPE_LBP
3
PROTOTYPE_LED
2
PROTOTYPE_NUD
1
PROTOTYPE_STD
0
REFERENCE_LEFT
1
REFERENCE_RIGHT
2
REGISTER_A
MEM_FLOPPY_END - 5
REGISTER_B
MEM_FLOPPY_END - 4
REGISTER_C
MEM_FLOPPY_END - 3
REGISTER_X
MEM_FLOPPY_END - 2
REGISTER_Y
MEM_FLOPPY_END - 1
SCOPE_MODE_INSERT
0x0004
SCOPE_MODE_UPDATE
0x0002
SCREEN_COLS
32
SCREEN_ROWS
12
SCREEN__CURSOR
2
SCREEN__END
1
SCREEN__START
0
SIZEOF_CONTROL
3
SIZEOF_FLOAT
4
SIZEOF_HANDLE
4
SIZEOF_LEXER
6
SIZEOF_SCREEN
3
SIZEOF__INODE
4
SUBSCRIPTION_INDEX
2
SUBSCRIPTION_LIST
1
TRUE
1
TYPE_BOOL
0x0010
TYPE_CONTROL
0x2000
TYPE_DICT
0x0001
TYPE_EXTENSION
0x1000
TYPE_FLOAT
0x0040
TYPE_GROUP_ALL
0x3fff
TYPE_GROUP_CAN_REFERENCE
TYPE_LIST + TYPE_DICT + TYPE_STR
TYPE_GROUP_CONTAINER
TYPE_CONTROL + TYPE_TUPLE + TYPE_LIST + TYPE_DICT + TYPE_TUPLE_COMMA + TYPE_REFERENCE + TYPE_SUBSCRIPTION
TYPE_GROUP_IMMUTABLE
TYPE_STR + TYPE_INT + TYPE_FLOAT + TYPE_BOOL + TYPE_NONE
TYPE_GROUP_INTEGER
TYPE_INT + TYPE_BOOL
TYPE_GROUP_NON_INTEGER
0xffcf
TYPE_GROUP_NUMERIC
TYPE_GROUP_INTEGER + TYPE_FLOAT
TYPE_GROUP_RUNNABLE
TYPE_DICT + TYPE_STR
TYPE_INT
0x0020
TYPE_LIST
0x0002
TYPE_MARKED
0x8000
TYPE_NAME
0x0800
TYPE_NONE
0x0080
TYPE_REFERENCE
0x0400
TYPE_STR
0x0008
TYPE_SUBSCRIPTION
0x0200
TYPE_TUPLE
0x0004
TYPE_TUPLE_COMMA
0x0100
TYPE_VOID
0x4000
1048
BOOL_FALSE
743
BOOL_TRUE
745
FLOAT_0
781
FLOAT_1
787
FLOAT_10
841
FLOAT_2
793
FLOAT_3
799
FLOAT_4
805
FLOAT_5
811
FLOAT_6
817
FLOAT_7
823
FLOAT_8
829
FLOAT_9
835
FLOAT_NAN
747
FLOAT_NINF
759
FLOAT_NZERO
765
FLOAT_PINF
753
FLOAT_PZERO
781
FLOAT_TABLE
771
HEX
1024
INT_0
675
INT_1
679
INT_10
715
INT_11
719
INT_12
723
INT_13
727
INT_14
731
INT_15
735
INT_16
739
INT_2
683
INT_3
687
INT_4
691
INT_5
695
INT_6
699
INT_7
703
INT_8
707
INT_9
711
INT_N1
671
INT_TABLE
675
NONE
667
STR_ARGV
992
STR_AUTOEXEC
960
STR_EMPTY
1021
STR_ERROR
951
STR_EX
982
STR_FALSE
1013
STR_MAIN
971
STR_ME
987
STR_NAN
873
STR_NINF
853
STR_NONE
999
STR_NZERO
866
STR_PINF
847
STR_PROMPT
947
STR_PZERO
860
STR_STARTUP
879
STR_STARTUP2
914
STR_STARTUP3
933
STR_TRUE
1006
STR_UNDERSCORE
978
VOID
669
_float__nlz16
6740
_float__special_values
6794
_float_cmp_abs
6768
add_char_backspace
12071
add_char_clear
12062
add_char_copy
12057
add_char_finish
12067
add_char_newline
12040
add_char_scroll
12044
alloc
8659
alloc__finish
8683
alloc__handle__new
8706
allocate_chars
9129
array__append
10200
array__append_array
10215
array__append_array__finish
10235
array__append_array__loop
10222
array__del
10123
array__del__finish
10142
array__del__loop
10136
array__get
10111
array__get_memory_addr
10145
array__get_memory_addr__out_of_bounds
10162
array__increment_length
10243
array__insert
10165
array__insert__finish
10196
array__insert__loop
10190
array__set
10116
array_clone
10442
array_clone_finish
10463
array_clone_loop
10457
array_cmp
10338
array_cmp_break__left
10367
array_cmp_break__right
10372
array_cmp_loop
10352
array_comparator
7974
array_comparator_true
7983
array_create
10096
array_find
10489
array_find__loop
10501
array_finish_inner
10437
array_map
10468
array_map__finish
10484
array_map__loop
10475
array_merge
10299
array_merge__left_loop
10322
array_merge__right
10328
array_merge__right_loop
10332
array_repeat
10375
array_repeat_loop
10400
array_reverse_comparator
7985
array_sort
10408
array_sort_inner
10425
array_sort_outer
10419
array_split
10254
array_split_loop
10291
assign
7994
assign_from_string
8113
assign_name
8072
assign_reference
8061
assign_reference_or_subscription_dict
8066
assign_subscription
8028
assign_subscription_dict
8057
assign_subscription_list_int
8049
assign_tuple
8082
assign_tuple_break
8110
assign_tuple_loop
8089
bol
11617
boolean
7849
boolean_false
7891
boolean_operator
3182
boolean_str
7895
boolean_true
7887
buf_end
608
buf_start
607
built_in
4273
built_in__dict_create
4330
built_in__dict_methods
1578
built_in__global_functions
4314
built_in__list_append
4351
built_in__list_insert
4364
built_in__list_methods
1560
built_in__object_functions
4287
built_in__object_method__init
4322
built_in__str_crypt
11013
built_in__str_decrypt
10974
built_in__str_encrypt
10988
built_in__str_encrypt__iv_loop
11002
built_in__str_endswith
10907
built_in__str_endswith__cmp
10959
built_in__str_find
10847
built_in__str_find__finish
10896
built_in__str_find__no_end
10895
built_in__str_find__no_start
10894
built_in__str_isalpha
10755
built_in__str_isalpha_loop
10765
built_in__str_isdigit
10782
built_in__str_isdigit_loop
10792
built_in__str_lower
10803
built_in__str_lower_loop
10813
built_in__str_methods
1588
built_in__str_replace
11042
built_in__str_replace__do_replace
11100
built_in__str_replace__finish
11109
built_in__str_replace__loop
11081
built_in__str_replace__loop_restart
11071
built_in__str_split
11113
built_in__str_split__loop
11138
built_in__str_split__ws
11174
built_in__str_split__ws__add_char
11198
built_in__str_split__ws__handle_ws
11205
built_in__str_split__ws_exit
11229
built_in__str_split__ws_finish
11219
built_in__str_startswith
10911
built_in__str_startswith__cmp
10947
built_in__str_upper
10826
built_in__str_upper_loop
10836
built_in__str_xwith
10913
built_in__str_xwith__array
10930
built_in__str_xwith__array_loop
10933
built_in__str_xwith__str
10944
built_in_abs
4668
built_in_bool
4942
built_in_call
5148
built_in_call_registers
5168
built_in_chr
4548
built_in_cmp
4526
built_in_cursor
5050
built_in_cursor_coords
5066
built_in_dir
4724
built_in_edit
4591
built_in_exit
4506
built_in_float
4846
built_in_float_bool
4878
built_in_float_float
4893
built_in_float_int
4873
built_in_float_string
4888
built_in_format
4733
built_in_functions
1316
built_in_getchar
4953
built_in_getchar_loop
4958
built_in_globals
4517
built_in_hex
4909
built_in_hwi
5312
built_in_hwn
5301
built_in_hwq
5335
built_in_id
4382
built_in_input
4393
built_in_int
4796
built_in_int_bool
4826
built_in_int_float
4841
built_in_int_int
4823
built_in_int_string
4836
built_in_key
4972
built_in_key_1
4993
built_in_key_1_int
5012
built_in_key_1_key
5016
built_in_len
4693
built_in_load
4744
built_in_locals
4508
built_in_matcher
8552
built_in_matcher_cmp_loop
8565
built_in_matcher_list_loop
8555
built_in_mem
4488
built_in_ord
4570
built_in_params
5442
built_in_params_end
5469
built_in_params_loop
5443
built_in_peek
5180
built_in_peek_str
5203
built_in_peek_str_loop
5222
built_in_poke
5228
built_in_poke_str
5263
built_in_poke_str_loop
5267
built_in_range
4413
built_in_range_2
4427
built_in_range_3
4433
built_in_range_break
4484
built_in_range_loop
4459
built_in_read
5273
built_in_read_and_write
5277
built_in_repr
4896
built_in_rm
4780
built_in_rnd
4610
built_in_rnd_1
4621
built_in_rnd_2
4640
built_in_rnd_finish
4654
built_in_save
4760
built_in_scroll
5409
built_in_sort
5026
built_in_sort_2
5039
built_in_stmts
1684
built_in_str
4926
built_in_type
4711
built_in_win_get
5104
built_in_win_set
5126
built_in_write
5276
cast_common_number_type
8199
char_comparator
7943
char_reverse_comparator
7951
check_augass
7377
clock
593
cmp__finish
7671
compact
8724
compact_copy_loop
8747
compact_finish
8753
compact_loop
8732
compare_operator
3438
crypt__DMix
13261
crypt__DWD16
13248
crypt__DWD16_loop
13251
crypt__Decrypt
13021
crypt__Decrypt_loop
13030
crypt__EMix
13234
crypt__EWD16
13220
crypt__EWD16_loop
13223
crypt__Encrypt
12929
crypt__Encrypt_loop
12938
crypt__FuncS
13285
crypt__FuncS_loop
13293
crypt__Init
13131
crypt__Init_loop
13156
crypt__Return
13318
crypt__SBoxD
651
crypt__SBoxE
635
crypt__State
627
crypt__Update_State
13110
cur_line
614
cur_pos
613
cur_x
615
cur_y
616
current_scope
566
current_screen
570
debug
533
debug__char
552
debug__loop
537
del
8157
del_name
8190
detect_hardware
8420
detect_hardware__loop
8421
dict__bin_search
12205
dict__bin_search__loop
12211
dict__bin_search__lower
12237
dict__bin_search__upper
12233
dict__del__finish
12190
dict__del__match
12192
dict__del__no_match
12109
dict__get__finish
623
dict__get__match
12099
dict__get__no_match
12109
dict__set
12116
dict__set__finish
625
dict__set__match
12154
dict__set__no_match
12158
dict_del
12169
dict_get
12078
dict_repr
12241
dict_repr_finish
12318
dict_repr_loop
12261
dict_repr_skip_comma
12273
dict_set_skip
12139
division_16
9894
division__nbit_8bit
9905
division__nbit_8bit__loop
9917
division_cmp_loop
9872
division_finish
9944
division_finish_signs
9956
division_loop
9842
division_return_tuple
9995
division_set_modulo_sign
9985
division_subtract_loop
9884
edit_copy_arg_to_buffer
11277
edit_copy_buffer_to_result
11369
edit_gap_move
11562
edit_gap_move_loop
11566
edit_insert_char
11587
edit_key_bs
11459
edit_key_character
11476
edit_key_del
11452
edit_key_down
11396
edit_key_left
11420
edit_key_newline
11480
edit_key_newline_loop
11486
edit_key_right
11433
edit_key_up
11380
edit_line_chars
11526
edit_line_chars_loop
11529
edit_line_chars_loop_1
11545
edit_line_draw
11506
edit_line_skip_end
11551
edit_line_skip_start
11507
edit_main
11233
edit_main_finish
11346
edit_main_loop
11286
edit_remove_char
11599
edit_win_draw
11494
edit_win_draw_loop
11499
eol
11634
eval
7676
eval_name
7706
eval_reference
7737
eval_subscription
7749
eval_subscription_array
7781
eval_subscription_array_index
7792
eval_subscription_array_slice
7798
eval_subscription_dict
7772
eval_subscription_str
7814
eval_subscription_str_index
7825
eval_subscription_str_slice
7798
eval_tuple
7716
eval_tuple_break
7733
eval_tuple_loop
7720
expr_finish
2770
expr_loop
2752
expression
2740
expression_callback
2766
ffs_add_significant
6406
ffs_decimal_point
6487
ffs_end
6504
ffs_exponent
6495
ffs_exponent_minus
6468
ffs_exponent_number
6424
ffs_fraction
6398
ffs_loop
6349
ffs_mantissa_minus
6458
ffs_minus
6447
ffs_overflow
6439
ffs_plus
6475
ffs_scale_loop
6546
ffs_whole_number
6404
finish
8531
finish_loop
8544
float__abs
5517
float__add
5595
float__add__align_exp
5624
float__add__num
5616
float__add__op_add
5679
float__add__op_sub
5654
float__add__special_values
6815
float__cmp
5565
float__cmp__finish
5590
float__cmp__float_int
5529
float__cmp__int_float
5547
float__div
5842
float__div__cmp
5901
float__div__next_bit
5913
float__div__nnum
5867
float__div__no_word
5926
float__div__normalize
5947
float__div__num
5872
float__div__pnum
5870
float__div__shift_divident
5935
float__div__special_values
6887
float__from_int
5975
float__from_str
6279
float__from_uint
6139
float__mul
5727
float__mul__nnum
5742
float__mul__no_normalize
5834
float__mul__num
5747
float__mul__pnum
5745
float__mul__special_values
6851
float__negate
5496
float__negate__abs_merge
5500
float__nlz16
6734
float__nlz2
6758
float__nlz32
6723
float__nlz4
6752
float__nlz8
6746
float__pow
6214
float__pow__break
6267
float__pow__calc
6236
float__pow__loop
6242
float__pow__skip
6256
float__random
6155
float__return_i
6951
float__return_inf
6927
float__return_j
6958
float__return_nan
6923
float__return_ninf
6935
float__return_nzero
6947
float__return_pinf
6931
float__return_pzero
6943
float__return_zero
6939
float__sub
5709
float__to_int
6047
float__to_int__finish
6116
float__to_str
6582
float__to_uint
6124
floppy
594
floppy__buffer__position
581
floppy__dir
584
floppy__dir__head
584
floppy__dir__read
12376
floppy__dir__tail
585
floppy__dir__write
12508
floppy__file__close
12875
floppy__file__delete
12465
floppy__file__free
12634
floppy__file__open
12867
floppy__file__position
580
floppy__file__read
12436
floppy__file__write
12385
floppy__file__write__update_dir
12418
floppy__format
12328
floppy__format__next_sector
12349
floppy__free
582
floppy__free__head
582
floppy__free__tail
583
floppy__inode__wrapper
12613
floppy__item__deserialize
12773
floppy__item__deserialize__add_item
12833
floppy__item__deserialize__array_loop
12821
floppy__item__deserialize__data
12812
floppy__item__deserialize__finish
12854
floppy__item__deserialize__known_item
12805
floppy__item__deserialize__new_item
12842
floppy__item__deserialize__next_item
12778
floppy__item__deserialize__skip_length
12820
floppy__item__deserialize_search
12858
floppy__item__deserialize_search_loop
12860
floppy__item__read
12761
floppy__item__serialize
12699
floppy__item__serialize__data__loop
12731
floppy__item__serialize__finish
12756
floppy__item__serialize__next_item
12707
floppy__item__serialize__search_item
12746
floppy__item__write
12654
floppy__mbr__read
12541
floppy__mbr__write
12557
floppy__sector__read
12588
floppy__sector__write
12573
floppy__status__wait_ready
12606
floppy__status__wait_ready__loop
12607
floppy__word__read
12912
floppy__word__read__use_buffer
12921
floppy__word__write
12886
floppy__word__write__use_buffer
12902
free_memory
8712
fts_fill_with_zero
6703
fts_finish
6719
fts_print
6655
fts_scale_down
6635
fts_scale_up
6683
gap_end
610
gap_start
609
global_scope
565
heap_counter
595
heap_free_start
596
heap_handle_free
600
heap_handle_head
598
heap_handle_start
597
heap_handle_tail
599
history
567
infix
4191
infix_1
4195
infixr
4183
input_loop
8498
int_abs
9387
int_add
9549
int_add_copy_loop
9599
int_add_loop
9568
int_bitwise
9216
int_bitwise_and
9270
int_bitwise_loop
9245
int_bitwise_or
9210
int_bitwise_xor
9262
int_cmp
9460
int_cmp__finish
9520
int_cmp_gt
9528
int_cmp_loop
9510
int_cmp_lt
9525
int_complement
9404
int_div
9761
int_division
9785
int_extend
10061
int_extend_copy_loop
10076
int_extend_fill_loop
10086
int_extend_finish
10090
int_lshift
9278
int_lshift_loop
9310
int_mod
9773
int_mul
9671
int_mul_carry_break
9721
int_mul_carry_loop
9713
int_mul_words_loop
9704
int_negate
9411
int_negate_or_complement
9415
int_normalize
10006
int_normalize_copy_loop
10055
int_normalize_count_break
10031
int_normalize_count_loop
10015
int_parse
8899
int_parse_finish
8968
int_parse_hex
8979
int_parse_hex_0x
8999
int_parse_hex_check
8921
int_parse_hex_loop
9002
int_parse_hex_loop_continue
9023
int_parse_loop
8937
int_pow
9609
int_pow_0
9663
int_pow_1
9667
int_pow_break
9659
int_pow_loop
9634
int_pow_skip
9648
int_random
9144
int_random_loop
9170
int_rnd_lfsr
9197
int_rshift
9334
int_rshift_by_uint
9326
int_rshift_join
9342
int_rshift_loop
9371
int_rshift_real
9357
int_sgn
9439
int_sub
9531
int_to_hex
9065
int_to_int16
8892
int_to_str
9073
int_to_str_loop
9086
int_to_str_negative
9120
int_to_str_start
9079
interpreter__line_edit
226
interpreter__line_edit__del_char__break
385
interpreter__line_edit__del_char__loop
376
interpreter__line_edit__draw_char
465
interpreter__line_edit__get_str
505
interpreter__line_edit__get_str__finish
530
interpreter__line_edit__get_str__loop
521
interpreter__line_edit__history
312
interpreter__line_edit__history_loop
425
interpreter__line_edit__key_bs
362
interpreter__line_edit__key_character
448
interpreter__line_edit__key_character__break
460
interpreter__line_edit__key_character__loop
452
interpreter__line_edit__key_del
369
interpreter__line_edit__key_down
305
interpreter__line_edit__key_left
441
interpreter__line_edit__key_newline
392
interpreter__line_edit__key_newline__finish
430
interpreter__line_edit__key_newline__store
414
interpreter__line_edit__key_right
434
interpreter__line_edit__key_up
290
interpreter__line_edit__key_up__break1
324
interpreter__line_edit__key_up__loop1
318
interpreter__line_edit__key_up__loop2
351
interpreter__line_edit_main_loop
245
interpreter_loop
58
interpreter_loop_parse
71
interpreter_loop_parse_2
85
interpreter_main
0
itoa_reverse_string
9138
itof_left
8216
itof_right
8223
keyboard
591
led_and
3142
led_assign
3749
led_augass
3772
led_augass_and
3809
led_augass_lshift
3793
led_augass_minus
3817
led_augass_or
3801
led_augass_percent
3829
led_augass_plus
3813
led_augass_rshift
3797
led_augass_slash
3825
led_augass_star
3821
led_augass_xor
3805
led_bitwise_and
3643
led_bitwise_and_operation
3653
led_bitwise_or
3603
led_bitwise_or_operation
3613
led_bitwise_xor
3623
led_bitwise_xor_operation
3633
led_comma
4217
led_comma_add
4241
led_comma_end
4269
led_equal
3425
led_greater
3399
led_greater_or_equal
3386
led_in
3277
led_in_1
3282
led_in_dict
3328
led_in_found
3346
led_in_list
3338
led_in_not_found
3353
led_in_string
3318
led_is
3215
led_is_not
3260
led_lbrack
4005
led_lbrack_after_colon
4050
led_lbrack_dict
4104
led_lbrack_empty_after_colon
4088
led_lbrack_finish
4119
led_lbrack_parse_first
4035
led_less
3373
led_less_or_equal
3360
led_lparen
3833
led_lparen_arg_loop_condition
3937
led_lparen_args
3881
led_lparen_call
3967
led_lparen_control
3991
led_lparen_finish
3983
led_lparen_prepare_call
3942
led_lparen_user_defined
3839
led_lshift
3663
led_lshift_operation
3673
led_minus
3503
led_minus_operation
3513
led_not
3268
led_not_equal
3412
led_operation_tailer
3499
led_or
3162
led_percent
3729
led_percent_operation
3739
led_plus
3466
led_plus_operation
3476
led_power
3575
led_power_operation
3585
led_reference
4139
led_rshift
3683
led_rshift_operation
3693
led_slash
3703
led_slash_operation
3713
led_star
3529
led_star_operation
3539
lexer__exit
7112
lexer__get_line
7028
lexer__goto_eol
7046
lexer__goto_sol
7057
lexer_advance
7069
lexer_char_ambersand
7274
lexer_char_caret
7260
lexer_char_colon
7180
lexer_char_comma
7185
lexer_char_comment
7609
lexer_char_digit
7395
lexer_char_digit_loop
7412
lexer_char_digit_start
7415
lexer_char_dot
7162
lexer_char_eof
7388
lexer_char_equal
7295
lexer_char_exclamation
7370
lexer_char_greater
7336
lexer_char_greater_greater
7355
lexer_char_hex
7435
lexer_char_lbrack
7210
lexer_char_lcurly
7200
lexer_char_less
7302
lexer_char_less_less
7321
lexer_char_letter
7462
lexer_char_lparen
7190
lexer_char_minus
7227
lexer_char_newline
7116
lexer_char_newline_break
7131
lexer_char_newline_loop
7121
lexer_char_newline_restart
7119
lexer_char_percent
7288
lexer_char_plus
7220
lexer_char_quotationmark
7495
lexer_char_rbrack
7215
lexer_char_rcurly
7205
lexer_char_rparen
7195
lexer_char_slash
7281
lexer_char_star
7234
lexer_char_star_assign
7250
lexer_char_star_star
7255
lexer_char_tilde
7175
lexer_char_vbar
7267
lexer_char_whitespace
7614
lexer_current_indent
603
lexer_dedent
7155
lexer_end
606
lexer_finish
7110
lexer_finish_advance
7109
lexer_float
7519
lexer_float_decimal_number
7558
lexer_float_decimal_point
7576
lexer_float_exponent
7582
lexer_float_exponent_number
7564
lexer_float_finish
7589
lexer_float_integral_number
7561
lexer_float_loop
7522
lexer_float_minus
7568
lexer_float_plus
7568
lexer_get_token_as_string
7013
lexer_indent
7148
lexer_init
6965
lexer_literal_string_loop
7498
lexer_name_loop
7462
lexer_next
7078
lexer_restore
6994
lexer_skip_white
7601
lexer_start
605
lexer_store
6980
lexer_string
601
lexer_table
1825
lexer_target_indent
602
lexer_token
604
line_editor__buf_index
618
line_editor__current_addr
620
line_editor__end_addr
621
line_editor__last_char
622
line_editor__start_addr
619
list_cmp
10566
list_del
10547
list_get
10515
list_repr
10572
list_repr_finish
10628
list_repr_loop
10598
list_repr_skip_comma
10610
list_set
10530
load_registers
5474
mark
8759
mark__advance
8778
mark__free_loop
8786
mark__free_loop__break
8814
mark__free_loop__marked
8794
mark__free_loop__unmarked
8804
mark__loop_references
8770
mark__process_frame
8767
mark_handle
8820
mem_clear
8843
mem_clear__loop
8854
monitor
592
next_char_loop
8496
nextline
11663
nud_false
2872
nud_float
2843
nud_generic
2849
nud_hex
2839
nud_int
2847
nud_lbrack
2914
nud_lbrack_change_type
2948
nud_lbrack_continue
2952
nud_lbrack_empty
2960
nud_lcurly
2968
nud_lcurly_finish
3034
nud_lcurly_loop
2978
nud_lparen
2877
nud_lparen_empty
2906
nud_minus
3049
nud_name
2830
nud_none
2862
nud_not
3113
nud_plus
3042
nud_str
2830
nud_tilde
3084
nud_tilde_int
3108
nud_true
2867
parse_testlist_item
4004
parse_testlist_item_assign
3911
parser_fork_scope
2548
parser_simple_stmt
1960
parser_skip_suite
2654
parser_skip_suite_block
2671
parser_skip_suite_block_loop
2678
parser_skip_suite_simple_stmt
2663
parser_skip_suite_simple_stmt_finish
2667
parser_skip_until_token
2638
parser_skip_until_token_finish
2652
parser_stmt
1953
parser_suite
2693
parser_suite_block
2706
parser_suite_block_break
2731
parser_suite_block_loop
2712
parser_suite_simple_stmt
2702
pos_x
11673
postamble
8230
preamble
8249
preamble_init_local
8261
prev_char
617
prevline
11650
print
8272
print_loop
8292
print_loop__check
8295
print_loop_escape
8308
print_loop_newline
8321
print_repr
8266
print_skip_repr
8291
print_with_repr
8283
quotient_shift_loop
9860
raw_input
8474
raw_input_no_prompt
8492
realloc
8581
realloc__copy_loop
8611
realloc__grow
8597
realloc__remove_from_list
8623
realloc__remove_from_list__break
8638
realloc__remove_from_list__loop
8630
realloc__set_handle_values
8647
realloc__zero_loop
8617
recover
198
recovery_fp
568
recovery_sp
569
remainder_shift_loop
9849
repr
8326
repr_boolean
8407
repr_none
8416
repr_string
8374
return_false
8577
return_true
8573
rintti
6561
rnd_lcg_seed
589
rnd_lfsr_poly
588
rnd_lfsr_seed
586
save_registers
5485
scope_del
121
scope_get
92
scope_set
150
scope_set_insert
187
scope_set_no_parent
183
screen__get
11927
screen__get_cursor
11966
screen__get_x
5070
screen__get_y
5088
screen__scroll
11832
screen__scroll__loop
11898
screen__set
11945
screen_add_char
12020
screen_clear
12002
screen_clear_finish
12016
screen_clear_loop
12012
screen_first
571
screen_last
577
screen_move_cursor
11816
screen_next
11792
screen_prev
11784
screen_select
11798
screen_toggle_cursor
11809
sort
7905
sort_array
7959
sort_string
7923
std_break
2280
std_cls
1989
std_continue
2280
std_dedent
1987
std_del
2426
std_del_break
2448
std_del_loop
2428
std_eof
1983
std_expression
2735
std_for
2321
std_for_control
2397
std_for_control_break
2415
std_for_control_continue
2376
std_for_control_return
2421
std_for_eof
2419
std_for_execute_suite
2369
std_for_finish
2417
std_for_loop
2351
std_for_loop_string
2380
std_for_loop_string_tuple
2391
std_if
2452
std_if_else
2531
std_if_eof
2544
std_if_false
2517
std_if_skip
2505
std_if_skip_loop
2492
std_indent
1987
std_newline
1981
std_pass
2307
std_print
2175
std_print_array
2207
std_print_break_eof
2235
std_print_break_newline
2231
std_print_iterator
2219
std_print_loop
2177
std_reset
1997
std_return
2242
std_return_finish
2276
std_run
2002
std_run_args
2082
std_run_autoexec
2030
std_run_call
2138
std_run_control
2162
std_run_finish
2154
std_run_init_lexer
2136
std_run_load
2033
std_run_prepare
2110
std_while
2567
std_while_control
2603
std_while_control_break
2621
std_while_control_continue
2599
std_while_control_return
2633
std_while_eof
2631
std_while_false
2629
std_while_loop
2573
str_cmp
10644
str_cmp_ignore_case
10662
str_comparator
10650
str_comparator__ignore_case
10668
str_search
10718
str_search_3
10688
str_search_inner_loop
10740
str_search_no_match
10752
str_search_outer_loop
10732
testlist
2774
testlist_callback
2826
testlist_loop
2797
token_and
1204
token_assign
1148
token_augass_and
1180
token_augass_lshift
1184
token_augass_minus
1156
token_augass_or
1172
token_augass_percent
1168
token_augass_plus
1152
token_augass_rshift
1188
token_augass_slash
1164
token_augass_star
1160
token_augass_xor
1176
token_bitwise_and
1252
token_bitwise_or
1244
token_bitwise_xor
1248
token_break
1132
token_cls
1096
token_colon
1196
token_comma
1192
token_continue
1144
token_dedent
1052
token_del
1100
token_elif
1112
token_else
1116
token_eof
1040
token_equal
1220
token_false
1084
token_float
1064
token_for
1104
token_greater
1232
token_greater_or_equal
1236
token_hex
1060
token_if
1092
token_in
1208
token_indent
1048
token_int
1056
token_is
1216
token_lbrack
1288
token_lcurly
1304
token_less
1224
token_less_or_equal
1228
token_lparen
1296
token_lshift
1256
token_minus
1268
token_name
1068
token_newline
1044
token_none
1076
token_not
1212
token_not_equal
1240
token_or
1200
token_pass
1120
token_percent
1280
token_plus
1264
token_power
1284
token_print
1124
token_rbrack
1292
token_rcurly
1308
token_reference
1312
token_reset
1136
token_return
1140
token_rparen
1300
token_rshift
1260
token_run
1108
token_slash
1276
token_star
1272
token_str
1072
token_tilde
1088
token_true
1080
token_while
1128
uint16_to_int
8866
uint16_to_int__optimize
8885
val_cmp
7616
win_getchar
8451
win_normalize
11701
win_normalize_1
11725
win_normalize_2
11707
win_normalize_3
11739
win_normalize_4
11729
win_normalize_5
11751
win_normalize_6
11741
win_normalize_7
11774
win_normalize_8
11763
win_shift
612
win_start
611
win_x
11688
win_x_loop
11691
xor_loop
9430
defs.dasm16
0
0
;----------------------------------------------------------------
defs.dasm16
1
0
; MEMORY LAYOUT
defs.dasm16
2
0
; 29440 bytes is the maximum file size for admiral.bin
defs.dasm16
3
0
; the optimal value for MEM_CODE_SIZE is len(admiral.bin)/2
defs.dasm16
4
0
;----------------------------------------------------------------
defs.dasm16
5
0
#define MEM_CODE_SIZE          0x4000
defs.dasm16
6
0
#define MEM_FLOPPY_SIZE        0x200
defs.dasm16
7
0
#define MEM_SCREEN_SIZE        0x480
defs.dasm16
8
0
#define MEM_STACK_SIZE         0x2000
defs.dasm16
9
0

defs.dasm16
10
0
#define MEM_STACK_END          0x10000
defs.dasm16
11
0
#define MEM_STACK_START        MEM_STACK_END - MEM_STACK_SIZE
defs.dasm16
12
0

defs.dasm16
13
0
#define MEM_SCREEN_END         MEM_STACK_START
defs.dasm16
14
0
#define MEM_SCREEN_START       MEM_SCREEN_END - MEM_SCREEN_SIZE
defs.dasm16
15
0

defs.dasm16
16
0
#define MEM_FLOPPY_END         MEM_SCREEN_START
defs.dasm16
17
0
#define MEM_FLOPPY_START       MEM_FLOPPY_END - MEM_FLOPPY_SIZE
defs.dasm16
18
0

defs.dasm16
19
0
#define MEM_HEAP_START         MEM_CODE_SIZE
defs.dasm16
20
0
#define MEM_HEAP_END           MEM_FLOPPY_START
defs.dasm16
21
0

defs.dasm16
22
0
#define REGISTER_A             MEM_FLOPPY_END - 5
defs.dasm16
23
0
#define REGISTER_B             MEM_FLOPPY_END - 4
defs.dasm16
24
0
#define REGISTER_C             MEM_FLOPPY_END - 3
defs.dasm16
25
0
#define REGISTER_X             MEM_FLOPPY_END - 2
defs.dasm16
26
0
#define REGISTER_Y             MEM_FLOPPY_END - 1
defs.dasm16
27
0

defs.dasm16
28
0
;----------------------------------------------------------------
defs.dasm16
29
0
; DATA TYPES
defs.dasm16
30
0
;----------------------------------------------------------------
defs.dasm16
31
0
; SYSTEM TYPES
defs.dasm16
32
0
#define TYPE_MARKED         0x8000
defs.dasm16
33
0
#define TYPE_VOID           0x4000
defs.dasm16
34
0
#define TYPE_CONTROL        0x2000
defs.dasm16
35
0
#define TYPE_EXTENSION      0x1000
defs.dasm16
36
0

defs.dasm16
37
0
; INTERNAL SYSTEM TYPES
defs.dasm16
38
0
#define TYPE_NAME           0x0800
defs.dasm16
39
0
#define TYPE_REFERENCE      0x0400
defs.dasm16
40
0
#define TYPE_SUBSCRIPTION   0x0200
defs.dasm16
41
0
#define TYPE_TUPLE_COMMA    0x0100
defs.dasm16
42
0

defs.dasm16
43
0
; USER TYPES
defs.dasm16
44
0
#define TYPE_NONE           0x0080
defs.dasm16
45
0
#define TYPE_FLOAT          0x0040
defs.dasm16
46
0
#define TYPE_INT            0x0020
defs.dasm16
47
0
#define TYPE_BOOL           0x0010
defs.dasm16
48
0

defs.dasm16
49
0
#define TYPE_STR            0x0008
defs.dasm16
50
0
#define TYPE_TUPLE          0x0004
defs.dasm16
51
0
#define TYPE_LIST           0x0002
defs.dasm16
52
0
#define TYPE_DICT           0x0001
defs.dasm16
53
0

defs.dasm16
54
0
; TYPE GROUPS
defs.dasm16
55
0
#define TYPE_GROUP_CONTAINER        TYPE_CONTROL + TYPE_TUPLE + TYPE_LIST + TYPE_DICT + TYPE_TUPLE_COMMA + TYPE_REFERENCE + TYPE_SUBSCRIPTION
defs.dasm16
56
0
#define TYPE_GROUP_IMMUTABLE        TYPE_STR + TYPE_INT + TYPE_FLOAT + TYPE_BOOL + TYPE_NONE
defs.dasm16
57
0
#define TYPE_GROUP_RUNNABLE         TYPE_DICT + TYPE_STR
defs.dasm16
58
0
#define TYPE_GROUP_CAN_REFERENCE    TYPE_LIST + TYPE_DICT + TYPE_STR
defs.dasm16
59
0
#define TYPE_GROUP_INTEGER          TYPE_INT + TYPE_BOOL
defs.dasm16
60
0
;define TYPE_GROUP_NON_INTEGER      0xffff - TYPE_GROUP_INTEGER
defs.dasm16
61
0
#define TYPE_GROUP_NON_INTEGER      0xffcf
defs.dasm16
62
0
#define TYPE_GROUP_NUMERIC          TYPE_GROUP_INTEGER + TYPE_FLOAT
defs.dasm16
63
0
#define TYPE_GROUP_ALL              0x3fff
defs.dasm16
64
0

defs.dasm16
65
0
;----------------------------------------------------------------
defs.dasm16
66
0
; PARAMETERS
defs.dasm16
67
0
;----------------------------------------------------------------
defs.dasm16
68
0
#define FONT_COLOR              0x7000
defs.dasm16
69
0

defs.dasm16
70
0
#define HISTORY_SIZE            5
defs.dasm16
71
0

defs.dasm16
72
0
#define EDIT_BUFFER_SIZE        0x0400
defs.dasm16
73
0
#define HEAP_GC_TRIGGER         40
defs.dasm16
74
0

defs.dasm16
75
0
;----------------------------------------------------------------
defs.dasm16
76
0
; CONSTANTS
defs.dasm16
77
0
;----------------------------------------------------------------
defs.dasm16
78
0
#define TRUE            1
defs.dasm16
79
0
#define FALSE           0
defs.dasm16
80
0

defs.dasm16
81
0
#define SCREEN_COLS     32
defs.dasm16
82
0
#define SCREEN_ROWS     12
defs.dasm16
83
0

defs.dasm16
84
0
#define KEY_BS          0x10
defs.dasm16
85
0
#define KEY_NEWLINE     0x11
defs.dasm16
86
0
#define KEY_INSERT      0x12
defs.dasm16
87
0
#define KEY_DEL         0x13
defs.dasm16
88
0
#define KEY_UP          0x80
defs.dasm16
89
0
#define KEY_DOWN        0x81
defs.dasm16
90
0
#define KEY_LEFT        0x82
defs.dasm16
91
0
#define KEY_RIGHT       0x83
defs.dasm16
92
0
#define KEY_SHIFT       0x90
defs.dasm16
93
0
#define KEY_CTRL        0x91
defs.dasm16
94
0
#define KEY_CTRL_MASK   0x8000
defs.dasm16
95
0
#define KEY_SHIFT_MASK  0x4000
defs.dasm16
96
0
#define KEY_CTRL_X      0x8058
defs.dasm16
97
0
#define KEY_CTRL_C      0x8043
defs.dasm16
98
0

defs.dasm16
99
0
#define SCOPE_MODE_UPDATE   0x0002
defs.dasm16
100
0
#define SCOPE_MODE_INSERT   0x0004
defs.dasm16
101
0

defs.dasm16
102
0
#define FLOPPY__MBR__SECTOR                0x00
defs.dasm16
103
0
#define FLOPPY__MBR__FREE_HEAD            MEM_FLOPPY_START
defs.dasm16
104
0
#define FLOPPY__MBR__FREE_TAIL            MEM_FLOPPY_START + 1
defs.dasm16
105
0
#define FLOPPY__MBR__DIR_HEAD            MEM_FLOPPY_START + 2
defs.dasm16
106
0
#define FLOPPY__MBR__DIR_TAIL            MEM_FLOPPY_START + 3
defs.dasm16
107
0

defs.dasm16
108
0
; data sector definitions
defs.dasm16
109
0
#define FLOPPY__SECTOR__NEXT            MEM_FLOPPY_START
defs.dasm16
110
0
#define FLOPPY__SECTOR__DATA            MEM_FLOPPY_START + 1
defs.dasm16
111
0

defs.dasm16
112
0
#define FLOPPY__STATE__NO_MEDIA                0x00
defs.dasm16
113
0
#define FLOPPY__STATE__READY                0x01
defs.dasm16
114
0
#define FLOPPY__STATE__READY_WP                0x02
defs.dasm16
115
0
#define FLOPPY__STATE__BUSY                    0x03
defs.dasm16
116
0

defs.dasm16
117
0
#define FLOAT_TYPE_NAN   0x8000
defs.dasm16
118
0
#define FLOAT_TYPE_PINF  -3
defs.dasm16
119
0
#define FLOAT_TYPE_PNUM  -2
defs.dasm16
120
0
#define FLOAT_TYPE_PZERO -1
defs.dasm16
121
0
#define FLOAT_TYPE_DBZ    0
defs.dasm16
122
0
#define FLOAT_TYPE_NZERO  1
defs.dasm16
123
0
#define FLOAT_TYPE_NNUM   2
defs.dasm16
124
0
#define FLOAT_TYPE_NINF   3
defs.dasm16
125
0
;----------------------------------------------------------------
defs.dasm16
126
0
; DATA STRUCTURE DEFINITIONS
defs.dasm16
127
0
;----------------------------------------------------------------
defs.dasm16
128
0
;----------------------------------------------------------------
defs.dasm16
129
0
; MEMORY
defs.dasm16
130
0
;
defs.dasm16
131
0
; struct handle {
defs.dasm16
132
0
;   uint16 *data;
defs.dasm16
133
0
;   uint16 type;
defs.dasm16
134
0
;   uint16 size;
defs.dasm16
135
0
;   struct handle *next;
defs.dasm16
136
0
; }
defs.dasm16
137
0
#define SIZEOF_HANDLE       4
defs.dasm16
138
0
#define HANDLE_PTR      0
defs.dasm16
139
0
#define HANDLE_TYPE     1
defs.dasm16
140
0
#define HANDLE_SIZE     2
defs.dasm16
141
0
#define HANDLE_NEXT     3
defs.dasm16
142
0

defs.dasm16
143
0
; struct float {
defs.dasm16
144
0
;    uint16 size;
defs.dasm16
145
0
;    uint16 type;
defs.dasm16
146
0
;    uint16 exponent;
defs.dasm16
147
0
;    uint16 mantissa high;
defs.dasm16
148
0
;    uint16 mantissa low;
defs.dasm16
149
0
; }
defs.dasm16
150
0

defs.dasm16
151
0
; OFFSETS
defs.dasm16
152
0
#define SIZEOF_FLOAT       4
defs.dasm16
153
0
#define FLOAT_TYPE         0
defs.dasm16
154
0
#define FLOAT_EXP          1
defs.dasm16
155
0
#define FLOAT_HIGH         2
defs.dasm16
156
0
#define FLOAT_LOW          3
defs.dasm16
157
0

defs.dasm16
158
0
#define FLOAT_EXP_BIAS     0x8000
defs.dasm16
159
0

defs.dasm16
160
0
; struct int_value {
defs.dasm16
161
0
;   uint16 len;
defs.dasm16
162
0
;   uint16[] data;
defs.dasm16
163
0
; }
defs.dasm16
164
0

defs.dasm16
165
0
#define INT_LEN     0
defs.dasm16
166
0
#define INT_DATA    1
defs.dasm16
167
0

defs.dasm16
168
0
#define INT_DIVISION_QUOTIENT   1
defs.dasm16
169
0
#define INT_DIVISION_REMAINDER  2
defs.dasm16
170
0

defs.dasm16
171
0
; position of key and value in dict item tuple
defs.dasm16
172
0
#define DICT_ITEM_KEY   1
defs.dasm16
173
0
#define DICT_ITEM_VALUE 2
defs.dasm16
174
0

defs.dasm16
175
0
; struct prototype {
defs.dasm16
176
0
;   void *std;
defs.dasm16
177
0
;   void *nud;
defs.dasm16
178
0
;   void *led;
defs.dasm16
179
0
;   uint16 lbp;
defs.dasm16
180
0
; }
defs.dasm16
181
0
#define PROTOTYPE_STD               0
defs.dasm16
182
0
#define PROTOTYPE_NUD               1
defs.dasm16
183
0
#define PROTOTYPE_LED               2
defs.dasm16
184
0
#define PROTOTYPE_LBP               3
defs.dasm16
185
0

defs.dasm16
186
0
; struct control {
defs.dasm16
187
0
;   uint16 length;
defs.dasm16
188
0
;   uint16 token;
defs.dasm16
189
0
;   [struct handle *value;] # only for return
defs.dasm16
190
0
; }
defs.dasm16
191
0
#define SIZEOF_CONTROL        3
defs.dasm16
192
0
#define CONTROL_SIGNAL      1
defs.dasm16
193
0
#define CONTROL_VALUE       2
defs.dasm16
194
0

defs.dasm16
195
0
; struct reference {
defs.dasm16
196
0
;   uint16 length;
defs.dasm16
197
0
;   struct handle *dict;
defs.dasm16
198
0
;   struct handle *name;
defs.dasm16
199
0
; }
defs.dasm16
200
0
#define REFERENCE_LEFT        1
defs.dasm16
201
0
#define REFERENCE_RIGHT        2
defs.dasm16
202
0

defs.dasm16
203
0
; struct subscription {
defs.dasm16
204
0
;   uint16 length;
defs.dasm16
205
0
;   struct handle *list;
defs.dasm16
206
0
;   struct handle *int;
defs.dasm16
207
0
; }
defs.dasm16
208
0
#define SUBSCRIPTION_LIST   1
defs.dasm16
209
0
#define SUBSCRIPTION_INDEX  2
defs.dasm16
210
0

defs.dasm16
211
0
; screen is not stored in heap -> it can be non-standard
defs.dasm16
212
0
;
defs.dasm16
213
0
; struct screen {
defs.dasm16
214
0
;   uint16 *start;
defs.dasm16
215
0
;   uint16 *end;
defs.dasm16
216
0
;   uint16 *cursor;
defs.dasm16
217
0
; }
defs.dasm16
218
0
#define SIZEOF_SCREEN        3
defs.dasm16
219
0
#define SCREEN__START        0
defs.dasm16
220
0
#define SCREEN__END            1
defs.dasm16
221
0
#define SCREEN__CURSOR        2
defs.dasm16
222
0

defs.dasm16
223
0
; struct inode {
defs.dasm16
224
0
;   struct handle *sector;
defs.dasm16
225
0
;   struct handle *size;
defs.dasm16
226
0
; }
defs.dasm16
227
0
#define SIZEOF__INODE                    4
defs.dasm16
228
0
#define INODE__LENGTH                    0
defs.dasm16
229
0
#define INODE__SECTOR__HEAD                1
defs.dasm16
230
0
#define INODE__SECTOR__TAIL                2
defs.dasm16
231
0
#define INODE__SIZE                        3
defs.dasm16
232
0

defs.dasm16
233
0
; struct lexer {
defs.dasm16
234
0
;   struct handle *string;
defs.dasm16
235
0
;   uint16 target_indent;
defs.dasm16
236
0
;   uint16 current_indent;
defs.dasm16
237
0
;   uint16_token;
defs.dasm16
238
0
;   uint16_start;
defs.dasm16
239
0
;   uint16_end;
defs.dasm16
240
0
; }
defs.dasm16
241
0
#define SIZEOF_LEXER                    6
defs.dasm16
242
0
#define LEXER__STR                        0
defs.dasm16
243
0
#define LEXER__INDENT_TARGET            1
defs.dasm16
244
0
#define LEXER__INDENT_CURRENT            2
defs.dasm16
245
0
#define LEXER__TOKEN                    3
defs.dasm16
246
0
#define LEXER__START                    4
defs.dasm16
247
0
#define LEXER__END                        5
defs.dasm16
248
0

interpreter.dasm16
0
0
:interpreter_main
interpreter.dasm16
1
1
0000
8701
    set push, 0
interpreter.dasm16
2
1
0001
9b01
    set push, 5
interpreter.dasm16
3
2
0002
7c20
0003
2039
    jsr preamble
interpreter.dasm16
4
0
    
interpreter.dasm16
5
2
0004
17c1
0005
0238
    set [recovery_fp], z
interpreter.dasm16
6
2
0006
6fc1
0007
0239
    set [recovery_sp], sp
interpreter.dasm16
7
0

interpreter.dasm16
8
2
0008
7c20
0009
20e4
    jsr detect_hardware
interpreter.dasm16
9
2
000a
7c20
000b
2e16
    jsr screen_select
interpreter.dasm16
10
2
000c
7c20
000d
2ee2
    jsr screen_clear
interpreter.dasm16
11
0

interpreter.dasm16
12
1
000e
af01
    set push, 10
interpreter.dasm16
13
1
000f
8b01
    set push, TYPE_DICT
interpreter.dasm16
14
2
0010
7c20
0011
21d3
    jsr alloc
interpreter.dasm16
15
2
0012
0ea1
0013
ffff
    set [z-1], x
interpreter.dasm16
16
0

interpreter.dasm16
17
2
0014
0fc1
0015
0235
    set [global_scope], x
interpreter.dasm16
18
2
0016
0fc1
0017
0236
    set [current_scope], x
interpreter.dasm16
19
0

interpreter.dasm16
20
1
0018
9f01
    set push, HISTORY_SIZE+1
interpreter.dasm16
21
1
0019
8f01
    set push, TYPE_LIST
interpreter.dasm16
22
2
001a
7c20
001b
2770
    jsr array_create
interpreter.dasm16
23
2
001c
0ea1
001d
fffb
    set [z-5], x
interpreter.dasm16
24
0

interpreter.dasm16
25
0
    ; setup interpreter history
interpreter.dasm16
26
2
001e
0fc1
001f
0237
    set [history], x
interpreter.dasm16
27
0

interpreter.dasm16
28
2
0020
7f01
0021
036f
    set push, STR_STARTUP
interpreter.dasm16
29
2
0022
7c20
0023
2050
    jsr print
interpreter.dasm16
30
0

interpreter.dasm16
31
2
0024
7f01
0025
0392
    set push, STR_STARTUP2
interpreter.dasm16
32
2
0026
7c20
0027
2050
    jsr print
interpreter.dasm16
33
0
    
interpreter.dasm16
34
2
0028
7c20
0029
2237
    jsr mark
interpreter.dasm16
35
2
002a
7c20
002b
2214
    jsr compact
interpreter.dasm16
36
0

interpreter.dasm16
37
2
002c
7801
002d
0255
    set a, [heap_handle_start]
interpreter.dasm16
38
2
002e
7803
002f
0254
    sub a, [heap_free_start]
interpreter.dasm16
39
0
    
interpreter.dasm16
40
1
0030
0301
    set push, a
interpreter.dasm16
41
2
0031
7c20
0032
22a2
    jsr uint16_to_int
interpreter.dasm16
42
0
    
interpreter.dasm16
43
1
0033
0f01
    set push, x
interpreter.dasm16
44
2
0034
7c20
0035
2050
    jsr print
interpreter.dasm16
45
0

interpreter.dasm16
46
2
0036
7f01
0037
03a5
    set push, STR_STARTUP3
interpreter.dasm16
47
2
0038
7c20
0039
2050
    jsr print
interpreter.dasm16
48
0

interpreter.dasm16
49
0
:interpreter_loop
interpreter.dasm16
50
2
003a
7f01
003b
03b3
    set push, STR_PROMPT
interpreter.dasm16
51
2
003c
7c20
003d
2050
    jsr print
interpreter.dasm16
52
0

interpreter.dasm16
53
2
003e
7c20
003f
00e2
    jsr interpreter__line_edit
interpreter.dasm16
54
2
0040
0ea1
0041
fffe
    set [z-2], x
interpreter.dasm16
55
0
    
interpreter.dasm16
56
1
0042
ac41
    set c, 10
interpreter.dasm16
57
2
0043
7c20
0044
2ef4
    jsr screen_add_char
interpreter.dasm16
58
0
    
interpreter.dasm16
59
2
0045
7c20
0046
1b35
    jsr lexer_init
interpreter.dasm16
60
0

interpreter.dasm16
61
0
:interpreter_loop_parse
interpreter.dasm16
62
2
0047
7c20
0048
07a1
    jsr parser_stmt
interpreter.dasm16
63
2
0049
0ea1
004a
fffd
    set [z-3], x
interpreter.dasm16
64
0

interpreter.dasm16
65
3
004b
7e72
004c
4000
004d
0001
    ife [x+1], TYPE_VOID
interpreter.dasm16
66
2
004e
7f81
004f
0055
        set pc, interpreter_loop_parse_2
interpreter.dasm16
67
0
    
interpreter.dasm16
68
1
0050
0f01
    set push, x
interpreter.dasm16
69
2
0051
7c20
0052
1dfc
    jsr eval
interpreter.dasm16
70
2
0053
0ea1
0054
fffd
    set [z-3], x
interpreter.dasm16
71
0

interpreter.dasm16
72
0
;    set push, x
interpreter.dasm16
73
0
;    jsr print_repr
interpreter.dasm16
74
0

interpreter.dasm16
75
0
;    set c, 10
interpreter.dasm16
76
0
;    jsr screen_add_char
interpreter.dasm16
77
0

interpreter.dasm16
78
0
:interpreter_loop_parse_2
interpreter.dasm16
79
3
0055
7fd3
0056
0410
0057
025c
    ifn [lexer_token], token_eof
interpreter.dasm16
80
2
0058
7f81
0059
0047
        set pc, interpreter_loop_parse
interpreter.dasm16
81
0
    
interpreter.dasm16
82
2
005a
7f81
005b
003a
    set pc, interpreter_loop
interpreter.dasm16
83
0

interpreter.dasm16
84
0
;----------------------------------------------------------------
interpreter.dasm16
85
0
; struct handle *scope_get(struct handle *dict, struct handle *key)
interpreter.dasm16
86
0
; return value from scope or any of the ancestor scopes
interpreter.dasm16
87
0
;----------------------------------------------------------------
interpreter.dasm16
88
0
:scope_get
interpreter.dasm16
89
1
005c
8f01
    set push, 2
interpreter.dasm16
90
1
005d
8701
    set push, 0
interpreter.dasm16
91
2
005e
7c20
005f
2039
    jsr preamble
interpreter.dasm16
92
0
    
interpreter.dasm16
93
2
0060
5701
0061
000b
    set push, [z+11]
interpreter.dasm16
94
2
0062
5701
0063
000a
    set push, [z+10]
interpreter.dasm16
95
2
0064
7c20
0065
2f2e
    jsr dict_get
interpreter.dasm16
96
0
    
interpreter.dasm16
97
1
0066
8473
    ifn x, 0
interpreter.dasm16
98
2
0067
7c20
0068
2026
        jsr postamble
interpreter.dasm16
99
0
        
interpreter.dasm16
100
2
0069
5701
006a
000b
    set push, [z+11]
interpreter.dasm16
101
2
006b
7f01
006c
03d2
    set push, STR_UNDERSCORE
interpreter.dasm16
102
2
006d
7c20
006e
2f2e
    jsr dict_get
interpreter.dasm16
103
0
    
interpreter.dasm16
104
1
006f
8472
    ife x, 0
interpreter.dasm16
105
2
0070
7c20
0071
2026
        jsr postamble
interpreter.dasm16
106
0
        
interpreter.dasm16
107
1
0072
0f01
    set push, x
interpreter.dasm16
108
2
0073
5701
0074
000a
    set push, [z+10]
interpreter.dasm16
109
2
0075
7c20
0076
005c
    jsr scope_get
interpreter.dasm16
110
0
    
interpreter.dasm16
111
2
0077
7c20
0078
2026
    jsr postamble
interpreter.dasm16
112
0
    
interpreter.dasm16
113
0
;----------------------------------------------------------------
interpreter.dasm16
114
0
; void scope_del(struct handle *dict, struct handle *key)
interpreter.dasm16
115
0
; delete value from scope or closest ancestor scope
interpreter.dasm16
116
0
;----------------------------------------------------------------
interpreter.dasm16
117
0
:scope_del
interpreter.dasm16
118
1
0079
8f01
    set push, 2
interpreter.dasm16
119
1
007a
8701
    set push, 0
interpreter.dasm16
120
2
007b
7c20
007c
2039
    jsr preamble
interpreter.dasm16
121
0
    
interpreter.dasm16
122
2
007d
5701
007e
000b
    set push, [z+11]
interpreter.dasm16
123
2
007f
5701
0080
000a
    set push, [z+10]
interpreter.dasm16
124
2
0081
7c20
0082
2f89
    jsr dict_del
interpreter.dasm16
125
0
    
interpreter.dasm16
126
1
0083
8473
    ifn x, 0
interpreter.dasm16
127
2
0084
7c20
0085
2026
        jsr postamble
interpreter.dasm16
128
0
        
interpreter.dasm16
129
2
0086
5701
0087
000b
    set push, [z+11]
interpreter.dasm16
130
2
0088
7f01
0089
03d2
    set push, STR_UNDERSCORE
interpreter.dasm16
131
2
008a
7c20
008b
2f2e
    jsr dict_get
interpreter.dasm16
132
0
    
interpreter.dasm16
133
1
008c
8472
    ife x, 0
interpreter.dasm16
134
2
008d
7c20
008e
00c6
        jsr recover
interpreter.dasm16
135
0
        
interpreter.dasm16
136
1
008f
0f01
    set push, x
interpreter.dasm16
137
2
0090
5701
0091
000a
    set push, [z + 10]
interpreter.dasm16
138
2
0092
7c20
0093
0079
    jsr scope_del
interpreter.dasm16
139
0
    
interpreter.dasm16
140
2
0094
7c20
0095
2026
    jsr postamble
interpreter.dasm16
141
0
    
interpreter.dasm16
142
0
;----------------------------------------------------------------
interpreter.dasm16
143
0
; void scope_set(struct handle *dict, struct handle *key, struct handle *value, uint16 mode)
interpreter.dasm16
144
0
; mode: SCOPE_MODE_UPDATE | SCOPE_MODE_INSERT
interpreter.dasm16
145
0
;----------------------------------------------------------------
interpreter.dasm16
146
0
:scope_set
interpreter.dasm16
147
1
0096
9701
    set push, 4
interpreter.dasm16
148
1
0097
8701
    set push, 0
interpreter.dasm16
149
2
0098
7c20
0099
2039
    jsr preamble    
interpreter.dasm16
150
0

interpreter.dasm16
151
2
009a
5701
009b
000d
    set push, [z+13]
interpreter.dasm16
152
2
009c
5701
009d
000c
    set push, [z+12]
interpreter.dasm16
153
2
009e
7c20
009f
2f2e
    jsr dict_get
interpreter.dasm16
154
0
    
interpreter.dasm16
155
1
00a0
8473
    ifn x, 0
interpreter.dasm16
156
2
00a1
7f81
00a2
00bb
        set pc, scope_set_insert
interpreter.dasm16
157
0
        
interpreter.dasm16
158
2
00a3
5701
00a4
000d
    set push, [z+13]
interpreter.dasm16
159
2
00a5
7f01
00a6
03d2
    set push, STR_UNDERSCORE
interpreter.dasm16
160
2
00a7
7c20
00a8
2f2e
    jsr dict_get
interpreter.dasm16
161
0
    
interpreter.dasm16
162
1
00a9
8472
    ife x, 0                            ; no parent found
interpreter.dasm16
163
2
00aa
7f81
00ab
00b7
        set pc, scope_set_no_parent
interpreter.dasm16
164
0

interpreter.dasm16
165
0
    ; parent found
interpreter.dasm16
166
1
00ac
0f01
    set push, x                            ; call parent
interpreter.dasm16
167
2
00ad
5701
00ae
000c
    set push, [z+12]                    ; key
interpreter.dasm16
168
2
00af
5701
00b0
000b
    set push, [z+11]                    ; value
interpreter.dasm16
169
1
00b1
8f01
    set push, SCOPE_MODE_UPDATE
interpreter.dasm16
170
2
00b2
7c20
00b3
0096
    jsr scope_set
interpreter.dasm16
171
0
    
interpreter.dasm16
172
1
00b4
8473
    ifn x, 0
interpreter.dasm16
173
2
00b5
7c20
00b6
2026
        jsr postamble
interpreter.dasm16
174
0

interpreter.dasm16
175
0
:scope_set_no_parent
interpreter.dasm16
176
2
00b7
8eb2
00b8
000a
    ife [z+10], SCOPE_MODE_UPDATE
interpreter.dasm16
177
2
00b9
7c20
00ba
2026
        jsr postamble
interpreter.dasm16
178
0

interpreter.dasm16
179
0
:scope_set_insert
interpreter.dasm16
180
2
00bb
5701
00bc
000d
    set push, [z+13]
interpreter.dasm16
181
2
00bd
5701
00be
000c
    set push, [z+12]
interpreter.dasm16
182
2
00bf
5701
00c0
000b
    set push, [z+11]
interpreter.dasm16
183
2
00c1
7c20
00c2
2f54
    jsr dict__set
interpreter.dasm16
184
0

interpreter.dasm16
185
1
00c3
8861
    set x, 1
interpreter.dasm16
186
2
00c4
7c20
00c5
2026
    jsr postamble
interpreter.dasm16
187
0
    
interpreter.dasm16
188
0
;----------------------------------------------------------------
interpreter.dasm16
189
0
:recover
interpreter.dasm16
190
0
; fastcall
interpreter.dasm16
191
0
;----------------------------------------------------------------
interpreter.dasm16
192
1
00c6
6001
    set a, pop
interpreter.dasm16
193
2
00c7
78a1
00c8
0238
    set z, [recovery_fp]
interpreter.dasm16
194
2
00c9
7b61
00ca
0239
    set sp, [recovery_sp]
interpreter.dasm16
195
0

interpreter.dasm16
196
3
00cb
7bc1
00cc
0235
00cd
0236
    set [current_scope], [global_scope]
interpreter.dasm16
197
0

interpreter.dasm16
198
2
00ce
7f01
00cf
03b7
    set push, STR_ERROR
interpreter.dasm16
199
2
00d0
7c20
00d1
2050
    jsr print
interpreter.dasm16
200
0

interpreter.dasm16
201
1
00d2
0301
    set push, a
interpreter.dasm16
202
2
00d3
7c20
00d4
0215
    jsr debug
interpreter.dasm16
203
0
    
interpreter.dasm16
204
1
00d5
ac41
    set c, 10
interpreter.dasm16
205
2
00d6
7c20
00d7
2ef4
    jsr screen_add_char
interpreter.dasm16
206
0

interpreter.dasm16
207
2
00d8
7c20
00d9
1b74
    jsr lexer__get_line
interpreter.dasm16
208
1
00da
0f01
    set push, x
interpreter.dasm16
209
2
00db
7c20
00dc
2050
    jsr print
interpreter.dasm16
210
0

interpreter.dasm16
211
1
00dd
ac41
    set c, 10
interpreter.dasm16
212
2
00de
7c20
00df
2ef4
    jsr screen_add_char
interpreter.dasm16
213
0

interpreter.dasm16
214
0
;    jsr lexer__get_token_marker
interpreter.dasm16
215
0
;    set push, x
interpreter.dasm16
216
0
;    jsr print
interpreter.dasm16
217
0
    
interpreter.dasm16
218
0
;    set c, 10
interpreter.dasm16
219
0
;    jsr screen_add_char
interpreter.dasm16
220
0

interpreter.dasm16
221
2
00e0
7f81
00e1
003a
    set pc, interpreter_loop
interpreter.dasm16
222
0

interpreter.dasm16
223
0
;----------------------------------------------------------------
interpreter.dasm16
224
0
:interpreter__line_edit
interpreter.dasm16
225
1
00e2
8701
    set push, 0
interpreter.dasm16
226
1
00e3
8b01
    set push, 1
interpreter.dasm16
227
2
00e4
7c20
00e5
2039
    jsr preamble
interpreter.dasm16
228
0
    
interpreter.dasm16
229
2
00e6
7881
00e7
023a
    set y, [current_screen]
interpreter.dasm16
230
2
00e8
9bc1
00e9
026a
    set [line_editor__buf_index], HISTORY_SIZE
interpreter.dasm16
231
3
00ea
53c1
00eb
0002
00ec
026b
    set [line_editor__start_addr], [y + SCREEN__CURSOR]
interpreter.dasm16
232
3
00ed
53c1
00ee
0002
00ef
026c
    set [line_editor__current_addr], [y + SCREEN__CURSOR]
interpreter.dasm16
233
3
00f0
53c1
00f1
0002
00f2
026d
    set [line_editor__end_addr], [y + SCREEN__CURSOR]
interpreter.dasm16
234
2
00f3
87c1
00f4
026e
    set [line_editor__last_char], 0
interpreter.dasm16
235
0

interpreter.dasm16
236
0
:interpreter__line_edit_main_loop
interpreter.dasm16
237
3
00f5
7a81
00f6
026c
00f7
0002
    set [y + SCREEN__CURSOR], [line_editor__current_addr]
interpreter.dasm16
238
0

interpreter.dasm16
239
2
00f8
7841
00f9
026e
    set c, [line_editor__last_char]
interpreter.dasm16
240
0

interpreter.dasm16
241
2
00fa
7c20
00fb
2e21
    jsr screen_toggle_cursor
interpreter.dasm16
242
2
00fc
7c20
00fd
2103
    jsr win_getchar
interpreter.dasm16
243
2
00fe
7c20
00ff
2e21
    jsr screen_toggle_cursor
interpreter.dasm16
244
0

interpreter.dasm16
245
2
0100
0bc1
0101
026e
    set [line_editor__last_char], c
interpreter.dasm16
246
0

interpreter.dasm16
247
2
0102
7c52
0103
0080
    ife c, KEY_UP
interpreter.dasm16
248
2
0104
7f81
0105
0122
        set pc, interpreter__line_edit__key_up
interpreter.dasm16
249
2
0106
7c52
0107
0081
    ife c, KEY_DOWN
interpreter.dasm16
250
2
0108
7f81
0109
0131
        set pc, interpreter__line_edit__key_down
interpreter.dasm16
251
2
010a
7c52
010b
0082
    ife c, KEY_LEFT
interpreter.dasm16
252
2
010c
7f81
010d
01b9
        set pc, interpreter__line_edit__key_left
interpreter.dasm16
253
2
010e
7c52
010f
0083
    ife c, KEY_RIGHT
interpreter.dasm16
254
2
0110
7f81
0111
01b2
        set pc, interpreter__line_edit__key_right
interpreter.dasm16
255
1
0112
d052
    ife c, KEY_DEL
interpreter.dasm16
256
2
0113
7f81
0114
0171
        set pc, interpreter__line_edit__key_del
interpreter.dasm16
257
1
0115
c452
    ife c, KEY_BS
interpreter.dasm16
258
2
0116
7f81
0117
016a
        set pc, interpreter__line_edit__key_bs
interpreter.dasm16
259
1
0118
c852
    ife c, KEY_NEWLINE
interpreter.dasm16
260
2
0119
7f81
011a
0188
        set pc, interpreter__line_edit__key_newline
interpreter.dasm16
261
1
011b
e854
    ifg c, 0x19
interpreter.dasm16
262
2
011c
7c56
011d
007f
        ifl c, 0x7f
interpreter.dasm16
263
2
011e
7f81
011f
01c0
            set pc, interpreter__line_edit__key_character
interpreter.dasm16
264
0

interpreter.dasm16
265
2
0120
7f81
0121
00f5
    set pc, interpreter__line_edit_main_loop
interpreter.dasm16
266
0

interpreter.dasm16
267
0
;----------------------------------------------------------------
interpreter.dasm16
268
0
:interpreter__line_edit__key_up
interpreter.dasm16
269
0
;----------------------------------------------------------------
interpreter.dasm16
270
0
    ; return if already oldest line
interpreter.dasm16
271
2
0122
87d2
0123
026a
    ife [line_editor__buf_index], 0
interpreter.dasm16
272
2
0124
7f81
0125
00f5
        set pc, interpreter__line_edit_main_loop
interpreter.dasm16
273
0

interpreter.dasm16
274
2
0126
7801
0127
0237
    set a, [history]
interpreter.dasm16
275
1
0128
2001
    set a, [a]
interpreter.dasm16
276
2
0129
7802
012a
026a
    add a, [line_editor__buf_index]
interpreter.dasm16
277
1
012b
8512
    ife [a], 0
interpreter.dasm16
278
2
012c
7f81
012d
00f5
        set pc, interpreter__line_edit_main_loop
interpreter.dasm16
279
0

interpreter.dasm16
280
1
012e
8301
    set push, -1
interpreter.dasm16
281
0

interpreter.dasm16
282
2
012f
7f81
0130
0138
    set pc, interpreter__line_edit__history
interpreter.dasm16
283
0

interpreter.dasm16
284
0
;----------------------------------------------------------------
interpreter.dasm16
285
0
:interpreter__line_edit__key_down
interpreter.dasm16
286
0
;----------------------------------------------------------------
interpreter.dasm16
287
0
    ; return if already last line
interpreter.dasm16
288
2
0131
9bd2
0132
026a
    ife [line_editor__buf_index], HISTORY_SIZE
interpreter.dasm16
289
2
0133
7f81
0134
00f5
        set pc, interpreter__line_edit_main_loop
interpreter.dasm16
290
0

interpreter.dasm16
291
1
0135
8b01
    set push, 1
interpreter.dasm16
292
0
    
interpreter.dasm16
293
2
0136
7f81
0137
0138
    set pc, interpreter__line_edit__history
interpreter.dasm16
294
0

interpreter.dasm16
295
0
;----------------------------------------------------------------
interpreter.dasm16
296
0
:interpreter__line_edit__history
interpreter.dasm16
297
0
;----------------------------------------------------------------
interpreter.dasm16
298
0
    ; get current line as str
interpreter.dasm16
299
2
0138
7c20
0139
01f9
    jsr interpreter__line_edit__get_str
interpreter.dasm16
300
0
    
interpreter.dasm16
301
0
    ; clear the current line
interpreter.dasm16
302
2
013a
78c1
013b
026b
    set i, [line_editor__start_addr]
interpreter.dasm16
303
2
013c
7801
013d
026d
    set a, [line_editor__end_addr]
interpreter.dasm16
304
0
    
interpreter.dasm16
305
0
    :interpreter__line_edit__key_up__loop1
interpreter.dasm16
306
1
013e
00d2
        ife i, a
interpreter.dasm16
307
2
013f
7f81
0140
0144
            set pc, interpreter__line_edit__key_up__break1
interpreter.dasm16
308
1
0141
85c1
        set [i], 0
interpreter.dasm16
309
2
0142
7f9e
0143
013e
        sti pc, interpreter__line_edit__key_up__loop1
interpreter.dasm16
310
0
    :interpreter__line_edit__key_up__break1
interpreter.dasm16
311
0

interpreter.dasm16
312
0
    ; store current line to history
interpreter.dasm16
313
2
0144
7801
0145
0237
    set a, [history]
interpreter.dasm16
314
2
0146
7821
0147
026a
    set b, [line_editor__buf_index]
interpreter.dasm16
315
1
0148
0c41
    set c, x
interpreter.dasm16
316
2
0149
7c20
014a
2784
    jsr array__set
interpreter.dasm16
317
0
        
interpreter.dasm16
318
0
    ; select older item
interpreter.dasm16
319
2
014b
63c2
014c
026a
    add [line_editor__buf_index], pop
interpreter.dasm16
320
0

interpreter.dasm16
321
0
    ; get current line
interpreter.dasm16
322
2
014d
7801
014e
0237
    set a, [history]
interpreter.dasm16
323
2
014f
7821
0150
026a
    set b, [line_editor__buf_index]
interpreter.dasm16
324
2
0151
7c20
0152
277f
    jsr array__get
interpreter.dasm16
325
0

interpreter.dasm16
326
0
    ; move cursor to start location
interpreter.dasm16
327
3
0153
7a81
0154
026b
0155
0002
    set [y + SCREEN__CURSOR], [line_editor__start_addr]
interpreter.dasm16
328
3
0156
7bc1
0157
026b
0158
026c
    set [line_editor__current_addr], [line_editor__start_addr]
interpreter.dasm16
329
3
0159
7bc1
015a
026b
015b
026d
    set [line_editor__end_addr], [line_editor__start_addr]
interpreter.dasm16
330
0

interpreter.dasm16
331
1
015c
2cc1
    set i, [x]
interpreter.dasm16
332
1
015d
183e
    sti b, i
interpreter.dasm16
333
1
015e
2422
    add b, [b]
interpreter.dasm16
334
0

interpreter.dasm16
335
0
    :interpreter__line_edit__key_up__loop2
interpreter.dasm16
336
1
015f
04d2
        ife i, b
interpreter.dasm16
337
2
0160
7f81
0161
00f5
            set pc, interpreter__line_edit_main_loop
interpreter.dasm16
338
1
0162
04d4
        ifg i, b
interpreter.dasm16
339
2
0163
7f81
0164
00f5
            set pc, interpreter__line_edit_main_loop
interpreter.dasm16
340
0
        
interpreter.dasm16
341
1
0165
3b01
        set push, [i]
interpreter.dasm16
342
2
0166
7c20
0167
01d1
        jsr interpreter__line_edit__draw_char
interpreter.dasm16
343
0

interpreter.dasm16
344
2
0168
7f9e
0169
015f
        sti pc, interpreter__line_edit__key_up__loop2
interpreter.dasm16
345
0

interpreter.dasm16
346
0
;----------------------------------------------------------------
interpreter.dasm16
347
0
:interpreter__line_edit__key_bs
interpreter.dasm16
348
0
;----------------------------------------------------------------
interpreter.dasm16
349
3
016a
7bd2
016b
026c
016c
026b
    ife [line_editor__start_addr], [line_editor__current_addr]
interpreter.dasm16
350
2
016d
7f81
016e
00f5
        set pc, interpreter__line_edit_main_loop
interpreter.dasm16
351
0

interpreter.dasm16
352
2
016f
8bc3
0170
026c
    sub [line_editor__current_addr], 1
interpreter.dasm16
353
0

interpreter.dasm16
354
0
    ; join key_del
interpreter.dasm16
355
0
    
interpreter.dasm16
356
0
;----------------------------------------------------------------
interpreter.dasm16
357
0
:interpreter__line_edit__key_del
interpreter.dasm16
358
0
;----------------------------------------------------------------
interpreter.dasm16
359
3
0171
7bd2
0172
026d
0173
026c
    ife [line_editor__current_addr], [line_editor__end_addr]
interpreter.dasm16
360
2
0174
7f81
0175
00f5
        set pc, interpreter__line_edit_main_loop
interpreter.dasm16
361
0

interpreter.dasm16
362
2
0176
78c1
0177
026c
    set i, [line_editor__current_addr]
interpreter.dasm16
363
0
    
interpreter.dasm16
364
0
:interpreter__line_edit__del_char__loop
interpreter.dasm16
365
2
0178
78d2
0179
026d
    ife i, [line_editor__end_addr]
interpreter.dasm16
366
2
017a
7f81
017b
0181
        set pc, interpreter__line_edit__del_char__break
interpreter.dasm16
367
0
        
interpreter.dasm16
368
2
017c
59c1
017d
0001
    set [i], [i+1]
interpreter.dasm16
369
1
017e
88c2
    add i, 1
interpreter.dasm16
370
2
017f
7f81
0180
0178
    set pc, interpreter__line_edit__del_char__loop
interpreter.dasm16
371
0

interpreter.dasm16
372
0
:interpreter__line_edit__del_char__break
interpreter.dasm16
373
2
0181
78c1
0182
026d
    set i, [line_editor__end_addr]
interpreter.dasm16
374
1
0183
85c1
    set [i], 0
interpreter.dasm16
375
2
0184
8bc3
0185
026d
    sub [line_editor__end_addr], 1
interpreter.dasm16
376
0

interpreter.dasm16
377
2
0186
7f81
0187
00f5
    set pc, interpreter__line_edit_main_loop
interpreter.dasm16
378
0

interpreter.dasm16
379
0
;----------------------------------------------------------------
interpreter.dasm16
380
0
:interpreter__line_edit__key_newline
interpreter.dasm16
381
0
;----------------------------------------------------------------
interpreter.dasm16
382
2
0188
7c20
0189
01f9
    jsr interpreter__line_edit__get_str
interpreter.dasm16
383
0

interpreter.dasm16
384
1
018a
2c01
    set a, [x]
interpreter.dasm16
385
1
018b
8d16
    ifl [a], 2
interpreter.dasm16
386
2
018c
7f81
018d
01ae
        set pc, interpreter__line_edit__key_newline__finish
interpreter.dasm16
387
0

interpreter.dasm16
388
2
018e
7801
018f
0237
    set a, [history]
interpreter.dasm16
389
1
0190
9421
    set b, HISTORY_SIZE - 1
interpreter.dasm16
390
2
0191
7c20
0192
277f
    jsr array__get
interpreter.dasm16
391
0

interpreter.dasm16
392
1
0193
8472
    ife x, 0
interpreter.dasm16
393
2
0194
7f81
0195
019e
        set pc, interpreter__line_edit__key_newline__store
interpreter.dasm16
394
0

interpreter.dasm16
395
1
0196
0f01
    set push, x
interpreter.dasm16
396
2
0197
5701
0198
ffff
    set push, [z-1]
interpreter.dasm16
397
2
0199
7c20
019a
1dc0
    jsr val_cmp
interpreter.dasm16
398
0
    
interpreter.dasm16
399
1
019b
8472
    ife x, 0
interpreter.dasm16
400
2
019c
7f81
019d
01ae
        set pc, interpreter__line_edit__key_newline__finish
interpreter.dasm16
401
0

interpreter.dasm16
402
0
:interpreter__line_edit__key_newline__store
interpreter.dasm16
403
1
019e
9821
    set b, HISTORY_SIZE
interpreter.dasm16
404
2
019f
5441
01a0
ffff
    set c, [z-1]
interpreter.dasm16
405
2
01a1
7c20
01a2
2784
    jsr array__set
interpreter.dasm16
406
0

interpreter.dasm16
407
0
    ; shift command history (HISTORY_SIZE must be >1)
interpreter.dasm16
408
2
01a3
7801
01a4
0237
    set a, [history]                    ; struct handle *
interpreter.dasm16
409
1
01a5
2001
    set a, [a]                            ; struct list *
interpreter.dasm16
410
1
01a6
00c1
    set i, a
interpreter.dasm16
411
0

interpreter.dasm16
412
1
01a7
2002
    add a, [a]                            ; history[-1]
interpreter.dasm16
413
1
01a8
8cc2
    add i, 2                            ; history[1]
interpreter.dasm16
414
0

interpreter.dasm16
415
0
    :interpreter__line_edit__history_loop
interpreter.dasm16
416
2
01a9
3ac1
01aa
ffff
    set [i-1], [i]
interpreter.dasm16
417
1
01ab
00d6
    ifl i, a
interpreter.dasm16
418
2
01ac
7f9e
01ad
01a9
        sti pc, interpreter__line_edit__history_loop
interpreter.dasm16
419
0

interpreter.dasm16
420
0
:interpreter__line_edit__key_newline__finish
interpreter.dasm16
421
2
01ae
5461
01af
ffff
    set x, [z-1]
interpreter.dasm16
422
2
01b0
7f81
01b1
2026
    set pc, postamble
interpreter.dasm16
423
0
        
interpreter.dasm16
424
0
;----------------------------------------------------------------
interpreter.dasm16
425
0
:interpreter__line_edit__key_right
interpreter.dasm16
426
0
;----------------------------------------------------------------
interpreter.dasm16
427
3
01b2
7bd6
01b3
026d
01b4
026c
    ifl [line_editor__current_addr], [line_editor__end_addr]
interpreter.dasm16
428
2
01b5
8bc2
01b6
026c
        add [line_editor__current_addr], 1
interpreter.dasm16
429
0
    
interpreter.dasm16
430
2
01b7
7f81
01b8
00f5
    set pc, interpreter__line_edit_main_loop
interpreter.dasm16
431
0

interpreter.dasm16
432
0
;----------------------------------------------------------------
interpreter.dasm16
433
0
:interpreter__line_edit__key_left
interpreter.dasm16
434
0
;----------------------------------------------------------------
interpreter.dasm16
435
3
01b9
7bd4
01ba
026b
01bb
026c
    ifg [line_editor__current_addr], [line_editor__start_addr]
interpreter.dasm16
436
2
01bc
8bc3
01bd
026c
        sub [line_editor__current_addr], 1
interpreter.dasm16
437
0
    
interpreter.dasm16
438
2
01be
7f81
01bf
00f5
    set pc, interpreter__line_edit_main_loop
interpreter.dasm16
439
0
    
interpreter.dasm16
440
0

interpreter.dasm16
441
0
;----------------------------------------------------------------
interpreter.dasm16
442
0
:interpreter__line_edit__key_character
interpreter.dasm16
443
0
;----------------------------------------------------------------
interpreter.dasm16
444
2
01c0
78e1
01c1
026d
    set j, [line_editor__end_addr]
interpreter.dasm16
445
2
01c2
78c1
01c3
026c
    set i, [line_editor__current_addr]
interpreter.dasm16
446
0
    
interpreter.dasm16
447
0
    :interpreter__line_edit__key_character__loop
interpreter.dasm16
448
1
01c4
1cd2
        ife i, j
interpreter.dasm16
449
2
01c5
7f81
01c6
01cc
            set pc, interpreter__line_edit__key_character__break
interpreter.dasm16
450
0

interpreter.dasm16
451
2
01c7
5de1
01c8
ffff
        set [j], [j-1]
interpreter.dasm16
452
0

interpreter.dasm16
453
1
01c9
88e3
        sub j, 1
interpreter.dasm16
454
2
01ca
7f81
01cb
01c4
        set pc, interpreter__line_edit__key_character__loop
interpreter.dasm16
455
0

interpreter.dasm16
456
0
    :interpreter__line_edit__key_character__break
interpreter.dasm16
457
1
01cc
0b01
        set push, c
interpreter.dasm16
458
2
01cd
7c20
01ce
01d1
        jsr interpreter__line_edit__draw_char
interpreter.dasm16
459
0

interpreter.dasm16
460
2
01cf
7f81
01d0
00f5
    set pc, interpreter__line_edit_main_loop
interpreter.dasm16
461
0

interpreter.dasm16
462
0
;----------------------------------------------------------------
interpreter.dasm16
463
0
:interpreter__line_edit__draw_char
interpreter.dasm16
464
0
;----------------------------------------------------------------
interpreter.dasm16
465
3
01d1
7f4b
01d2
7000
01d3
0001
    bor [sp+1], FONT_COLOR
interpreter.dasm16
466
2
01d4
7861
01d5
026c
    set x, [line_editor__current_addr]
interpreter.dasm16
467
2
01d6
6961
01d7
0001
    set [x], [sp+1]
interpreter.dasm16
468
0

interpreter.dasm16
469
1
01d8
6321
    set [sp], pop
interpreter.dasm16
470
0
        
interpreter.dasm16
471
2
01d9
8bc2
01da
026c
    add [line_editor__current_addr], 1
interpreter.dasm16
472
2
01db
8bc2
01dc
026d
    add [line_editor__end_addr], 1
interpreter.dasm16
473
0

interpreter.dasm16
474
3
01dd
53d6
01de
0001
01df
026d
    ifl [line_editor__end_addr], [y + SCREEN__END]
interpreter.dasm16
475
1
01e0
6381
        set pc, pop
interpreter.dasm16
476
0

interpreter.dasm16
477
1
01e1
8701
    set push, 0
interpreter.dasm16
478
1
01e2
8301
    set push, -1
interpreter.dasm16
479
2
01e3
7c20
01e4
2e38
    jsr screen__scroll
interpreter.dasm16
480
0
    
interpreter.dasm16
481
3
01e5
7fc3
01e6
0020
01e7
026b
    sub [line_editor__start_addr], SCREEN_COLS
interpreter.dasm16
482
3
01e8
7fc3
01e9
0020
01ea
026c
    sub [line_editor__current_addr], SCREEN_COLS
interpreter.dasm16
483
3
01eb
7fc3
01ec
0020
01ed
026d
    sub [line_editor__end_addr], SCREEN_COLS
interpreter.dasm16
484
0
    
interpreter.dasm16
485
2
01ee
33d6
01ef
026b
    ifl [line_editor__start_addr], [y + SCREEN__START]
interpreter.dasm16
486
2
01f0
33c1
01f1
026b
        set [line_editor__start_addr], [y + SCREEN__START]
interpreter.dasm16
487
0

interpreter.dasm16
488
3
01f2
7bd6
01f3
026b
01f4
026c
    ifl [line_editor__current_addr], [line_editor__start_addr]
interpreter.dasm16
489
3
01f5
7bc1
01f6
026b
01f7
026c
        set [line_editor__current_addr], [line_editor__start_addr]
interpreter.dasm16
490
0

interpreter.dasm16
491
1
01f8
6381
    set pc, pop
interpreter.dasm16
492
0

interpreter.dasm16
493
0
;----------------------------------------------------------------
interpreter.dasm16
494
0
:interpreter__line_edit__get_str
interpreter.dasm16
495
0
;----------------------------------------------------------------
interpreter.dasm16
496
1
01f9
1b01
    set push, i
interpreter.dasm16
497
1
01fa
1f01
    set push, j
interpreter.dasm16
498
0

interpreter.dasm16
499
2
01fb
78c1
01fc
026d
    set i, [line_editor__end_addr]
interpreter.dasm16
500
0

interpreter.dasm16
501
1
01fd
1b01
    set push, i
interpreter.dasm16
502
2
01fe
7b23
01ff
026b
    sub [sp], [line_editor__start_addr]
interpreter.dasm16
503
1
0200
8b22
    add [sp], 1
interpreter.dasm16
504
0

interpreter.dasm16
505
1
0201
a701
    set push, TYPE_STR
interpreter.dasm16
506
2
0202
7c20
0203
2770
    jsr array_create
interpreter.dasm16
507
2
0204
0ea1
0205
ffff
    set [z-1], x
interpreter.dasm16
508
0

interpreter.dasm16
509
1
0206
2ce1
    set j, [x]                    ; struct string *
interpreter.dasm16
510
1
0207
3ce2
    add j, [j]                    ; string[last]
interpreter.dasm16
511
1
0208
c9ff
    std [j], KEY_NEWLINE        ; set newline, set i = end - 1, set j before newline
interpreter.dasm16
512
0

interpreter.dasm16
513
0
:interpreter__line_edit__get_str__loop
interpreter.dasm16
514
2
0209
78d6
020a
026b
    ifl i, [line_editor__start_addr]
interpreter.dasm16
515
2
020b
7f81
020c
0212
        set pc, interpreter__line_edit__get_str__finish
interpreter.dasm16
516
1
020d
39e1
    set [j], [i]
interpreter.dasm16
517
2
020e
7dea
020f
007f
    and [j], 0x007f
interpreter.dasm16
518
0
    
interpreter.dasm16
519
2
0210
7f9f
0211
0209
    std pc, interpreter__line_edit__get_str__loop
interpreter.dasm16
520
0

interpreter.dasm16
521
0
:interpreter__line_edit__get_str__finish
interpreter.dasm16
522
1
0212
60e1
    set j, pop
interpreter.dasm16
523
1
0213
60c1
    set i, pop
interpreter.dasm16
524
1
0214
6381
    set pc, pop
interpreter.dasm16
525
0

interpreter.dasm16
526
0
;----------------------------------------------------------------
interpreter.dasm16
527
0
:debug
interpreter.dasm16
528
0
;----------------------------------------------------------------
interpreter.dasm16
529
1
0215
0301
    set push, a
interpreter.dasm16
530
1
0216
0b01
    set push, c
interpreter.dasm16
531
1
0217
0f01
    set push, x
interpreter.dasm16
532
0

interpreter.dasm16
533
1
0218
c401
    set a, 16
interpreter.dasm16
534
0
:debug__loop
interpreter.dasm16
535
1
0219
9403
    sub a, 4
interpreter.dasm16
536
2
021a
7c20
021b
0228
    jsr debug__char
interpreter.dasm16
537
1
021c
8413
    ifn a, 0
interpreter.dasm16
538
2
021d
7f81
021e
0219
        set pc, debug__loop
interpreter.dasm16
539
0

interpreter.dasm16
540
2
021f
7c41
0220
0020
    set c, ' '
interpreter.dasm16
541
2
0221
7c20
0222
2ef4
    jsr screen_add_char
interpreter.dasm16
542
0

interpreter.dasm16
543
1
0223
6061
    set x, pop
interpreter.dasm16
544
1
0224
6041
    set c, pop
interpreter.dasm16
545
1
0225
6001
    set a, pop 
interpreter.dasm16
546
1
0226
6321
    set [sp], pop   
interpreter.dasm16
547
1
0227
6381
    set pc, pop
interpreter.dasm16
548
0

interpreter.dasm16
549
0
:debug__char
interpreter.dasm16
550
2
0228
6841
0229
0005
    set c, [sp+5]
interpreter.dasm16
551
1
022a
004d
    shr c, a
interpreter.dasm16
552
1
022b
c04a
    and c, 0x000f
interpreter.dasm16
553
1
022c
a854
    ifg c, 9
interpreter.dasm16
554
2
022d
7c42
022e
0037
        add c, 'A'-10
interpreter.dasm16
555
1
022f
ac56
    ifl c, 10
interpreter.dasm16
556
2
0230
7c42
0231
0030
        add c, '0'
interpreter.dasm16
557
2
0232
7c20
0233
2ef4
    jsr screen_add_char
interpreter.dasm16
558
0

interpreter.dasm16
559
1
0234
6381
    set pc, pop
data.dasm16
0
0
;----------------------------------------------------------------
data.dasm16
1
0
; GLOBAL INTERPRETER VARIABLES
data.dasm16
2
0
;----------------------------------------------------------------
data.dasm16
3
1
0235
0000
:global_scope   dat 0
data.dasm16
4
1
0236
0000
:current_scope  dat 0
data.dasm16
5
0

data.dasm16
6
1
0237
0000
:history        dat 0
data.dasm16
7
0

data.dasm16
8
1
0238
0000
:recovery_fp    dat 0
data.dasm16
9
1
0239
0000
:recovery_sp    dat 0
data.dasm16
10
0

data.dasm16
11
0
;----------------------------------------------------------------
data.dasm16
12
0
; GLOBAL DISPLAY VARIABLES
data.dasm16
13
0
;----------------------------------------------------------------
data.dasm16
14
1
023a
023b
:current_screen dat screen_first
data.dasm16
15
0

data.dasm16
16
3
023b
db80
023c
dd00
023d
db80
:screen_first    dat MEM_SCREEN_START, MEM_SCREEN_START + 0x180, MEM_SCREEN_START
data.dasm16
17
3
023e
dd00
023f
de80
0240
dd00
                dat MEM_SCREEN_START + 0x180, MEM_SCREEN_START + 0x300, MEM_SCREEN_START + 0x180
data.dasm16
18
3
0241
de80
0242
e000
0243
de80
:screen_last    dat MEM_SCREEN_START + 0x300, MEM_SCREEN_START + 0x480, MEM_SCREEN_START + 0x300
data.dasm16
19
0

data.dasm16
20
0

data.dasm16
21
0
;----------------------------------------------------------------
data.dasm16
22
0
; GLOBAL FD VARIABLES
data.dasm16
23
0
;----------------------------------------------------------------
data.dasm16
24
1
0244
0000
:floppy__file__position                    dat 0
data.dasm16
25
1
0245
0000
:floppy__buffer__position                dat 0
data.dasm16
26
0

data.dasm16
27
0
:floppy__free
data.dasm16
28
1
0246
0000
:floppy__free__head                        DAT 0
data.dasm16
29
1
0247
0000
:floppy__free__tail                        DAT 0
data.dasm16
30
0

data.dasm16
31
0
:floppy__dir
data.dasm16
32
1
0248
0000
:floppy__dir__head                        DAT 0
data.dasm16
33
1
0249
0000
:floppy__dir__tail                        DAT 0
data.dasm16
34
0

data.dasm16
35
0
;----------------------------------------------------------------
data.dasm16
36
0
; RANDOM NUMBER GENERATORS
data.dasm16
37
0
;----------------------------------------------------------------
data.dasm16
38
2
024a
be8c
024b
8000
:rnd_lfsr_seed     dat 0xbe8c,0x8000 ; 1st is anything but zero. 2nd should be 8000 or 0000
data.dasm16
39
1
024c
b400
:rnd_lfsr_poly     dat 0xb400 
data.dasm16
40
0

data.dasm16
41
0
; To seed the generator, simply overwrite the data in randseed.
data.dasm16
42
2
024d
5678
024e
1234
:rnd_lcg_seed    dat 0x5678, 0x1234
data.dasm16
43
0

data.dasm16
44
0
;----------------------------------------------------------------
data.dasm16
45
0
; GLOBAL HW VARIABLES
data.dasm16
46
0
;----------------------------------------------------------------
data.dasm16
47
1
024f
0000
:keyboard           DAT 0
data.dasm16
48
1
0250
0000
:monitor            DAT 0 
data.dasm16
49
1
0251
0000
:clock              DAT 0
data.dasm16
50
1
0252
0000
:floppy             DAT 0
data.dasm16
51
0
     
data.dasm16
52
0
;----------------------------------------------------------------
data.dasm16
53
0
; GLOBAL HEAP MANAGEMENT VARIABLES
data.dasm16
54
0
;----------------------------------------------------------------
data.dasm16
55
1
0253
0028
:heap_counter         DAT HEAP_GC_TRIGGER
data.dasm16
56
1
0254
4000
:heap_free_start    DAT MEM_HEAP_START
data.dasm16
57
0

data.dasm16
58
1
0255
d980
:heap_handle_start  DAT MEM_HEAP_END
data.dasm16
59
1
0256
0000
:heap_handle_head   DAT 0
data.dasm16
60
1
0257
0253
:heap_handle_tail   DAT heap_handle_head - HANDLE_NEXT
data.dasm16
61
1
0258
0000
:heap_handle_free   DAT 0
data.dasm16
62
0

data.dasm16
63
0
;----------------------------------------------------------------
data.dasm16
64
0
; GLOBAL LEXER VARIABLES
data.dasm16
65
0
;----------------------------------------------------------------
data.dasm16
66
1
0259
0000
:lexer_string       dat 0
data.dasm16
67
1
025a
0000
:lexer_target_indent    dat 0
data.dasm16
68
1
025b
0000
:lexer_current_indent   dat 0
data.dasm16
69
1
025c
0000
:lexer_token        dat 0
data.dasm16
70
1
025d
0000
:lexer_start        dat 0
data.dasm16
71
1
025e
0000
:lexer_end      dat 0
data.dasm16
72
0

data.dasm16
73
0
;----------------------------------------------------------------
data.dasm16
74
0
; GLOBAL EDITOR VARIABLES
data.dasm16
75
0
;----------------------------------------------------------------
data.dasm16
76
1
025f
0000
:buf_start  dat 0
data.dasm16
77
1
0260
0000
:buf_end    dat 0
data.dasm16
78
0

data.dasm16
79
1
0261
0000
:gap_start  dat 0
data.dasm16
80
1
0262
0000
:gap_end    dat 0
data.dasm16
81
0

data.dasm16
82
1
0263
0000
:win_start  dat 0
data.dasm16
83
1
0264
0000
:win_shift  dat 0
data.dasm16
84
0

data.dasm16
85
1
0265
0000
:cur_pos    dat 0
data.dasm16
86
1
0266
0000
:cur_line   dat 0
data.dasm16
87
0

data.dasm16
88
1
0267
0000
:cur_x      dat 0
data.dasm16
89
1
0268
0000
:cur_y      dat 0
data.dasm16
90
0

data.dasm16
91
1
0269
0000
:prev_char  dat 0
data.dasm16
92
0

data.dasm16
93
0
;----------------------------------------------------------------
data.dasm16
94
0
; INTERPRETER LINE EDITOR
data.dasm16
95
0
;----------------------------------------------------------------
data.dasm16
96
0
;----------------------------------------------------------------
data.dasm16
97
0
; current history line 0-4
data.dasm16
98
1
026a
0000
:line_editor__buf_index        dat            0
data.dasm16
99
1
026b
0000
:line_editor__start_addr    dat            0
data.dasm16
100
1
026c
0000
:line_editor__current_addr    dat            0
data.dasm16
101
1
026d
0000
:line_editor__end_addr        dat            0
data.dasm16
102
1
026e
0000
:line_editor__last_char        dat            0
data.dasm16
103
0

data.dasm16
104
0
;----------------------------------------------------------------
data.dasm16
105
0
; DICT HELPERS
data.dasm16
106
0
;----------------------------------------------------------------
data.dasm16
107
0
:dict__get__finish
data.dasm16
108
1
026f
2f43
    dat dict__get__match
data.dasm16
109
1
0270
2f4d
    dat dict__get__no_match
data.dasm16
110
0

data.dasm16
111
0
:dict__set__finish
data.dasm16
112
1
0271
2f7a
    dat dict__set__match
data.dasm16
113
1
0272
2f7e
    dat dict__set__no_match
data.dasm16
114
0

data.dasm16
115
0
;----------------------------------------------------------------
data.dasm16
116
0
; CRYPT LIB
data.dasm16
117
0
;----------------------------------------------------------------
data.dasm16
118
0
:crypt__State
data.dasm16
119
4
0273
0000
0274
0000
0275
0000
0276
0000
dat 0x0, 0x0, 0x0, 0x0
data.dasm16
120
4
0277
0000
0278
0000
0279
0000
027a
0000
dat 0x0, 0x0, 0x0, 0x0
data.dasm16
121
0

data.dasm16
122
0
:crypt__SBoxE
data.dasm16
123
4
027b
7ce9
027c
215f
027d
b6d0
027e
48a3
dat 0x7ce9, 0x215f, 0xb6d0, 0x48a3
data.dasm16
124
4
027f
4a16
0280
8f7c
0281
30ed
0282
59b2
dat 0x4a16, 0x8f7c, 0x30ed, 0x59b2
data.dasm16
125
4
0283
2fc1
0284
56ad
0285
e834
0286
0b97
dat 0x2fc1, 0x56ad, 0xe834, 0x0b97
data.dasm16
126
4
0287
f458
0288
9721
0289
a30e
028a
6cdb
dat 0xf458, 0x9721, 0xa30e, 0x6cdb
data.dasm16
127
0

data.dasm16
128
0
:crypt__SBoxD
data.dasm16
129
4
028b
b54f
028c
c690
028d
d3e8
028e
1a27
dat 0xb54f, 0xc690, 0xd3e8, 0x1a27
data.dasm16
130
4
028f
92f8
0290
0c36
0291
4d1e
0292
7ba5
dat 0x92f8, 0x0c36, 0x4d1e, 0x7ba5
data.dasm16
131
4
0293
c30a
0294
b45f
0295
9e6d
0296
2781
dat 0xc30a, 0xb45f, 0x9e6d, 0x2781
data.dasm16
132
4
0297
a769
0298
12c5
0299
348f
029a
deb0
dat 0xa769, 0x12c5, 0x348f, 0xdeb0
data.dasm16
133
0
;----------------------------------------------------------------
data.dasm16
134
0
; CONSTANT DATA VALUES
data.dasm16
135
0
;----------------------------------------------------------------
data.dasm16
136
2
029b
0000
029c
0080
:NONE       dat 0, TYPE_NONE
data.dasm16
137
2
029d
0000
029e
4000
:VOID       dat 0, TYPE_VOID
data.dasm16
138
0

data.dasm16
139
4
029f
02a1
02a0
0020
02a1
0001
02a2
ffff
:INT_N1     dat INT_N1 + 2, TYPE_INT, 0x0001, 0xFFFF
data.dasm16
140
0
:INT_TABLE
data.dasm16
141
4
02a3
02a5
02a4
0020
02a5
0001
02a6
0000
:INT_0      dat INT_0 + 2, TYPE_INT, 0x0001, 0x0000
data.dasm16
142
4
02a7
02a9
02a8
0020
02a9
0001
02aa
0001
:INT_1      dat INT_1 + 2, TYPE_INT, 0x0001, 0x0001
data.dasm16
143
4
02ab
02ad
02ac
0020
02ad
0001
02ae
0002
:INT_2      dat INT_2 + 2, TYPE_INT, 0x0001, 0x0002
data.dasm16
144
4
02af
02b1
02b0
0020
02b1
0001
02b2
0003
:INT_3      dat INT_3 + 2, TYPE_INT, 0x0001, 0x0003
data.dasm16
145
4
02b3
02b5
02b4
0020
02b5
0001
02b6
0004
:INT_4      dat INT_4 + 2, TYPE_INT, 0x0001, 0x0004
data.dasm16
146
4
02b7
02b9
02b8
0020
02b9
0001
02ba
0005
:INT_5      dat INT_5 + 2, TYPE_INT, 0x0001, 0x0005
data.dasm16
147
4
02bb
02bd
02bc
0020
02bd
0001
02be
0006
:INT_6      dat INT_6 + 2, TYPE_INT, 0x0001, 0x0006
data.dasm16
148
4
02bf
02c1
02c0
0020
02c1
0001
02c2
0007
:INT_7      dat INT_7 + 2, TYPE_INT, 0x0001, 0x0007
data.dasm16
149
4
02c3
02c5
02c4
0020
02c5
0001
02c6
0008
:INT_8      dat INT_8 + 2, TYPE_INT, 0x0001, 0x0008
data.dasm16
150
4
02c7
02c9
02c8
0020
02c9
0001
02ca
0009
:INT_9      dat INT_9 + 2, TYPE_INT, 0x0001, 0x0009
data.dasm16
151
4
02cb
02cd
02cc
0020
02cd
0001
02ce
000a
:INT_10     dat INT_10 + 2, TYPE_INT, 0x0001, 0x000a
data.dasm16
152
4
02cf
02d1
02d0
0020
02d1
0001
02d2
000b
:INT_11     dat INT_11 + 2, TYPE_INT, 0x0001, 0x000b
data.dasm16
153
4
02d3
02d5
02d4
0020
02d5
0001
02d6
000c
:INT_12     dat INT_12 + 2, TYPE_INT, 0x0001, 0x000c 
data.dasm16
154
4
02d7
02d9
02d8
0020
02d9
0001
02da
000d
:INT_13     dat INT_13 + 2, TYPE_INT, 0x0001, 0x000d 
data.dasm16
155
4
02db
02dd
02dc
0020
02dd
0001
02de
000e
:INT_14     dat INT_14 + 2, TYPE_INT, 0x0001, 0x000e 
data.dasm16
156
4
02df
02e1
02e0
0020
02e1
0001
02e2
000f
:INT_15     dat INT_15 + 2, TYPE_INT, 0x0001, 0x000f 
data.dasm16
157
4
02e3
02e5
02e4
0020
02e5
0001
02e6
0010
:INT_16     dat INT_16 + 2, TYPE_INT, 0x0001, 0x0010
data.dasm16
158
0

data.dasm16
159
2
02e7
02a5
02e8
0010
:BOOL_FALSE  dat INT_0 + 2, TYPE_BOOL
data.dasm16
160
2
02e9
02a9
02ea
0010
:BOOL_TRUE   dat INT_1 + 2, TYPE_BOOL
data.dasm16
161
0

data.dasm16
162
6
02eb
02ed
02ec
0040
02ed
8000
02ee
0000
02ef
0000
02f0
0000
:FLOAT_NAN      DAT FLOAT_NAN   + 2, TYPE_FLOAT, FLOAT_TYPE_NAN,   0x0000, 0x0000, 0x0000
data.dasm16
163
6
02f1
02f3
02f2
0040
02f3
fffd
02f4
0000
02f5
0000
02f6
0000
:FLOAT_PINF     DAT FLOAT_PINF  + 2, TYPE_FLOAT, FLOAT_TYPE_PINF,  0x0000, 0x0000, 0x0000
data.dasm16
164
6
02f7
02f9
02f8
0040
02f9
0003
02fa
0000
02fb
0000
02fc
0000
:FLOAT_NINF     DAT FLOAT_NINF  + 2, TYPE_FLOAT, FLOAT_TYPE_NINF,  0x0000, 0x0000, 0x0000
data.dasm16
165
6
02fd
02ff
02fe
0040
02ff
0001
0300
0000
0301
0000
0302
0000
:FLOAT_NZERO    DAT FLOAT_NZERO + 2, TYPE_FLOAT, FLOAT_TYPE_NZERO, 0x0000, 0x0000, 0x0000
data.dasm16
166
0

data.dasm16
167
5
0303
030d
0304
0313
0305
0319
0306
031f
0307
0325
:FLOAT_TABLE    DAT FLOAT_0, FLOAT_1, FLOAT_2, FLOAT_3, FLOAT_4
data.dasm16
168
5
0308
032b
0309
0331
030a
0337
030b
033d
030c
0343
                DAT FLOAT_5, FLOAT_6, FLOAT_7, FLOAT_8, FLOAT_9
data.dasm16
169
0

data.dasm16
170
0
:FLOAT_PZERO
data.dasm16
171
6
030d
030f
030e
0040
030f
ffff
0310
0000
0311
0000
0312
0000
:FLOAT_0        DAT FLOAT_0     + 2, TYPE_FLOAT, FLOAT_TYPE_PZERO, 0x0000, 0x0000, 0x0000
data.dasm16
172
6
0313
0315
0314
0040
0315
fffe
0316
8000
0317
8000
0318
0000
:FLOAT_1        DAT FLOAT_1     + 2, TYPE_FLOAT, FLOAT_TYPE_PNUM,  0x8000, 0x8000, 0x0000
data.dasm16
173
6
0319
031b
031a
0040
031b
fffe
031c
8001
031d
8000
031e
0000
:FLOAT_2        DAT FLOAT_2     + 2, TYPE_FLOAT, FLOAT_TYPE_PNUM,  0x8001, 0x8000, 0x0000
data.dasm16
174
6
031f
0321
0320
0040
0321
fffe
0322
8001
0323
c000
0324
0000
:FLOAT_3        DAT FLOAT_3     + 2, TYPE_FLOAT, FLOAT_TYPE_PNUM,  0x8001, 0xC000, 0x0000
data.dasm16
175
6
0325
0327
0326
0040
0327
fffe
0328
8002
0329
8000
032a
0000
:FLOAT_4        DAT FLOAT_4     + 2, TYPE_FLOAT, FLOAT_TYPE_PNUM,  0x8002, 0x8000, 0x0000
data.dasm16
176
6
032b
032d
032c
0040
032d
fffe
032e
8002
032f
a000
0330
0000
:FLOAT_5        DAT FLOAT_5     + 2, TYPE_FLOAT, FLOAT_TYPE_PNUM,  0x8002, 0xA000, 0x0000
data.dasm16
177
6
0331
0333
0332
0040
0333
fffe
0334
8002
0335
c000
0336
0000
:FLOAT_6        DAT FLOAT_6     + 2, TYPE_FLOAT, FLOAT_TYPE_PNUM,  0x8002, 0xC000, 0x0000
data.dasm16
178
6
0337
0339
0338
0040
0339
fffe
033a
8002
033b
e000
033c
0000
:FLOAT_7        DAT FLOAT_7     + 2, TYPE_FLOAT, FLOAT_TYPE_PNUM,  0x8002, 0xE000, 0x0000
data.dasm16
179
6
033d
033f
033e
0040
033f
fffe
0340
8003
0341
8000
0342
0000
:FLOAT_8        DAT FLOAT_8     + 2, TYPE_FLOAT, FLOAT_TYPE_PNUM,  0x8003, 0x8000, 0x0000
data.dasm16
180
6
0343
0345
0344
0040
0345
fffe
0346
8003
0347
9000
0348
0000
:FLOAT_9        DAT FLOAT_9     + 2, TYPE_FLOAT, FLOAT_TYPE_PNUM,  0x8003, 0x9000, 0x0000
data.dasm16
181
6
0349
034b
034a
0040
034b
fffe
034c
8003
034d
a000
034e
0000
:FLOAT_10       DAT FLOAT_10    + 2, TYPE_FLOAT, FLOAT_TYPE_PNUM,  0x8003, 0xA000, 0x0000
data.dasm16
182
0

data.dasm16
183
6
034f
0351
0350
0008
0351
0003
0352
0069
0353
006e
0354
0066
:STR_PINF            DAT STR_PINF+2, TYPE_STR, 3, "inf"
data.dasm16
184
7
0355
0357
0356
0008
0357
0004
0358
002d
0359
0069
035a
006e
035b
0066
:STR_NINF            DAT STR_NINF+2, TYPE_STR, 4, "-inf"
data.dasm16
185
6
035c
035e
035d
0008
035e
0003
035f
0030
0360
002e
0361
0030
:STR_PZERO            DAT STR_PZERO+2, TYPE_STR, 3, "0.0"
data.dasm16
186
7
0362
0364
0363
0008
0364
0004
0365
002d
0366
0030
0367
002e
0368
0030
:STR_NZERO            DAT STR_NZERO+2, TYPE_STR, 4, "-0.0"
data.dasm16
187
6
0369
036b
036a
0008
036b
0003
036c
006e
036d
0061
036e
006e
:STR_NAN            DAT STR_NAN+2, TYPE_STR, 3, "nan"
data.dasm16
188
0

data.dasm16
189
35
036f
0371
0370
0008
0371
0020
0372
0020
0373
002a
0374
002a
0375
0020
0376
0044
0377
0043
0378
0050
0379
0055
037a
0020
037b
0041
037c
0044
037d
004d
037e
0049
037f
0052
0380
0041
0381
004c
0382
0020
0383
0049
0384
004e
0385
0054
0386
0045
0387
0052
0388
0050
0389
0052
038a
0045
038b
0054
038c
0045
038d
0052
038e
0020
038f
002a
0390
002a
0391
0020
:STR_STARTUP    DAT STR_STARTUP + 2, TYPE_STR, 32, " ** DCPU ADMIRAL INTERPRETER ** "
data.dasm16
190
19
0392
0394
0393
0008
0394
0010
0395
0036
0396
0034
0397
004b
0398
0020
0399
0052
039a
0041
039b
004d
039c
0020
039d
0053
039e
0059
039f
0053
03a0
0054
03a1
0045
03a2
004d
03a3
0020
03a4
0020
:STR_STARTUP2    DAT STR_STARTUP2 + 2, TYPE_STR, 16, "64K RAM SYSTEM  "
data.dasm16
191
14
03a5
03a7
03a6
0008
03a7
000b
03a8
0020
03a9
0057
03aa
004f
03ab
0052
03ac
0044
03ad
0053
03ae
0020
03af
0046
03b0
0052
03b1
0045
03b2
0045
:STR_STARTUP3    DAT STR_STARTUP3 + 2, TYPE_STR, 11, " WORDS FREE"
data.dasm16
192
4
03b3
03b5
03b4
0008
03b5
0001
03b6
003e
:STR_PROMPT     DAT STR_PROMPT + 2, TYPE_STR, 1, ">"
data.dasm16
193
9
03b7
03b9
03b8
0008
03b9
0006
03ba
0045
03bb
0052
03bc
0052
03bd
004f
03be
0052
03bf
003a
:STR_ERROR      DAT STR_ERROR + 2, TYPE_STR, 6, "ERROR:"
data.dasm16
194
11
03c0
03c2
03c1
0008
03c2
0008
03c3
004d
03c4
0041
03c5
0049
03c6
004e
03c7
002e
03c8
0042
03c9
0049
03ca
004e
:STR_AUTOEXEC    DAT STR_AUTOEXEC + 2, TYPE_STR, 8, "MAIN.BIN"
data.dasm16
195
7
03cb
03cd
03cc
0800
03cd
0004
03ce
006d
03cf
0061
03d0
0069
03d1
006e
:STR_MAIN        DAT STR_MAIN + 2, TYPE_NAME, 4, "main"
data.dasm16
196
0

data.dasm16
197
4
03d2
03d4
03d3
0800
03d4
0001
03d5
005f
:STR_UNDERSCORE DAT STR_UNDERSCORE + 2, TYPE_NAME, 1, "_"
data.dasm16
198
5
03d6
03d8
03d7
0800
03d8
0002
03d9
0065
03da
0078
:STR_EX         DAT STR_EX + 2, TYPE_NAME, 2, "ex"
data.dasm16
199
5
03db
03dd
03dc
0800
03dd
0002
03de
006d
03df
0065
:STR_ME         DAT STR_ME + 2, TYPE_NAME, 2, "me"
data.dasm16
200
7
03e0
03e2
03e1
0800
03e2
0004
03e3
0061
03e4
0072
03e5
0067
03e6
0076
:STR_ARGV        DAT STR_ARGV + 2, TYPE_NAME, 4, "argv"
data.dasm16
201
0

data.dasm16
202
7
03e7
03e9
03e8
0008
03e9
0004
03ea
006e
03eb
006f
03ec
006e
03ed
0065
:STR_NONE       DAT STR_NONE + 2, TYPE_STR, 4, "none"
data.dasm16
203
7
03ee
03f0
03ef
0008
03f0
0004
03f1
0074
03f2
0072
03f3
0075
03f4
0065
:STR_TRUE       DAT STR_TRUE + 2, TYPE_STR, 4, "true"
data.dasm16
204
8
03f5
03f7
03f6
0008
03f7
0005
03f8
0066
03f9
0061
03fa
006c
03fb
0073
03fc
0065
:STR_FALSE      DAT STR_FALSE + 2, TYPE_STR, 5, "false"
data.dasm16
205
3
03fd
03ff
03fe
0008
03ff
0000
:STR_EMPTY      DAT STR_EMPTY + 2, TYPE_STR, 0
data.dasm16
206
0

data.dasm16
207
16
0400
0030
0401
0031
0402
0032
0403
0033
0404
0034
0405
0035
0406
0036
0407
0037
0408
0038
0409
0039
040a
0061
040b
0062
040c
0063
040d
0064
040e
0065
040f
0066
:HEX            DAT "0123456789abcdef"
data.dasm16
208
0

data.dasm16
209
0
;----------------------------------------------------------------
data.dasm16
210
0
; TOKENS
data.dasm16
211
0
;----------------------------------------------------------------
data.dasm16
212
0
; controls
data.dasm16
213
4
0410
07bf
0411
00c6
0412
00c6
0413
0000
:token_eof          dat std_eof, recover, recover, 0x0000
data.dasm16
214
4
0414
07bd
0415
00c6
0416
00c6
0417
0000
:token_newline      dat std_newline, recover, recover, 0x0000
data.dasm16
215
4
0418
07c3
0419
00c6
041a
00c6
041b
0000
:token_indent       dat std_indent, recover, recover, 0x0000
data.dasm16
216
4
041c
07c3
041d
00c6
041e
00c6
041f
0000
:token_dedent       dat std_dedent, recover, recover, 0x0000
data.dasm16
217
0

data.dasm16
218
0
; atoms
data.dasm16
219
4
0420
0aaf
0421
0b1f
0422
00c6
0423
0000
:token_int          dat std_expression, nud_int, recover, 0x0000
data.dasm16
220
4
0424
0aaf
0425
0b17
0426
00c6
0427
0000
:token_hex          dat std_expression, nud_hex, recover, 0x0000
data.dasm16
221
4
0428
0aaf
0429
0b1b
042a
00c6
042b
0000
:token_float        dat std_expression, nud_float, recover, 0x0000
data.dasm16
222
4
042c
0aaf
042d
0b0e
042e
00c6
042f
0000
:token_name         dat std_expression, nud_name, recover, 0x0000
data.dasm16
223
4
0430
0aaf
0431
0b0e
0432
00c6
0433
0000
:token_str          dat std_expression, nud_str, recover, 0x0000
data.dasm16
224
4
0434
0aaf
0435
0b2e
0436
00c6
0437
0000
:token_none         dat std_expression, nud_none, recover, 0x0000
data.dasm16
225
4
0438
0aaf
0439
0b33
043a
00c6
043b
0000
:token_true         dat std_expression, nud_true, recover, 0x0000
data.dasm16
226
4
043c
0aaf
043d
0b38
043e
00c6
043f
0000
:token_false        dat std_expression, nud_false, recover, 0x0000
data.dasm16
227
0

data.dasm16
228
0
; nud operators
data.dasm16
229
4
0440
0aaf
0441
0c0c
0442
00c6
0443
0000
:token_tilde        dat std_expression, nud_tilde, recover, 0x0000
data.dasm16
230
0

data.dasm16
231
0
; statements
data.dasm16
232
4
0444
0994
0445
00c6
0446
00c6
0447
0000
:token_if           dat std_if, recover, recover, 0x0000
data.dasm16
233
4
0448
07c5
0449
00c6
044a
00c6
044b
0000
:token_cls          dat std_cls, recover, recover, 0x0000
data.dasm16
234
4
044c
097a
044d
00c6
044e
00c6
044f
0000
:token_del          dat std_del, recover, recover, 0x0000
data.dasm16
235
4
0450
0911
0451
00c6
0452
00c6
0453
0000
:token_for          dat std_for, recover, recover, 0x0000
data.dasm16
236
4
0454
07d2
0455
00c6
0456
00c6
0457
0000
:token_run          dat std_run, recover, recover, 0x0000
data.dasm16
237
4
0458
00c6
0459
00c6
045a
00c6
045b
0000
:token_elif         dat recover, recover, recover, 0x0000
data.dasm16
238
4
045c
00c6
045d
00c6
045e
00c6
045f
0000
:token_else         dat recover, recover, recover, 0x0000
data.dasm16
239
4
0460
0903
0461
00c6
0462
00c6
0463
0000
:token_pass         dat std_pass, recover, recover, 0x0000
data.dasm16
240
4
0464
087f
0465
00c6
0466
00c6
0467
0000
:token_print            dat std_print, recover, recover, 0x0000
data.dasm16
241
4
0468
0a07
0469
00c6
046a
00c6
046b
0000
:token_while            dat std_while, recover, recover, 0x0000
data.dasm16
242
4
046c
08e8
046d
00c6
046e
00c6
046f
0000
:token_break            dat std_break, recover, recover, 0x0000
data.dasm16
243
4
0470
07cd
0471
00c6
0472
00c6
0473
0000
:token_reset            dat std_reset, recover, recover, 0x0000
data.dasm16
244
4
0474
08c2
0475
00c6
0476
00c6
0477
0000
:token_return           dat std_return, recover, recover, 0x0000
data.dasm16
245
4
0478
08e8
0479
00c6
047a
00c6
047b
0000
:token_continue         dat std_continue, recover, recover, 0x0000
data.dasm16
246
0

data.dasm16
247
0
; assignments
data.dasm16
248
4
047c
00c6
047d
00c6
047e
0ea5
047f
0010
:token_assign           dat recover, recover, led_assign, 0x0010
data.dasm16
249
4
0480
00c6
0481
00c6
0482
0ee5
0483
0010
:token_augass_plus      dat recover, recover, led_augass_plus, 0x0010
data.dasm16
250
4
0484
00c6
0485
00c6
0486
0ee9
0487
0010
:token_augass_minus     dat recover, recover, led_augass_minus, 0x0010
data.dasm16
251
4
0488
00c6
0489
00c6
048a
0eed
048b
0010
:token_augass_star      dat recover, recover, led_augass_star, 0x0010
data.dasm16
252
4
048c
00c6
048d
00c6
048e
0ef1
048f
0010
:token_augass_slash     dat recover, recover, led_augass_slash, 0x0010
data.dasm16
253
4
0490
00c6
0491
00c6
0492
0ef5
0493
0010
:token_augass_percent   dat recover, recover, led_augass_percent, 0x0010
data.dasm16
254
4
0494
00c6
0495
00c6
0496
0ed9
0497
0010
:token_augass_or        dat recover, recover, led_augass_or, 0x0010
data.dasm16
255
4
0498
00c6
0499
00c6
049a
0edd
049b
0010
:token_augass_xor       dat recover, recover, led_augass_xor, 0x0010
data.dasm16
256
4
049c
00c6
049d
00c6
049e
0ee1
049f
0010
:token_augass_and       dat recover, recover, led_augass_and, 0x0010
data.dasm16
257
4
04a0
00c6
04a1
00c6
04a2
0ed1
04a3
0010
:token_augass_lshift    dat recover, recover, led_augass_lshift, 0x0010
data.dasm16
258
4
04a4
00c6
04a5
00c6
04a6
0ed5
04a7
0010
:token_augass_rshift    dat recover, recover, led_augass_rshift, 0x0010
data.dasm16
259
0

data.dasm16
260
0
; tuple constructor
data.dasm16
261
4
04a8
00c6
04a9
00c6
04aa
1079
04ab
0020
:token_comma            dat recover, recover, led_comma, 0x0020
data.dasm16
262
0

data.dasm16
263
0
; tuple constructor
data.dasm16
264
0
;:token_colon           dat recover, recover, led_colon, 0x0030
data.dasm16
265
4
04ac
00c6
04ad
00c6
04ae
00c6
04af
0000
:token_colon            dat recover, recover, recover, 0x0000
data.dasm16
266
0

data.dasm16
267
0
; logical operators
data.dasm16
268
4
04b0
00c6
04b1
00c6
04b2
0c5a
04b3
0040
:token_or           dat recover, recover, led_or, 0x0040
data.dasm16
269
4
04b4
00c6
04b5
00c6
04b6
0c46
04b7
0050
:token_and          dat recover, recover, led_and, 0x0050
data.dasm16
270
4
04b8
00c6
04b9
00c6
04ba
0ccd
04bb
0060
:token_in           dat recover, recover, led_in, 0x0060
data.dasm16
271
4
04bc
0aaf
04bd
0c29
04be
0cc4
04bf
0060
:token_not          dat std_expression, nud_not, led_not, 0x0060
data.dasm16
272
4
04c0
00c6
04c1
00c6
04c2
0c8f
04c3
0070
:token_is           dat recover, recover, led_is, 0x0070
data.dasm16
273
0

data.dasm16
274
0
; equality operators
data.dasm16
275
4
04c4
00c6
04c5
00c6
04c6
0d61
04c7
0080
:token_equal            dat recover, recover, led_equal, 0x0080
data.dasm16
276
4
04c8
00c6
04c9
00c6
04ca
0d2d
04cb
0080
:token_less         dat recover, recover, led_less, 0x0080
data.dasm16
277
4
04cc
00c6
04cd
00c6
04ce
0d20
04cf
0080
:token_less_or_equal        dat recover, recover, led_less_or_equal, 0x0080
data.dasm16
278
4
04d0
00c6
04d1
00c6
04d2
0d47
04d3
0080
:token_greater          dat recover, recover, led_greater, 0x0080
data.dasm16
279
4
04d4
00c6
04d5
00c6
04d6
0d3a
04d7
0080
:token_greater_or_equal     dat recover, recover, led_greater_or_equal, 0x0080
data.dasm16
280
4
04d8
00c6
04d9
00c6
04da
0d54
04db
0080
:token_not_equal        dat recover, recover, led_not_equal, 0x0080
data.dasm16
281
0

data.dasm16
282
0
; bitwise operators
data.dasm16
283
4
04dc
00c6
04dd
00c6
04de
0e13
04df
0090
:token_bitwise_or   dat recover, recover, led_bitwise_or, 0x0090
data.dasm16
284
4
04e0
00c6
04e1
00c6
04e2
0e27
04e3
0100
:token_bitwise_xor  dat recover, recover, led_bitwise_xor, 0x0100
data.dasm16
285
4
04e4
00c6
04e5
00c6
04e6
0e3b
04e7
0110
:token_bitwise_and  dat recover, recover, led_bitwise_and, 0x0110
data.dasm16
286
0

data.dasm16
287
0
; shifts
data.dasm16
288
4
04e8
00c6
04e9
00c6
04ea
0e4f
04eb
0120
:token_lshift       dat recover, recover, led_lshift, 0x0120
data.dasm16
289
4
04ec
00c6
04ed
00c6
04ee
0e63
04ef
0120
:token_rshift       dat recover, recover, led_rshift, 0x0120
data.dasm16
290
0

data.dasm16
291
0
; arithmetic operators
data.dasm16
292
4
04f0
0aaf
04f1
0be2
04f2
0d8a
04f3
0130
:token_plus         dat std_expression, nud_plus, led_plus, 0x0130
data.dasm16
293
4
04f4
0aaf
04f5
0be9
04f6
0daf
04f7
0130
:token_minus        dat std_expression, nud_minus, led_minus, 0x0130
data.dasm16
294
0

data.dasm16
295
4
04f8
00c6
04f9
00c6
04fa
0dc9
04fb
0140
:token_star         dat recover, recover, led_star, 0x0140
data.dasm16
296
4
04fc
00c6
04fd
00c6
04fe
0e77
04ff
0140
:token_slash            dat recover, recover, led_slash, 0x0140
data.dasm16
297
4
0500
00c6
0501
00c6
0502
0e91
0503
0140
:token_percent          dat recover, recover, led_percent, 0x0140
data.dasm16
298
4
0504
00c6
0505
00c6
0506
0df7
0507
0170
:token_power            dat recover, recover, led_power, 0x0170
data.dasm16
299
0

data.dasm16
300
0
; blaa blaa
data.dasm16
301
4
0508
0aaf
0509
0b62
050a
0fa5
050b
0180
:token_lbrack           dat std_expression, nud_lbrack, led_lbrack, 0x0180
data.dasm16
302
4
050c
00c6
050d
00c6
050e
00c6
050f
0000
:token_rbrack           dat recover, recover, recover, 0x0000
data.dasm16
303
0

data.dasm16
304
4
0510
0aaf
0511
0b3d
0512
0ef9
0513
0200
:token_lparen           dat std_expression, nud_lparen, led_lparen, 0x0200
data.dasm16
305
4
0514
00c6
0515
00c6
0516
00c6
0517
0000
:token_rparen           dat recover, recover, recover, 0x0000
data.dasm16
306
0

data.dasm16
307
4
0518
0aaf
0519
0b98
051a
00c6
051b
0000
:token_lcurly           dat std_expression, nud_lcurly, recover, 0x0000
data.dasm16
308
4
051c
00c6
051d
00c6
051e
00c6
051f
0000
:token_rcurly           dat recover, recover, recover, 0x0000
data.dasm16
309
0

data.dasm16
310
4
0520
00c6
0521
00c6
0522
102b
0523
0210
:token_reference        dat recover, recover, led_reference, 0x0210
data.dasm16
311
0

data.dasm16
312
0
;----------------------------------------------------------------
data.dasm16
313
0
; BUILT IN FUNCTIONS
data.dasm16
314
0
; length+1, function_name, function_impl_ptr
data.dasm16
315
0
; last line is the default if nothing matches
data.dasm16
316
0
;----------------------------------------------------------------
data.dasm16
317
0
:built_in_functions
data.dasm16
318
4
0524
0003
0525
0069
0526
0064
0527
111e
    dat 3, "id", built_in_id
data.dasm16
319
4
0528
0003
0529
0072
052a
006d
052b
12ac
    dat 3, "rm", built_in_rm
data.dasm16
320
5
052c
0004
052d
0064
052e
0069
052f
0072
0530
1274
    dat 4, "dir", built_in_dir
data.dasm16
321
5
0531
0004
0532
0068
0533
0065
0534
0078
0535
132d
    dat 4, "hex", built_in_hex
data.dasm16
322
5
0536
0004
0537
0068
0538
0077
0539
0069
053a
14c0
    dat 4, "hwi", built_in_hwi
data.dasm16
323
5
053b
0004
053c
0068
053d
0077
053e
006e
053f
14b5
    dat 4, "hwn", built_in_hwn
data.dasm16
324
5
0540
0004
0541
0068
0542
0077
0543
0071
0544
14d7
    dat 4, "hwq", built_in_hwq
data.dasm16
325
5
0545
0004
0546
006d
0547
0065
0548
006d
0549
1188
    dat 4, "mem", built_in_mem
data.dasm16
326
5
054a
0004
054b
0072
054c
006e
054d
0064
054e
1202
    dat 4, "rnd", built_in_rnd
data.dasm16
327
5
054f
0004
0550
0069
0551
006e
0552
0074
0553
12bc
    dat 4, "int", built_in_int
data.dasm16
328
5
0554
0004
0555
0073
0556
0074
0557
0072
0558
133e
    dat 4, "str", built_in_str
data.dasm16
329
5
0559
0004
055a
006c
055b
0065
055c
006e
055d
1255
    dat 4, "len", built_in_len
data.dasm16
330
5
055e
0004
055f
0061
0560
0062
0561
0073
0562
123c
    dat 4, "abs", built_in_abs
data.dasm16
331
5
0563
0004
0564
006f
0565
0072
0566
0064
0567
11da
    dat 4, "ord", built_in_ord
data.dasm16
332
5
0568
0004
0569
0063
056a
0068
056b
0072
056c
11c4
    dat 4, "chr", built_in_chr
data.dasm16
333
5
056d
0004
056e
0063
056f
006d
0570
0070
0571
11ae
    dat 4, "cmp", built_in_cmp
data.dasm16
334
5
0572
0004
0573
006b
0574
0065
0575
0079
0576
136c
    dat 4, "key", built_in_key
data.dasm16
335
6
0577
0005
0578
0062
0579
006f
057a
006f
057b
006c
057c
134e
    dat 5, "bool", built_in_bool
data.dasm16
336
6
057d
0005
057e
0063
057f
0061
0580
006c
0581
006c
0582
141c
    dat 5, "call", built_in_call
data.dasm16
337
6
0583
0005
0584
0065
0585
0064
0586
0069
0587
0074
0588
11ef
    dat 5, "edit", built_in_edit
data.dasm16
338
6
0589
0005
058a
0065
058b
0078
058c
0069
058d
0074
058e
119a
    dat 5, "exit", built_in_exit
data.dasm16
339
6
058f
0005
0590
0067
0591
0065
0592
0074
0593
0063
0594
1359
    dat 5, "getc", built_in_getchar
data.dasm16
340
6
0595
0005
0596
006c
0597
006f
0598
0061
0599
0064
059a
1288
    dat 5, "load", built_in_load
data.dasm16
341
6
059b
0005
059c
0070
059d
0065
059e
0065
059f
006b
05a0
143c
    dat 5, "peek", built_in_peek
data.dasm16
342
6
05a1
0005
05a2
0070
05a3
006f
05a4
006b
05a5
0065
05a6
146c
    dat 5, "poke", built_in_poke
data.dasm16
343
6
05a7
0005
05a8
0072
05a9
0065
05aa
0061
05ab
0064
05ac
1499
    dat 5, "read", built_in_read
data.dasm16
344
6
05ad
0005
05ae
0072
05af
0065
05b0
0070
05b1
0072
05b2
1320
    dat 5, "repr", built_in_repr
data.dasm16
345
6
05b3
0005
05b4
0073
05b5
0061
05b6
0076
05b7
0065
05b8
1298
    dat 5, "save", built_in_save
data.dasm16
346
6
05b9
0005
05ba
0073
05bb
006f
05bc
0072
05bd
0074
05be
13a2
    dat 5, "sort", built_in_sort
data.dasm16
347
6
05bf
0005
05c0
0074
05c1
0079
05c2
0070
05c3
0065
05c4
1267
    dat 5, "type", built_in_type
data.dasm16
348
6
05c5
0005
05c6
0077
05c7
0067
05c8
0065
05c9
0074
05ca
13f0
    dat 5, "wget", built_in_win_get
data.dasm16
349
6
05cb
0005
05cc
0077
05cd
0073
05ce
0065
05cf
0074
05d0
1406
    dat 5, "wset", built_in_win_set
data.dasm16
350
7
05d1
0006
05d2
0072
05d3
0061
05d4
006e
05d5
0067
05d6
0065
05d7
113d
    dat 6, "range", built_in_range
data.dasm16
351
7
05d8
0006
05d9
0066
05da
006c
05db
006f
05dc
0061
05dd
0074
05de
12ee
    dat 6, "float", built_in_float
data.dasm16
352
7
05df
0006
05e0
0069
05e1
006e
05e2
0070
05e3
0075
05e4
0074
05e5
1129
    dat 6, "input", built_in_input
data.dasm16
353
7
05e6
0006
05e7
0077
05e8
0072
05e9
0069
05ea
0074
05eb
0065
05ec
149c
    dat 6, "write", built_in_write
data.dasm16
354
8
05ed
0007
05ee
0063
05ef
0075
05f0
0072
05f1
0073
05f2
006f
05f3
0072
05f4
13ba
    dat 7, "cursor", built_in_cursor
data.dasm16
355
8
05f5
0007
05f6
0066
05f7
006f
05f8
0072
05f9
006d
05fa
0061
05fb
0074
05fc
127d
    dat 7, "format", built_in_format
data.dasm16
356
8
05fd
0007
05fe
006c
05ff
006f
0600
0063
0601
0061
0602
006c
0603
0073
0604
119c
    dat 7, "locals", built_in_locals
data.dasm16
357
8
0605
0007
0606
0073
0607
0063
0608
0072
0609
006f
060a
006c
060b
006c
060c
1521
    dat 7, "scroll", built_in_scroll
data.dasm16
358
9
060d
0008
060e
0067
060f
006c
0610
006f
0611
0062
0612
0061
0613
006c
0614
0073
0615
11a5
    dat 8, "globals", built_in_globals
data.dasm16
359
2
0616
0001
0617
0eff
    dat 1, led_lparen_user_defined
data.dasm16
360
0

data.dasm16
361
0
:built_in__list_methods
data.dasm16
362
8
0618
0007
0619
0061
061a
0070
061b
0070
061c
0065
061d
006e
061e
0064
061f
10ff
    dat 7, "append", built_in__list_append
data.dasm16
363
8
0620
0007
0621
0069
0622
006e
0623
0073
0624
0065
0625
0072
0626
0074
0627
110c
    dat 7, "insert", built_in__list_insert
data.dasm16
364
2
0628
0001
0629
0eff
    dat 1, led_lparen_user_defined
data.dasm16
365
0

data.dasm16
366
0
:built_in__dict_methods
data.dasm16
367
8
062a
0007
062b
0063
062c
0072
062d
0065
062e
0061
062f
0074
0630
0065
0631
10ea
    dat 7, "create", built_in__dict_create
data.dasm16
368
2
0632
0001
0633
0eff
    dat 1, led_lparen_user_defined
data.dasm16
369
0

data.dasm16
370
0
:built_in__str_methods
data.dasm16
371
9
0634
0008
0635
0064
0636
0065
0637
0063
0638
0072
0639
0079
063a
0070
063b
0074
063c
2ade
    dat 8, "decrypt", built_in__str_decrypt
data.dasm16
372
9
063d
0008
063e
0065
063f
006e
0640
0063
0641
0072
0642
0079
0643
0070
0644
0074
0645
2aec
    dat 8, "encrypt", built_in__str_encrypt
data.dasm16
373
7
0646
0006
0647
006c
0648
006f
0649
0077
064a
0065
064b
0072
064c
2a33
    dat 6, "lower", built_in__str_lower
data.dasm16
374
7
064d
0006
064e
0075
064f
0070
0650
0070
0651
0065
0652
0072
0653
2a4a
    dat 6, "upper", built_in__str_upper
data.dasm16
375
6
0654
0005
0655
0066
0656
0069
0657
006e
0658
0064
0659
2a5f
    dat 5, "find", built_in__str_find
data.dasm16
376
9
065a
0008
065b
0072
065c
0065
065d
0070
065e
006c
065f
0061
0660
0063
0661
0065
0662
2b22
    dat 8, "replace", built_in__str_replace
data.dasm16
377
7
0663
0006
0664
0073
0665
0070
0666
006c
0667
0069
0668
0074
0669
2b69
    dat 6, "split", built_in__str_split
data.dasm16
378
10
066a
0009
066b
0065
066c
006e
066d
0064
066e
0073
066f
0077
0670
0069
0671
0074
0672
0068
0673
2a9b
    dat 9, "endswith", built_in__str_endswith
data.dasm16
379
12
0674
000b
0675
0073
0676
0074
0677
0061
0678
0072
0679
0074
067a
0073
067b
0077
067c
0069
067d
0074
067e
0068
067f
2a9f
    dat 11, "startswith", built_in__str_startswith
data.dasm16
380
9
0680
0008
0681
0069
0682
0073
0683
0061
0684
006c
0685
0070
0686
0068
0687
0061
0688
2a03
    dat 8, "isalpha", built_in__str_isalpha
data.dasm16
381
9
0689
0008
068a
0069
068b
0073
068c
0064
068d
0069
068e
0067
068f
0069
0690
0074
0691
2a1e
    dat 8, "isdigit", built_in__str_isdigit
data.dasm16
382
2
0692
0001
0693
0eff
    dat 1, led_lparen_user_defined
data.dasm16
383
0

data.dasm16
384
0
;----------------------------------------------------------------
data.dasm16
385
0
; RESERVED WORDS
data.dasm16
386
0
; length+1, reserved word, token
data.dasm16
387
0
; last line is the default if nothing matches
data.dasm16
388
0
;----------------------------------------------------------------
data.dasm16
389
0
:built_in_stmts
data.dasm16
390
4
0694
0003
0695
0069
0696
0066
0697
0444
    dat 3, "if", token_if
data.dasm16
391
4
0698
0003
0699
006f
069a
0072
069b
04b0
    dat 3, "or", token_or
data.dasm16
392
4
069c
0003
069d
0069
069e
0073
069f
04c0
    dat 3, "is", token_is
data.dasm16
393
4
06a0
0003
06a1
0069
06a2
006e
06a3
04b8
    dat 3, "in", token_in
data.dasm16
394
5
06a4
0004
06a5
0063
06a6
006c
06a7
0073
06a8
0448
    dat 4, "cls", token_cls
data.dasm16
395
5
06a9
0004
06aa
0061
06ab
006e
06ac
0064
06ad
04b4
    dat 4, "and", token_and
data.dasm16
396
5
06ae
0004
06af
006e
06b0
006f
06b1
0074
06b2
04bc
    dat 4, "not", token_not
data.dasm16
397
5
06b3
0004
06b4
0064
06b5
0065
06b6
006c
06b7
044c
    dat 4, "del", token_del
data.dasm16
398
5
06b8
0004
06b9
0066
06ba
006f
06bb
0072
06bc
0450
    dat 4, "for", token_for
data.dasm16
399
5
06bd
0004
06be
0069
06bf
006e
06c0
0066
06c1
0428
    dat 4, "inf", token_float
data.dasm16
400
5
06c2
0004
06c3
006e
06c4
0061
06c5
006e
06c6
0428
    dat 4, "nan", token_float
data.dasm16
401
5
06c7
0004
06c8
0072
06c9
0075
06ca
006e
06cb
0454
    dat 4, "run", token_run
data.dasm16
402
6
06cc
0005
06cd
0074
06ce
0072
06cf
0075
06d0
0065
06d1
0438
    dat 5, "true", token_true
data.dasm16
403
6
06d2
0005
06d3
006e
06d4
006f
06d5
006e
06d6
0065
06d7
0434
    dat 5, "none", token_none
data.dasm16
404
6
06d8
0005
06d9
0065
06da
006c
06db
0069
06dc
0066
06dd
0458
    dat 5, "elif", token_elif
data.dasm16
405
6
06de
0005
06df
0065
06e0
006c
06e1
0073
06e2
0065
06e3
045c
    dat 5, "else", token_else
data.dasm16
406
6
06e4
0005
06e5
0070
06e6
0061
06e7
0073
06e8
0073
06e9
0460
    dat 5, "pass", token_pass
data.dasm16
407
7
06ea
0006
06eb
0066
06ec
0061
06ed
006c
06ee
0073
06ef
0065
06f0
043c
    dat 6, "false", token_false
data.dasm16
408
7
06f1
0006
06f2
0070
06f3
0072
06f4
0069
06f5
006e
06f6
0074
06f7
0464
    dat 6, "print", token_print
data.dasm16
409
7
06f8
0006
06f9
0077
06fa
0068
06fb
0069
06fc
006c
06fd
0065
06fe
0468
    dat 6, "while", token_while
data.dasm16
410
7
06ff
0006
0700
0072
0701
0065
0702
0073
0703
0065
0704
0074
0705
0470
    dat 6, "reset", token_reset
data.dasm16
411
7
0706
0006
0707
0062
0708
0072
0709
0065
070a
0061
070b
006b
070c
046c
    dat 6, "break", token_break
data.dasm16
412
8
070d
0007
070e
0072
070f
0065
0710
0074
0711
0075
0712
0072
0713
006e
0714
0474
    dat 7, "return", token_return
data.dasm16
413
10
0715
0009
0716
0063
0717
006f
0718
006e
0719
0074
071a
0069
071b
006e
071c
0075
071d
0065
071e
0478
    dat 9, "continue", token_continue
data.dasm16
414
2
071f
0001
0720
042c
    dat 1, token_name
data.dasm16
415
0

data.dasm16
416
0
;----------------------------------------------------------------
data.dasm16
417
0
; LEXER CHARACTER TABLE
data.dasm16
418
0
;----------------------------------------------------------------
data.dasm16
419
0
:lexer_table
data.dasm16
420
1
0721
1cdc
    DAT lexer_char_eof           ;  0 NUL (Null char.)
data.dasm16
421
1
0722
00c6
    DAT recover                  ;  1 SOH (Start of Header)
data.dasm16
422
1
0723
00c6
    DAT recover                  ;  2 STX (Start of Text)
data.dasm16
423
1
0724
00c6
    DAT recover                  ;  3 ETX (End of Text)
data.dasm16
424
1
0725
00c6
    DAT recover                  ;  4 EOT (End of Transmission)
data.dasm16
425
1
0726
00c6
    DAT recover                  ;  5 ENQ (Enquiry)
data.dasm16
426
1
0727
00c6
    DAT recover                  ;  6 ACK (Acknowledgment)
data.dasm16
427
1
0728
00c6
    DAT recover                  ;  7 BEL (Bell)
data.dasm16
428
1
0729
00c6
    DAT recover                  ;  8 BS (Backspace)
data.dasm16
429
1
072a
00c6
    DAT recover                  ;  9 HT (Horizontal Tab)
data.dasm16
430
1
072b
1bcc
    DAT lexer_char_newline       ; 10 LF (Line Feed)
data.dasm16
431
1
072c
00c6
    DAT recover                  ; 11 VT (Vertical Tab)
data.dasm16
432
1
072d
00c6
    DAT recover                  ; 12 FF (Form Feed)
data.dasm16
433
1
072e
00c6
    DAT recover                  ; 13 CR (Carriage Return)
data.dasm16
434
1
072f
00c6
    DAT recover                  ; 14 SO (Shift Out)
data.dasm16
435
1
0730
00c6
    DAT recover                  ; 15 SI (Shift In)
data.dasm16
436
1
0731
00c6
    DAT recover                  ; 16 DLE (Data Link Escape)
data.dasm16
437
1
0732
1bcc
    DAT lexer_char_newline       ; 17 DC1 (XON)(Device Control 1)
data.dasm16
438
1
0733
00c6
    DAT recover                  ; 18 DC2 (Device Control 2)
data.dasm16
439
1
0734
00c6
    DAT recover                  ; 19 DC3 (XOFF)(Device Control 3)
data.dasm16
440
1
0735
00c6
    DAT recover                  ; 20 DC4 (Device Control 4)
data.dasm16
441
1
0736
00c6
    DAT recover                  ; 21 NAK (Negative Acknowledgement)
data.dasm16
442
1
0737
00c6
    DAT recover                  ; 22 SYN (Synchronous Idle)
data.dasm16
443
1
0738
00c6
    DAT recover                  ; 23 ETB (End of Trans. Block)
data.dasm16
444
1
0739
00c6
    DAT recover                  ; 24 CAN (Cancel)
data.dasm16
445
1
073a
00c6
    DAT recover                  ; 25 EM (End of Medium)
data.dasm16
446
1
073b
00c6
    DAT recover                  ; 26 SUB (Substitute)
data.dasm16
447
1
073c
00c6
    DAT recover                  ; 27 ESC (Escape)
data.dasm16
448
1
073d
00c6
    DAT recover                  ; 28 FS (File Separator)
data.dasm16
449
1
073e
00c6
    DAT recover                  ; 29 GS (Group Separator)
data.dasm16
450
1
073f
00c6
    DAT recover                  ; 30 RS (Request to Send)(Record Separator)
data.dasm16
451
1
0740
00c6
    DAT recover                  ; 31 US (Unit Separator)
data.dasm16
452
1
0741
1dbe
    DAT lexer_char_whitespace    ; 32 SP (Space)
data.dasm16
453
1
0742
1cca
    DAT lexer_char_exclamation   ; 33 ! (exclamation mark)
data.dasm16
454
1
0743
1d47
    DAT lexer_char_quotationmark ; 34 " (double quote)
data.dasm16
455
1
0744
1db9
    DAT lexer_char_comment       ; 35 # (number sign)
data.dasm16
456
1
0745
1d26
    DAT lexer_char_letter        ; 36 $ (dollar sign)
data.dasm16
457
1
0746
1c78
    DAT lexer_char_percent       ; 37 % (percent)
data.dasm16
458
1
0747
1c6a
    DAT lexer_char_ambersand     ; 38 & (ampersand)
data.dasm16
459
1
0748
1d47
    DAT lexer_char_quotationmark ; 39 ' (single quote)
data.dasm16
460
1
0749
1c16
    DAT lexer_char_lparen        ; 40 ( (left opening parenthesis)
data.dasm16
461
1
074a
1c1b
    DAT lexer_char_rparen        ; 41 ) (right closing parenthesis)
data.dasm16
462
1
074b
1c42
    DAT lexer_char_star          ; 42 * (asterisk)
data.dasm16
463
1
074c
1c34
    DAT lexer_char_plus          ; 43 + (plus)
data.dasm16
464
1
074d
1c11
    DAT lexer_char_comma         ; 44 , (comma)
data.dasm16
465
1
074e
1c3b
    DAT lexer_char_minus         ; 45 - (minus or dash)
data.dasm16
466
1
074f
1bfa
    DAT lexer_char_dot           ; 46 . (dot)
data.dasm16
467
1
0750
1c71
    DAT lexer_char_slash         ; 47 / (forward slash)
data.dasm16
468
1
0751
1ce3
    DAT lexer_char_digit         ; 48 0 
data.dasm16
469
1
0752
1ce3
    DAT lexer_char_digit         ; 49 1 
data.dasm16
470
1
0753
1ce3
    DAT lexer_char_digit         ; 50 2 
data.dasm16
471
1
0754
1ce3
    DAT lexer_char_digit         ; 51 3 
data.dasm16
472
1
0755
1ce3
    DAT lexer_char_digit         ; 52 4 
data.dasm16
473
1
0756
1ce3
    DAT lexer_char_digit         ; 53 5 
data.dasm16
474
1
0757
1ce3
    DAT lexer_char_digit         ; 54 6 
data.dasm16
475
1
0758
1ce3
    DAT lexer_char_digit         ; 55 7 
data.dasm16
476
1
0759
1ce3
    DAT lexer_char_digit         ; 56 8 
data.dasm16
477
1
075a
1ce3
    DAT lexer_char_digit         ; 57 9 
data.dasm16
478
1
075b
1c0c
    DAT lexer_char_colon         ; 58 : (colon)
data.dasm16
479
1
075c
00c6
    DAT recover                  ; 59 ; (semi-colon)
data.dasm16
480
1
075d
1c86
    DAT lexer_char_less          ; 60 < (less than sign)
data.dasm16
481
1
075e
1c7f
    DAT lexer_char_equal         ; 61 = (equal sign)
data.dasm16
482
1
075f
1ca8
    DAT lexer_char_greater       ; 62 > (greater than sign)
data.dasm16
483
1
0760
00c6
    DAT recover                  ; 63 ? (question mark)
data.dasm16
484
1
0761
00c6
    DAT recover                  ; 64 @ (AT symbol)
data.dasm16
485
1
0762
1d26
    DAT lexer_char_letter        ; 65 A 
data.dasm16
486
1
0763
1d26
    DAT lexer_char_letter        ; 66 B 
data.dasm16
487
1
0764
1d26
    DAT lexer_char_letter        ; 67 C 
data.dasm16
488
1
0765
1d26
    DAT lexer_char_letter        ; 68 D 
data.dasm16
489
1
0766
1d26
    DAT lexer_char_letter        ; 69 E 
data.dasm16
490
1
0767
1d26
    DAT lexer_char_letter        ; 70 F 
data.dasm16
491
1
0768
1d26
    DAT lexer_char_letter        ; 71 G 
data.dasm16
492
1
0769
1d26
    DAT lexer_char_letter        ; 72 H 
data.dasm16
493
1
076a
1d26
    DAT lexer_char_letter        ; 73 I 
data.dasm16
494
1
076b
1d26
    DAT lexer_char_letter        ; 74 J 
data.dasm16
495
1
076c
1d26
    DAT lexer_char_letter        ; 75 K 
data.dasm16
496
1
076d
1d26
    DAT lexer_char_letter        ; 76 L 
data.dasm16
497
1
076e
1d26
    DAT lexer_char_letter        ; 77 M 
data.dasm16
498
1
076f
1d26
    DAT lexer_char_letter        ; 78 N 
data.dasm16
499
1
0770
1d26
    DAT lexer_char_letter        ; 79 O 
data.dasm16
500
1
0771
1d26
    DAT lexer_char_letter        ; 80 P 
data.dasm16
501
1
0772
1d26
    DAT lexer_char_letter        ; 81 Q 
data.dasm16
502
1
0773
1d26
    DAT lexer_char_letter        ; 82 R 
data.dasm16
503
1
0774
1d26
    DAT lexer_char_letter        ; 83 S 
data.dasm16
504
1
0775
1d26
    DAT lexer_char_letter        ; 84 T 
data.dasm16
505
1
0776
1d26
    DAT lexer_char_letter        ; 85 U 
data.dasm16
506
1
0777
1d26
    DAT lexer_char_letter        ; 86 V 
data.dasm16
507
1
0778
1d26
    DAT lexer_char_letter        ; 87 W 
data.dasm16
508
1
0779
1d26
    DAT lexer_char_letter        ; 88 X 
data.dasm16
509
1
077a
1d26
    DAT lexer_char_letter        ; 89 Y 
data.dasm16
510
1
077b
1d26
    DAT lexer_char_letter        ; 90 Z 
data.dasm16
511
1
077c
1c2a
    DAT lexer_char_lbrack        ; 91 [ (left opening bracket)
data.dasm16
512
1
077d
00c6
    DAT recover                  ; 92 \ (back slash)
data.dasm16
513
1
077e
1c2f
    DAT lexer_char_rbrack        ; 93 ] (right closing bracket)
data.dasm16
514
1
077f
1c5c
    DAT lexer_char_caret         ; 94 ^ (caret cirumflex)
data.dasm16
515
1
0780
1d26
    DAT lexer_char_letter        ; 95 _ (underscore)
data.dasm16
516
1
0781
00c6
    DAT recover                  ; 96 ` 
data.dasm16
517
1
0782
1d26
    DAT lexer_char_letter        ; 97 a 
data.dasm16
518
1
0783
1d26
    DAT lexer_char_letter        ; 98 b 
data.dasm16
519
1
0784
1d26
    DAT lexer_char_letter        ; 99 c 
data.dasm16
520
1
0785
1d26
    DAT lexer_char_letter        ; 100 d 
data.dasm16
521
1
0786
1d26
    DAT lexer_char_letter        ; 101 e 
data.dasm16
522
1
0787
1d26
    DAT lexer_char_letter        ; 102 f 
data.dasm16
523
1
0788
1d26
    DAT lexer_char_letter        ; 103 g 
data.dasm16
524
1
0789
1d26
    DAT lexer_char_letter        ; 104 h 
data.dasm16
525
1
078a
1d26
    DAT lexer_char_letter        ; 105 i 
data.dasm16
526
1
078b
1d26
    DAT lexer_char_letter        ; 106 j 
data.dasm16
527
1
078c
1d26
    DAT lexer_char_letter        ; 107 k 
data.dasm16
528
1
078d
1d26
    DAT lexer_char_letter        ; 108 l 
data.dasm16
529
1
078e
1d26
    DAT lexer_char_letter        ; 109 m 
data.dasm16
530
1
078f
1d26
    DAT lexer_char_letter        ; 110 n 
data.dasm16
531
1
0790
1d26
    DAT lexer_char_letter        ; 111 o 
data.dasm16
532
1
0791
1d26
    DAT lexer_char_letter        ; 112 p 
data.dasm16
533
1
0792
1d26
    DAT lexer_char_letter        ; 113 q 
data.dasm16
534
1
0793
1d26
    DAT lexer_char_letter        ; 114 r 
data.dasm16
535
1
0794
1d26
    DAT lexer_char_letter        ; 115 s 
data.dasm16
536
1
0795
1d26
    DAT lexer_char_letter        ; 116 t 
data.dasm16
537
1
0796
1d26
    DAT lexer_char_letter        ; 117 u 
data.dasm16
538
1
0797
1d26
    DAT lexer_char_letter        ; 118 v 
data.dasm16
539
1
0798
1d26
    DAT lexer_char_letter        ; 119 w 
data.dasm16
540
1
0799
1d26
    DAT lexer_char_letter        ; 120 x 
data.dasm16
541
1
079a
1d26
    DAT lexer_char_letter        ; 121 y 
data.dasm16
542
1
079b
1d26
    DAT lexer_char_letter        ; 122 z 
data.dasm16
543
1
079c
1c20
    DAT lexer_char_lcurly        ; 123 { (left opening brace)
data.dasm16
544
1
079d
1c63
    DAT lexer_char_vbar          ; 124 | (vertical bar)
data.dasm16
545
1
079e
1c25
    DAT lexer_char_rcurly        ; 125 } (right closing brace)
data.dasm16
546
1
079f
1c07
    DAT lexer_char_tilde         ; 126 ~ (tilde)
data.dasm16
547
1
07a0
00c6
    DAT recover                  ; 127 DEL (delete)
data.dasm16
548
0

data.dasm16
549
0
;----------------------------------------------------------------
data.dasm16
550
0

data.dasm16
551
0

parser.dasm16
0
0
;----------------------------------------------------------------
parser.dasm16
1
0
:parser_stmt
parser.dasm16
2
0
; main method to parse anything
parser.dasm16
3
0
;----------------------------------------------------------------
parser.dasm16
4
1
07a1
8701
    set push, 0
parser.dasm16
5
1
07a2
9701
    set push, 4
parser.dasm16
6
2
07a3
7c20
07a4
2039
    jsr preamble
parser.dasm16
7
0

parser.dasm16
8
2
07a5
7881
07a6
025c
    set y, [lexer_token]
parser.dasm16
9
1
07a7
3381
    set pc, [y + PROTOTYPE_STD]
parser.dasm16
10
0

parser.dasm16
11
0
;----------------------------------------------------------------
parser.dasm16
12
0
:parser_simple_stmt
parser.dasm16
13
0
; e.g. print hi is simple stmt
parser.dasm16
14
0
;   if true: print "Hi"
parser.dasm16
15
0
;----------------------------------------------------------------
parser.dasm16
16
1
07a8
8701
    set push, 0
parser.dasm16
17
1
07a9
9701
    set push, 4
parser.dasm16
18
2
07aa
7c20
07ab
2039
    jsr preamble
parser.dasm16
19
0

parser.dasm16
20
0
    ; compound stmts are not allowed here
parser.dasm16
21
0
    ;   if true: if true: print "Hi"
parser.dasm16
22
0
    ; that would make parsing more complex
parser.dasm16
23
2
07ac
7841
07ad
025c
    set c, [lexer_token]
parser.dasm16
24
2
07ae
7c52
07af
0468
    ife c, token_while
parser.dasm16
25
2
07b0
7c20
07b1
00c6
        jsr recover
parser.dasm16
26
2
07b2
7c52
07b3
0444
    ife c, token_if
parser.dasm16
27
2
07b4
7c20
07b5
00c6
        jsr recover
parser.dasm16
28
2
07b6
7c52
07b7
0450
    ife c, token_for
parser.dasm16
29
2
07b8
7c20
07b9
00c6
        jsr recover
parser.dasm16
30
0

parser.dasm16
31
2
07ba
7881
07bb
025c
    set y, [lexer_token]
parser.dasm16
32
1
07bc
3381
    set pc, [y + PROTOTYPE_STD]
parser.dasm16
33
0

parser.dasm16
34
0
;----------------------------------------------------------------
parser.dasm16
35
0
:std_newline
parser.dasm16
36
0
; return struct handle *none
parser.dasm16
37
0
;----------------------------------------------------------------
parser.dasm16
38
2
07bd
7c20
07be
1ba6
    jsr lexer_next
parser.dasm16
39
0

parser.dasm16
40
0
;----------------------------------------------------------------
parser.dasm16
41
0
:std_eof
parser.dasm16
42
0
; return struct handle *none
parser.dasm16
43
0
;----------------------------------------------------------------
parser.dasm16
44
2
07bf
7c61
07c0
029d
    set x, VOID
parser.dasm16
45
2
07c1
7f81
07c2
2026
    set pc, postamble
parser.dasm16
46
0

parser.dasm16
47
0
;----------------------------------------------------------------
parser.dasm16
48
0
:std_indent
parser.dasm16
49
0
:std_dedent
parser.dasm16
50
0
; These should never occur outside compund statements
parser.dasm16
51
0
;----------------------------------------------------------------
parser.dasm16
52
2
07c3
7c20
07c4
00c6
    jsr recover
parser.dasm16
53
0

parser.dasm16
54
0
;----------------------------------------------------------------
parser.dasm16
55
0
:std_cls
parser.dasm16
56
0
; clear lem
parser.dasm16
57
0
; return struct handle *none
parser.dasm16
58
0
;----------------------------------------------------------------
parser.dasm16
59
2
07c5
7c20
07c6
1ba6
    jsr lexer_next        ; skip 'cls'
parser.dasm16
60
0

parser.dasm16
61
2
07c7
7c20
07c8
2ee2
    jsr screen_clear
parser.dasm16
62
0

parser.dasm16
63
2
07c9
7c61
07ca
029d
    set x, VOID
parser.dasm16
64
2
07cb
7f81
07cc
2026
    set pc, postamble
parser.dasm16
65
0

parser.dasm16
66
0
;----------------------------------------------------------------
parser.dasm16
67
0
:std_reset
parser.dasm16
68
0
; restart admiral "sys 64738"
parser.dasm16
69
0
;----------------------------------------------------------------
parser.dasm16
70
2
07cd
7c20
07ce
2ee2
    jsr screen_clear
parser.dasm16
71
1
07cf
8761
    set sp, 0
parser.dasm16
72
1
07d0
84a1
    set z, 0
parser.dasm16
73
1
07d1
8781
    set pc, interpreter_main
parser.dasm16
74
0

parser.dasm16
75
0
;----------------------------------------------------------------
parser.dasm16
76
0
:std_run
parser.dasm16
77
0
;----------------------------------------------------------------
parser.dasm16
78
2
07d2
7c20
07d3
1ba6
    jsr lexer_next        ; skip 'run'
parser.dasm16
79
0

parser.dasm16
80
0
    ; run autoexec if there is no arguments
parser.dasm16
81
3
07d4
7fd2
07d5
0414
07d6
025c
    ife [lexer_token], token_newline
parser.dasm16
82
2
07d7
7f81
07d8
07ee
        set pc, std_run_autoexec
parser.dasm16
83
3
07d9
7fd2
07da
0410
07db
025c
    ife [lexer_token], token_eof
parser.dasm16
84
2
07dc
7f81
07dd
07ee
        set pc, std_run_autoexec
parser.dasm16
85
0

parser.dasm16
86
0
    ; filename is the 1st argument
parser.dasm16
87
1
07de
8701
    set push, 0
parser.dasm16
88
2
07df
7c20
07e0
0ab4
    jsr expression
parser.dasm16
89
2
07e1
0ea1
07e2
ffff
    set [z-1], x
parser.dasm16
90
0
    
parser.dasm16
91
1
07e3
0f01
    set push, x
parser.dasm16
92
2
07e4
7c20
07e5
1dfc
    jsr eval
parser.dasm16
93
2
07e6
0ea1
07e7
ffff
    set [z-1], x
parser.dasm16
94
0
    
parser.dasm16
95
0
    ; filename is required to be str
parser.dasm16
96
2
07e8
a671
07e9
0001
    ifc [x + HANDLE_TYPE], TYPE_STR
parser.dasm16
97
2
07ea
7c20
07eb
00c6
        jsr recover
parser.dasm16
98
0

parser.dasm16
99
2
07ec
7f81
07ed
07f1
    set pc, std_run_load
parser.dasm16
100
0

parser.dasm16
101
0
:std_run_autoexec
parser.dasm16
102
0
    ; use default filename
parser.dasm16
103
3
07ee
7ea1
07ef
03c0
07f0
ffff
    set [z-1], STR_AUTOEXEC
parser.dasm16
104
0

parser.dasm16
105
0
:std_run_load
parser.dasm16
106
0
    ; load file
parser.dasm16
107
2
07f1
5701
07f2
ffff
    set push, [z-1]
parser.dasm16
108
2
07f3
7c20
07f4
3094
    jsr floppy__file__read
parser.dasm16
109
2
07f5
0ea1
07f6
ffff
    set [z-1], x
parser.dasm16
110
0

parser.dasm16
111
0
    ; if it was not str or dict -> error
parser.dasm16
112
2
07f7
aa71
07f8
0001
    ifc [x + HANDLE_TYPE], TYPE_GROUP_RUNNABLE
parser.dasm16
113
2
07f9
7c20
07fa
00c6
        jsr recover
parser.dasm16
114
0

parser.dasm16
115
0
    ; function scope
parser.dasm16
116
1
07fb
af01
    set push, 10
parser.dasm16
117
1
07fc
8b01
    set push, TYPE_DICT
parser.dasm16
118
2
07fd
7c20
07fe
21d3
    jsr alloc
parser.dasm16
119
2
07ff
0ea1
0800
fffe
    set [z-2], x
parser.dasm16
120
0

parser.dasm16
121
0
    ; add global scope to function scope
parser.dasm16
122
1
0801
0f01
    set push, x
parser.dasm16
123
2
0802
7f01
0803
03d6
    set push, STR_EX
parser.dasm16
124
2
0804
7b01
0805
0235
    set push, [global_scope]
parser.dasm16
125
2
0806
7c20
0807
2f54
    jsr dict__set
parser.dasm16
126
0

parser.dasm16
127
0
    ; create tuple for arguments
parser.dasm16
128
1
0808
9b01
    set push, 5
parser.dasm16
129
1
0809
9701
    set push, TYPE_TUPLE
parser.dasm16
130
2
080a
7c20
080b
21d3
    jsr alloc
parser.dasm16
131
2
080c
0ea1
080d
fffc
    set [z-4], x
parser.dasm16
132
0

parser.dasm16
133
0
    ; add argument tuple to function scope
parser.dasm16
134
2
080e
5701
080f
fffe
    set push, [z-2]
parser.dasm16
135
2
0810
7f01
0811
03e0
    set push, STR_ARGV
parser.dasm16
136
1
0812
0f01
    set push, x
parser.dasm16
137
2
0813
7c20
0814
2f54
    jsr dict__set
parser.dasm16
138
0

parser.dasm16
139
0
    ; add 'me' if loaded object was dict
parser.dasm16
140
2
0815
5461
0816
ffff
    set x, [z-1]
parser.dasm16
141
2
0817
a672
0818
0001
    ife [x + HANDLE_TYPE], TYPE_STR
parser.dasm16
142
2
0819
7f81
081a
0822
        set pc, std_run_args
parser.dasm16
143
0

parser.dasm16
144
0
    ; add 'me' to function scope
parser.dasm16
145
2
081b
5701
081c
fffe
    set push, [z-2]
parser.dasm16
146
2
081d
7f01
081e
03db
    set push, STR_ME
parser.dasm16
147
1
081f
0f01
    set push, x
parser.dasm16
148
2
0820
7c20
0821
2f54
    jsr dict__set
parser.dasm16
149
0

parser.dasm16
150
0
:std_run_args
parser.dasm16
151
0
    ; exit arg-loop if end of line
parser.dasm16
152
3
0822
7fd2
0823
0414
0824
025c
    ife [lexer_token], token_newline
parser.dasm16
153
2
0825
7f81
0826
083e
        set pc, std_run_prepare
parser.dasm16
154
3
0827
7fd2
0828
0410
0829
025c
    ife [lexer_token], token_eof
parser.dasm16
155
2
082a
7f81
082b
083e
        set pc, std_run_prepare
parser.dasm16
156
0

parser.dasm16
157
0
    ; parse next argument
parser.dasm16
158
1
082c
8701
    set push, 0
parser.dasm16
159
2
082d
7c20
082e
0ab4
    jsr expression
parser.dasm16
160
2
082f
0ea1
0830
fffd
    set [z-3], x
parser.dasm16
161
0

parser.dasm16
162
0
    ; evaluate argument
parser.dasm16
163
1
0831
0f01
    set push, x
parser.dasm16
164
2
0832
7c20
0833
1dfc
    jsr eval
parser.dasm16
165
2
0834
0ea1
0835
fffd
    set [z-3], x
parser.dasm16
166
0

parser.dasm16
167
2
0836
5701
0837
fffc
    set push, [z-4]
parser.dasm16
168
2
0838
5701
0839
fffd
    set push, [z-3]
parser.dasm16
169
2
083a
7c20
083b
27d8
    jsr array__append
parser.dasm16
170
0

parser.dasm16
171
2
083c
7f81
083d
0822
    set pc, std_run_args
parser.dasm16
172
0

parser.dasm16
173
0
:std_run_prepare
parser.dasm16
174
2
083e
7b01
083f
0236
    set push, [current_scope]
parser.dasm16
175
3
0840
57c1
0841
fffe
0842
0236
    set [current_scope], [z-2]
parser.dasm16
176
0

parser.dasm16
177
2
0843
7c20
0844
1b44
    jsr lexer_store
parser.dasm16
178
0

parser.dasm16
179
2
0845
5461
0846
ffff
    set x, [z-1]
parser.dasm16
180
2
0847
a672
0848
0001
    ife [x + HANDLE_TYPE], TYPE_STR
parser.dasm16
181
2
0849
7f81
084a
0858
        set pc, std_run_init_lexer
parser.dasm16
182
0

parser.dasm16
183
2
084b
5701
084c
ffff
    set push, [z-1]
parser.dasm16
184
2
084d
7f01
084e
03cb
    set push, STR_MAIN
parser.dasm16
185
2
084f
7c20
0850
2f2e
    jsr dict_get
parser.dasm16
186
0

parser.dasm16
187
1
0851
8472
    ife x, 0
parser.dasm16
188
2
0852
7c20
0853
00c6
        jsr recover
parser.dasm16
189
0

parser.dasm16
190
2
0854
a673
0855
0001
    ifn [x + HANDLE_TYPE], TYPE_STR
parser.dasm16
191
2
0856
7c20
0857
00c6
        jsr recover
parser.dasm16
192
0

parser.dasm16
193
0
:std_run_init_lexer
parser.dasm16
194
2
0858
7c20
0859
1b35
    jsr lexer_init
parser.dasm16
195
0

parser.dasm16
196
0
:std_run_call
parser.dasm16
197
2
085a
7c20
085b
07a1
    jsr parser_stmt
parser.dasm16
198
2
085c
0ea1
085d
fffd
    set [z-3], x
parser.dasm16
199
0

parser.dasm16
200
3
085e
7e72
085f
2000
0860
0001
    ife [x+HANDLE_TYPE], TYPE_CONTROL
parser.dasm16
201
2
0861
7f81
0862
0872
        set pc, std_run_control
parser.dasm16
202
0

parser.dasm16
203
3
0863
7fd3
0864
0410
0865
025c
    ifn [lexer_token], token_eof
parser.dasm16
204
2
0866
7f81
0867
085a
        set pc, std_run_call
parser.dasm16
205
0

parser.dasm16
206
2
0868
7c01
0869
029d
    set a, VOID
parser.dasm16
207
0

parser.dasm16
208
0
:std_run_finish
parser.dasm16
209
2
086a
7c20
086b
1b52
    jsr lexer_restore
parser.dasm16
210
3
086c
6bc1
086d
0006
086e
0236
    set [current_scope], [sp+6]
parser.dasm16
211
1
086f
0061
    set x, a
parser.dasm16
212
2
0870
7f81
0871
2026
    set pc, postamble
parser.dasm16
213
0

parser.dasm16
214
0
:std_run_control
parser.dasm16
215
1
0872
2c01
    set a, [x]
parser.dasm16
216
3
0873
7e13
0874
0474
0875
0001
    ifn [a + CONTROL_SIGNAL], token_return
parser.dasm16
217
2
0876
7c20
0877
00c6
        jsr recover            ; break and continue
parser.dasm16
218
0

parser.dasm16
219
2
0878
4301
0879
0002
    set push, [a + CONTROL_VALUE]
parser.dasm16
220
2
087a
7c20
087b
1dfc
    jsr eval
parser.dasm16
221
1
087c
0c01
    set a, x
parser.dasm16
222
0
    
parser.dasm16
223
2
087d
7f81
087e
086a
    set pc, std_run_finish
parser.dasm16
224
0

parser.dasm16
225
0

parser.dasm16
226
0
;----------------------------------------------------------------
parser.dasm16
227
0
:std_print    
parser.dasm16
228
0
; return struct handle *none
parser.dasm16
229
0
;----------------------------------------------------------------
parser.dasm16
230
2
087f
7c20
0880
1ba6
    jsr lexer_next        ; skip 'print'
parser.dasm16
231
0

parser.dasm16
232
0
:std_print_loop
parser.dasm16
233
3
0881
7fd2
0882
0414
0883
025c
    ife [lexer_token], token_newline
parser.dasm16
234
2
0884
7f81
0885
08b7
        set pc, std_print_break_newline
parser.dasm16
235
3
0886
7fd2
0887
0410
0888
025c
    ife [lexer_token], token_eof
parser.dasm16
236
2
0889
7f81
088a
08bb
        set pc, std_print_break_eof
parser.dasm16
237
0

parser.dasm16
238
1
088b
8701
    set push, 0
parser.dasm16
239
2
088c
7c20
088d
0ab4
    jsr expression
parser.dasm16
240
2
088e
0ea1
088f
ffff
    set [z-1], x
parser.dasm16
241
0

parser.dasm16
242
3
0890
7e72
0891
0100
0892
0001
    ife [x + HANDLE_TYPE], TYPE_TUPLE_COMMA
parser.dasm16
243
2
0893
7f81
0894
089f
        set pc, std_print_array
parser.dasm16
244
0
        
parser.dasm16
245
1
0895
0f01
    set push, x
parser.dasm16
246
2
0896
7c20
0897
1dfc
    jsr eval
parser.dasm16
247
2
0898
0ea1
0899
ffff
    set [z-1], x
parser.dasm16
248
0

parser.dasm16
249
1
089a
0f01
    set push, x
parser.dasm16
250
2
089b
7c20
089c
2050
    jsr print
parser.dasm16
251
0
    
parser.dasm16
252
2
089d
7f81
089e
0881
    set pc, std_print_loop
parser.dasm16
253
0

parser.dasm16
254
0
:std_print_array
parser.dasm16
255
1
089f
0f01
    set push, x
parser.dasm16
256
2
08a0
7c20
08a1
1dfc
    jsr eval
parser.dasm16
257
2
08a2
0ea1
08a3
ffff
    set [z-1], x
parser.dasm16
258
0

parser.dasm16
259
1
08a4
0f01
    set push, x
parser.dasm16
260
0

parser.dasm16
261
2
08a5
7f01
08a6
08ab
    set push, std_print_iterator
parser.dasm16
262
2
08a7
7c20
08a8
28e4
    jsr array_map
parser.dasm16
263
0

parser.dasm16
264
2
08a9
7f81
08aa
0881
    set pc, std_print_loop
parser.dasm16
265
0

parser.dasm16
266
0
:std_print_iterator
parser.dasm16
267
1
08ab
0b01
    set push, c
parser.dasm16
268
2
08ac
6b01
08ad
0002
    set push, [sp+2]
parser.dasm16
269
2
08ae
7c20
08af
2050
    jsr print
parser.dasm16
270
0

parser.dasm16
271
2
08b0
7c41
08b1
0020
    set c, ' '
parser.dasm16
272
2
08b2
7c20
08b3
2ef4
    jsr screen_add_char
parser.dasm16
273
0

parser.dasm16
274
1
08b4
6041
    set c, pop
parser.dasm16
275
1
08b5
6321
    set [sp], pop
parser.dasm16
276
1
08b6
6381
    set pc, pop
parser.dasm16
277
0

parser.dasm16
278
0
:std_print_break_newline
parser.dasm16
279
2
08b7
7f01
08b8
0414
    set push, token_newline
parser.dasm16
280
2
08b9
7c20
08ba
1b9d
    jsr lexer_advance
parser.dasm16
281
0

parser.dasm16
282
0
:std_print_break_eof
parser.dasm16
283
1
08bb
ac41
    set c, 10
parser.dasm16
284
2
08bc
7c20
08bd
2ef4
    jsr screen_add_char
parser.dasm16
285
0

parser.dasm16
286
2
08be
7c61
08bf
029d
    set x, VOID
parser.dasm16
287
2
08c0
7f81
08c1
2026
    set pc, postamble
parser.dasm16
288
0

parser.dasm16
289
0
;----------------------------------------------------------------
parser.dasm16
290
0
:std_return
parser.dasm16
291
0
; return struct handle *control
parser.dasm16
292
0
;----------------------------------------------------------------
parser.dasm16
293
2
08c2
7c20
08c3
1ba6
    jsr lexer_next        ; skip return
parser.dasm16
294
0

parser.dasm16
295
1
08c4
9301
    set push, SIZEOF_CONTROL                ; create struct control
parser.dasm16
296
2
08c5
7f01
08c6
2000
    set push, TYPE_CONTROL
parser.dasm16
297
2
08c7
7c20
08c8
2770
    jsr array_create
parser.dasm16
298
2
08c9
0ea1
08ca
ffff
    set [z-1], x
parser.dasm16
299
0

parser.dasm16
300
1
08cb
2c01
    set a, [x]
parser.dasm16
301
3
08cc
7e01
08cd
0474
08ce
0001
    set [a + CONTROL_SIGNAL], token_return        ; set control type
parser.dasm16
302
3
08cf
7e01
08d0
029b
08d1
0002
    set [a + CONTROL_VALUE], NONE            ; default: no return value
parser.dasm16
303
0

parser.dasm16
304
3
08d2
7fd2
08d3
0414
08d4
025c
    ife [lexer_token], token_newline
parser.dasm16
305
2
08d5
7f81
08d6
08e4
        set pc, std_return_finish
parser.dasm16
306
3
08d7
7fd2
08d8
0410
08d9
025c
    ife [lexer_token], token_eof
parser.dasm16
307
2
08da
7f81
08db
08e4
        set pc, std_return_finish
parser.dasm16
308
0
    
parser.dasm16
309
1
08dc
8701
    set push, 0
parser.dasm16
310
2
08dd
7c20
08de
0ab4
    jsr expression
parser.dasm16
311
0

parser.dasm16
312
2
08df
5401
08e0
ffff
    set a, [z-1]
parser.dasm16
313
1
08e1
2001
    set a, [a]
parser.dasm16
314
2
08e2
0e01
08e3
0002
    set [a + CONTROL_VALUE], x
parser.dasm16
315
0

parser.dasm16
316
0
:std_return_finish
parser.dasm16
317
0
    ; keeping lexer up to date is not needed after return
parser.dasm16
318
0
    ; set push, token_newline
parser.dasm16
319
0
    ; jsr lexer_advance
parser.dasm16
320
0

parser.dasm16
321
2
08e4
5461
08e5
ffff
    set x, [z-1]
parser.dasm16
322
2
08e6
7f81
08e7
2026
    set pc, postamble
parser.dasm16
323
0
    
parser.dasm16
324
0
;----------------------------------------------------------------
parser.dasm16
325
0
:std_break
parser.dasm16
326
0
:std_continue
parser.dasm16
327
0
; return struct handle *control
parser.dasm16
328
0
;----------------------------------------------------------------
parser.dasm16
329
2
08e8
7821
08e9
025c
    set b, [lexer_token]            ; store token for control signal
parser.dasm16
330
0

parser.dasm16
331
2
08ea
7c20
08eb
1ba6
    jsr lexer_next                    ; advance 'break' or 'continue'
parser.dasm16
332
0

parser.dasm16
333
3
08ec
7fd3
08ed
0414
08ee
025c
    ifn [lexer_token], token_newline
parser.dasm16
334
3
08ef
7fd3
08f0
0410
08f1
025c
        ifn [lexer_token], token_eof
parser.dasm16
335
2
08f2
7c20
08f3
00c6
            jsr recover
parser.dasm16
336
0

parser.dasm16
337
2
08f4
7c20
08f5
1ba6
    jsr lexer_next                    ; advance newline or eof
parser.dasm16
338
0

parser.dasm16
339
1
08f6
9301
    set push, SIZEOF_CONTROL        ; create struct control
parser.dasm16
340
2
08f7
7f01
08f8
2000
    set push, TYPE_CONTROL
parser.dasm16
341
2
08f9
7c20
08fa
2770
    jsr array_create
parser.dasm16
342
0

parser.dasm16
343
1
08fb
2c01
    set a, [x]
parser.dasm16
344
2
08fc
0601
08fd
0001
    set [a + CONTROL_SIGNAL], b     ; set control signal
parser.dasm16
345
3
08fe
7e01
08ff
029d
0900
0002
    set [a + CONTROL_VALUE], VOID    ; default: no return value
parser.dasm16
346
2
0901
7f81
0902
2026
    set pc, postamble
parser.dasm16
347
0

parser.dasm16
348
0
;----------------------------------------------------------------
parser.dasm16
349
0
:std_pass
parser.dasm16
350
0
; return struct handle *none
parser.dasm16
351
0
;----------------------------------------------------------------
parser.dasm16
352
2
0903
7c20
0904
1ba6
    jsr lexer_next
parser.dasm16
353
0

parser.dasm16
354
3
0905
7fd3
0906
0414
0907
025c
    ifn [lexer_token], token_newline
parser.dasm16
355
3
0908
7fd3
0909
0410
090a
025c
        ifn [lexer_token], token_eof
parser.dasm16
356
2
090b
7c20
090c
00c6
            jsr recover
parser.dasm16
357
0

parser.dasm16
358
2
090d
7c61
090e
029d
    set x, VOID
parser.dasm16
359
2
090f
7f81
0910
2026
        set pc, postamble
parser.dasm16
360
0

parser.dasm16
361
0
;----------------------------------------------------------------
parser.dasm16
362
0
:std_for
parser.dasm16
363
0
; for x in list:
parser.dasm16
364
0
;  print x
parser.dasm16
365
0
; return VOID
parser.dasm16
366
0
; TODO 'else'
parser.dasm16
367
0
; Comments:
parser.dasm16
368
0
; Python grammar uses valid operator 'in' as for loop
parser.dasm16
369
0
; separator. there is no way for parser to detect between expression 
parser.dasm16
370
0
; operator and for separator.
parser.dasm16
371
0
;----------------------------------------------------------------
parser.dasm16
372
2
0911
7c20
0912
1ba6
    jsr lexer_next                ; advance 'for'
parser.dasm16
373
2
0913
7c20
0914
09f4
    jsr parser_fork_scope
parser.dasm16
374
0

parser.dasm16
375
0
    ; get the testlist (left side)
parser.dasm16
376
1
0915
8701
    set push, 0x0000
parser.dasm16
377
2
0916
7c20
0917
0ad6
    jsr testlist
parser.dasm16
378
2
0918
0ea1
0919
fffd
    set [z-3], x
parser.dasm16
379
0

parser.dasm16
380
2
091a
7f01
091b
04b8
    set push, token_in    ; verify 'in'
parser.dasm16
381
2
091c
7c20
091d
1b9d
    jsr lexer_advance
parser.dasm16
382
0
    
parser.dasm16
383
0
    ; get the exprlist (right side)
parser.dasm16
384
1
091e
8701
    set push, 0x0000
parser.dasm16
385
2
091f
7c20
0920
0ab4
    jsr expression
parser.dasm16
386
2
0921
0ea1
0922
fffc
    set [z-4], x
parser.dasm16
387
0

parser.dasm16
388
1
0923
0f01
    set push, x
parser.dasm16
389
2
0924
7c20
0925
1dfc
    jsr eval
parser.dasm16
390
2
0926
0ea1
0927
fffc
    set [z-4], x
parser.dasm16
391
0

parser.dasm16
392
2
0928
7f01
0929
04ac
    set push, token_colon        ; verify colon
parser.dasm16
393
2
092a
7c20
092b
1b9d
    jsr lexer_advance
parser.dasm16
394
0
    
parser.dasm16
395
2
092c
7c20
092d
1b44
    jsr lexer_store                ; store lexer position
parser.dasm16
396
0

parser.dasm16
397
1
092e
84c1
    set i, 0
parser.dasm16
398
0
    
parser.dasm16
399
0
:std_for_loop
parser.dasm16
400
2
092f
5401
0930
fffd
    set a, [z-3]   ; struct handle *left
parser.dasm16
401
2
0931
5421
0932
fffc
    set b, [z-4]   ; struct handle *right
parser.dasm16
402
0

parser.dasm16
403
1
0933
2441
    set c, [b]        ; struct data *right
parser.dasm16
404
1
0934
28d2
    ife i, [c]        ; i == rightLen -> done
parser.dasm16
405
2
0935
7f81
0936
0971
        set pc, std_for_finish
parser.dasm16
406
0

parser.dasm16
407
1
0937
1842
    add c, i        ; c+1 = points to current item
parser.dasm16
408
2
0938
a632
0939
0001
    ife [b + HANDLE_TYPE], TYPE_STR
parser.dasm16
409
2
093a
7f81
093b
094c
        set pc, std_for_loop_string
parser.dasm16
410
0
        
parser.dasm16
411
1
093c
0301
    set push, a
parser.dasm16
412
2
093d
4b01
093e
0001
    set push, [c+1]
parser.dasm16
413
2
093f
7c20
0940
1f3a
    jsr assign
parser.dasm16
414
0

parser.dasm16
415
0
:std_for_execute_suite
parser.dasm16
416
2
0941
7c20
0942
0a85
    jsr parser_suite
parser.dasm16
417
3
0943
7e72
0944
2000
0945
0001
    ife [x + HANDLE_TYPE], TYPE_CONTROL
parser.dasm16
418
2
0946
7f81
0947
095d
        set pc, std_for_control
parser.dasm16
419
0
;    ife [lexer_token], token_eof
parser.dasm16
420
0
;        set pc, std_for_eof
parser.dasm16
421
0

parser.dasm16
422
0
:std_for_control_continue
parser.dasm16
423
2
0948
7c20
0949
1b52
    jsr lexer_restore                ; restore lexer to loop condition
parser.dasm16
424
2
094a
7f9e
094b
092f
    sti pc, std_for_loop
parser.dasm16
425
0

parser.dasm16
426
0
:std_for_loop_string
parser.dasm16
427
2
094c
9612
094d
0001
    ife [a + HANDLE_TYPE], TYPE_TUPLE
parser.dasm16
428
2
094e
7f81
094f
0957
        set pc, std_for_loop_string_tuple
parser.dasm16
429
0

parser.dasm16
430
1
0950
0301
    set push, a
parser.dasm16
431
2
0951
4b01
0952
0001
    set push, [c+1]
parser.dasm16
432
2
0953
7c20
0954
1fb1
    jsr assign_from_string
parser.dasm16
433
0

parser.dasm16
434
2
0955
7f81
0956
0941
    set pc, std_for_execute_suite
parser.dasm16
435
0

parser.dasm16
436
0
:std_for_loop_string_tuple
parser.dasm16
437
1
0957
0301
    set push, a
parser.dasm16
438
1
0958
0701
    set push, b
parser.dasm16
439
2
0959
7c20
095a
1f3a
    jsr assign
parser.dasm16
440
0
    
parser.dasm16
441
2
095b
7f81
095c
0941
    set pc, std_for_execute_suite
parser.dasm16
442
0

parser.dasm16
443
0
:std_for_control
parser.dasm16
444
1
095d
2c01
    set a, [x]
parser.dasm16
445
3
095e
7e12
095f
0478
0960
0001
    ife [a + CONTROL_SIGNAL], token_continue
parser.dasm16
446
2
0961
7f81
0962
0948
        set pc, std_for_control_continue
parser.dasm16
447
3
0963
7e12
0964
046c
0965
0001
    ife [a + CONTROL_SIGNAL], token_break
parser.dasm16
448
2
0966
7f81
0967
096f
        set pc, std_for_control_break
parser.dasm16
449
3
0968
7e12
0969
0474
096a
0001
    ife [a + CONTROL_SIGNAL], token_return
parser.dasm16
450
2
096b
7f81
096c
0975
        set pc, std_for_control_return
parser.dasm16
451
0

parser.dasm16
452
2
096d
7c20
096e
00c6
    jsr recover
parser.dasm16
453
0

parser.dasm16
454
0
:std_for_control_break
parser.dasm16
455
2
096f
7c20
0970
1b52
    jsr lexer_restore
parser.dasm16
456
0

parser.dasm16
457
0
:std_for_finish    
parser.dasm16
458
2
0971
7c20
0972
0a5e
    jsr parser_skip_suite
parser.dasm16
459
0
:std_for_eof
parser.dasm16
460
2
0973
7c61
0974
029d
    set x, VOID
parser.dasm16
461
0

parser.dasm16
462
0
:std_for_control_return
parser.dasm16
463
3
0975
57c1
0976
ffff
0977
0236
    set [current_scope], [z-1]
parser.dasm16
464
2
0978
7f81
0979
2026
    set pc, postamble
parser.dasm16
465
0

parser.dasm16
466
0
;----------------------------------------------------------------
parser.dasm16
467
0
:std_del
parser.dasm16
468
0
;----------------------------------------------------------------
parser.dasm16
469
2
097a
7c20
097b
1ba6
    jsr lexer_next            ; advance 'del'
parser.dasm16
470
0

parser.dasm16
471
0
:std_del_loop
parser.dasm16
472
3
097c
7fd2
097d
0414
097e
025c
    ife [lexer_token], token_newline
parser.dasm16
473
2
097f
7f81
0980
0990
        set pc, std_del_break
parser.dasm16
474
3
0981
7fd2
0982
0410
0983
025c
    ife [lexer_token], token_eof
parser.dasm16
475
2
0984
7f81
0985
0990
        set pc, std_del_break
parser.dasm16
476
0

parser.dasm16
477
1
0986
8701
    set push, 0
parser.dasm16
478
2
0987
7c20
0988
0ab4
    jsr expression
parser.dasm16
479
2
0989
0ea1
098a
ffff
    set [z-1], x
parser.dasm16
480
0
    
parser.dasm16
481
1
098b
0f01
    set push, x
parser.dasm16
482
2
098c
7c20
098d
1fdd
    jsr del
parser.dasm16
483
0
    
parser.dasm16
484
2
098e
7f81
098f
097c
    set pc, std_del_loop
parser.dasm16
485
0

parser.dasm16
486
0
:std_del_break
parser.dasm16
487
2
0990
7c61
0991
029d
    set x, VOID
parser.dasm16
488
2
0992
7f81
0993
2026
    set pc, postamble
parser.dasm16
489
0

parser.dasm16
490
0
;----------------------------------------------------------------
parser.dasm16
491
0
:std_if
parser.dasm16
492
0
; return struct handle *none
parser.dasm16
493
0
;----------------------------------------------------------------
parser.dasm16
494
2
0994
7c20
0995
1ba6
    jsr lexer_next            ; advance 'if'
parser.dasm16
495
0

parser.dasm16
496
1
0996
8701
    set push, 0            ; evaluate if condition
parser.dasm16
497
2
0997
7c20
0998
0ab4
    jsr expression
parser.dasm16
498
2
0999
0ea1
099a
fffd
    set [z-3], x
parser.dasm16
499
0
    
parser.dasm16
500
1
099b
0f01
    set push, x
parser.dasm16
501
2
099c
7c20
099d
1dfc
    jsr eval
parser.dasm16
502
2
099e
0ea1
099f
fffd
    set [z-3], x
parser.dasm16
503
0
    
parser.dasm16
504
1
09a0
0f01
    set push, x
parser.dasm16
505
2
09a1
7c20
09a2
1ea9
    jsr boolean
parser.dasm16
506
2
09a3
0ea1
09a4
fffd
    set [z-3], x
parser.dasm16
507
0
    
parser.dasm16
508
2
09a5
7f01
09a6
04ac
    set push, token_colon        ; verify colon
parser.dasm16
509
2
09a7
7c20
09a8
1b9d
    jsr lexer_advance
parser.dasm16
510
0

parser.dasm16
511
3
09a9
7eb2
09aa
02e7
09ab
fffd
    ife [z-3], BOOL_FALSE   ; break if loop condition is false
parser.dasm16
512
2
09ac
7f81
09ad
09d5
        set pc, std_if_false
parser.dasm16
513
0

parser.dasm16
514
2
09ae
7c20
09af
0a85
    jsr parser_suite
parser.dasm16
515
3
09b0
7e72
09b1
2000
09b2
0001
    ife [x + HANDLE_TYPE], TYPE_CONTROL
parser.dasm16
516
2
09b3
7f81
09b4
2026
        set pc, postamble
parser.dasm16
517
3
09b5
7fd2
09b6
0410
09b7
025c
    ife [lexer_token], token_eof
parser.dasm16
518
2
09b8
7f81
09b9
09f0
        set pc, std_if_eof
parser.dasm16
519
0

parser.dasm16
520
2
09ba
7f81
09bb
09c9
    set pc, std_if_skip
parser.dasm16
521
0

parser.dasm16
522
0
:std_if_skip_loop
parser.dasm16
523
2
09bc
7f01
09bd
04ac
    set push, token_colon
parser.dasm16
524
2
09be
7c20
09bf
0a4e
    jsr parser_skip_until_token
parser.dasm16
525
0

parser.dasm16
526
2
09c0
7c20
09c1
1ba6
    jsr lexer_next            ; skip COLON
parser.dasm16
527
0

parser.dasm16
528
2
09c2
7c20
09c3
0a5e
    jsr parser_skip_suite
parser.dasm16
529
3
09c4
7fd2
09c5
0410
09c6
025c
    ife [lexer_token], token_eof
parser.dasm16
530
2
09c7
7f81
09c8
09f0
        set pc, std_if_eof
parser.dasm16
531
0

parser.dasm16
532
0
:std_if_skip
parser.dasm16
533
3
09c9
7fd2
09ca
0458
09cb
025c
    ife [lexer_token], token_elif
parser.dasm16
534
2
09cc
7f81
09cd
09bc
        set pc, std_if_skip_loop
parser.dasm16
535
3
09ce
7fd2
09cf
045c
09d0
025c
    ife [lexer_token], token_else
parser.dasm16
536
2
09d1
7f81
09d2
09bc
        set pc, std_if_skip_loop
parser.dasm16
537
0

parser.dasm16
538
2
09d3
7f81
09d4
09f0
    set pc, std_if_eof
parser.dasm16
539
0

parser.dasm16
540
0
:std_if_false
parser.dasm16
541
2
09d5
7c20
09d6
0a5e
    jsr parser_skip_suite
parser.dasm16
542
3
09d7
7fd2
09d8
0458
09d9
025c
    ife [lexer_token], token_elif
parser.dasm16
543
2
09da
7f81
09db
0994
        set pc, std_if
parser.dasm16
544
3
09dc
7fd2
09dd
045c
09de
025c
    ife [lexer_token], token_else
parser.dasm16
545
2
09df
7f81
09e0
09e3
        set pc, std_if_else
parser.dasm16
546
0
    
parser.dasm16
547
2
09e1
7f81
09e2
09f0
    set pc, std_if_eof
parser.dasm16
548
0

parser.dasm16
549
0
:std_if_else
parser.dasm16
550
2
09e3
7c20
09e4
1ba6
    jsr lexer_next        ; skip else
parser.dasm16
551
0

parser.dasm16
552
2
09e5
7f01
09e6
04ac
    set push, token_colon
parser.dasm16
553
2
09e7
7c20
09e8
1b9d
    jsr lexer_advance    ; skip COLON
parser.dasm16
554
0
    
parser.dasm16
555
2
09e9
7c20
09ea
0a85
    jsr parser_suite
parser.dasm16
556
0

parser.dasm16
557
3
09eb
7e72
09ec
2000
09ed
0001
    ife [x + HANDLE_TYPE], TYPE_CONTROL
parser.dasm16
558
2
09ee
7f81
09ef
2026
        set pc, postamble
parser.dasm16
559
0

parser.dasm16
560
0
:std_if_eof
parser.dasm16
561
2
09f0
7c61
09f1
029d
    set x, VOID
parser.dasm16
562
2
09f2
7f81
09f3
2026
    set pc, postamble
parser.dasm16
563
0

parser.dasm16
564
0
;----------------------------------------------------------------
parser.dasm16
565
0
:parser_fork_scope
parser.dasm16
566
0
;----------------------------------------------------------------
parser.dasm16
567
3
09f4
7aa1
09f5
0236
09f6
ffff
    set [z-1], [current_scope] ; store current scope
parser.dasm16
568
0

parser.dasm16
569
0
    ;----------------------------------------------------------------
parser.dasm16
570
0
    ; comment to disabled block scope to mimic python's deficiencies
parser.dasm16
571
1
09f7
9b01
    set push, 5            ; create new scope for while block
parser.dasm16
572
1
09f8
8b01
    set push, TYPE_DICT
parser.dasm16
573
2
09f9
7c20
09fa
21d3
    jsr alloc
parser.dasm16
574
2
09fb
0ea1
09fc
fffe
    set [z-2], x
parser.dasm16
575
2
09fd
0fc1
09fe
0236
    set [current_scope], x        ; set new scope in effect
parser.dasm16
576
0

parser.dasm16
577
1
09ff
0f01
    set push, x            ; set parent scope
parser.dasm16
578
2
0a00
7f01
0a01
03d2
    set push, STR_UNDERSCORE
parser.dasm16
579
2
0a02
5701
0a03
ffff
    set push, [z-1]
parser.dasm16
580
2
0a04
7c20
0a05
2f54
    jsr dict__set
parser.dasm16
581
0
    ;----------------------------------------------------------------
parser.dasm16
582
0

parser.dasm16
583
1
0a06
6381
    set pc, pop
parser.dasm16
584
0

parser.dasm16
585
0
;----------------------------------------------------------------
parser.dasm16
586
0
:std_while
parser.dasm16
587
0
; return struct handle *none
parser.dasm16
588
0
; todo implement else
parser.dasm16
589
0
;----------------------------------------------------------------
parser.dasm16
590
2
0a07
7c20
0a08
1ba6
    jsr lexer_next                ; advance 'while'
parser.dasm16
591
0

parser.dasm16
592
2
0a09
7c20
0a0a
09f4
    jsr parser_fork_scope
parser.dasm16
593
0

parser.dasm16
594
2
0a0b
7c20
0a0c
1b44
    jsr lexer_store                ; store lexer position
parser.dasm16
595
0

parser.dasm16
596
0
:std_while_loop
parser.dasm16
597
1
0a0d
8701
    set push, 0                    ; evaluate loop condition
parser.dasm16
598
2
0a0e
7c20
0a0f
0ab4
    jsr expression
parser.dasm16
599
2
0a10
0ea1
0a11
fffd
    set [z-3], x
parser.dasm16
600
0
    
parser.dasm16
601
1
0a12
0f01
    set push, x
parser.dasm16
602
2
0a13
7c20
0a14
1ea9
    jsr boolean
parser.dasm16
603
2
0a15
0ea1
0a16
fffd
    set [z-3], x
parser.dasm16
604
0
    
parser.dasm16
605
2
0a17
7f01
0a18
04ac
    set push, token_colon        ; verify colon
parser.dasm16
606
2
0a19
7c20
0a1a
1b9d
    jsr lexer_advance
parser.dasm16
607
0

parser.dasm16
608
3
0a1b
7eb2
0a1c
02e7
0a1d
fffd
    ife [z-3], BOOL_FALSE   ; break if loop condition is false
parser.dasm16
609
2
0a1e
7f81
0a1f
0a45
        set pc, std_while_false
parser.dasm16
610
0

parser.dasm16
611
2
0a20
7c20
0a21
0a85
    jsr parser_suite
parser.dasm16
612
3
0a22
7e72
0a23
2000
0a24
0001
    ife [x + HANDLE_TYPE], TYPE_CONTROL
parser.dasm16
613
2
0a25
7f81
0a26
0a2b
        set pc, std_while_control
parser.dasm16
614
0
;    ife [lexer_token], token_eof
parser.dasm16
615
0
;        set pc, std_while_eof    
parser.dasm16
616
0

parser.dasm16
617
0
:std_while_control_continue
parser.dasm16
618
2
0a27
7c20
0a28
1b52
    jsr lexer_restore                ; restore lexer to loop condition
parser.dasm16
619
2
0a29
7f81
0a2a
0a0d
    set pc, std_while_loop
parser.dasm16
620
0

parser.dasm16
621
0
:std_while_control
parser.dasm16
622
1
0a2b
2c01
    set a, [x]
parser.dasm16
623
3
0a2c
7e12
0a2d
0478
0a2e
0001
    ife [a + CONTROL_SIGNAL], token_continue
parser.dasm16
624
2
0a2f
7f81
0a30
0a27
        set pc, std_while_control_continue
parser.dasm16
625
3
0a31
7e12
0a32
046c
0a33
0001
    ife [a + CONTROL_SIGNAL], token_break
parser.dasm16
626
2
0a34
7f81
0a35
0a3d
        set pc, std_while_control_break
parser.dasm16
627
3
0a36
7e12
0a37
0474
0a38
0001
    ife [a + CONTROL_SIGNAL], token_return
parser.dasm16
628
2
0a39
7f81
0a3a
0a49
        set pc, std_while_control_return
parser.dasm16
629
0

parser.dasm16
630
2
0a3b
7c20
0a3c
00c6
    jsr recover
parser.dasm16
631
0

parser.dasm16
632
0
:std_while_control_break
parser.dasm16
633
2
0a3d
7c20
0a3e
1b52
    jsr lexer_restore
parser.dasm16
634
0
    
parser.dasm16
635
2
0a3f
7f01
0a40
04ac
    set push, token_colon
parser.dasm16
636
2
0a41
7c20
0a42
0a4e
    jsr parser_skip_until_token
parser.dasm16
637
0

parser.dasm16
638
2
0a43
7c20
0a44
1ba6
    jsr lexer_next        ; skip colon
parser.dasm16
639
0

parser.dasm16
640
0
:std_while_false
parser.dasm16
641
2
0a45
7c20
0a46
0a5e
    jsr parser_skip_suite
parser.dasm16
642
0
:std_while_eof
parser.dasm16
643
2
0a47
7c61
0a48
029d
    set x, VOID
parser.dasm16
644
0

parser.dasm16
645
0
:std_while_control_return
parser.dasm16
646
3
0a49
57c1
0a4a
ffff
0a4b
0236
    set [current_scope], [z-1]
parser.dasm16
647
2
0a4c
7f81
0a4d
2026
    set pc, postamble
parser.dasm16
648
0

parser.dasm16
649
0
;----------------------------------------------------------------
parser.dasm16
650
0
; void parser_skip_suite()
parser.dasm16
651
0
;----------------------------------------------------------------
parser.dasm16
652
0
:parser_skip_until_token
parser.dasm16
653
3
0a4e
6bd2
0a4f
0001
0a50
025c
    ife [lexer_token], [sp + 1]
parser.dasm16
654
2
0a51
7f81
0a52
0a5c
        set pc, parser_skip_until_token_finish
parser.dasm16
655
3
0a53
7fd2
0a54
0410
0a55
025c
    ife [lexer_token], token_eof
parser.dasm16
656
2
0a56
7f81
0a57
0a5c
        set pc, parser_skip_until_token_finish
parser.dasm16
657
0

parser.dasm16
658
2
0a58
7c20
0a59
1ba6
    jsr lexer_next
parser.dasm16
659
2
0a5a
7f81
0a5b
0a4e
    set pc, parser_skip_until_token
parser.dasm16
660
0

parser.dasm16
661
0
:parser_skip_until_token_finish
parser.dasm16
662
1
0a5c
6321
    set [sp], pop
parser.dasm16
663
1
0a5d
6381
    set pc, pop
parser.dasm16
664
0

parser.dasm16
665
0
;----------------------------------------------------------------
parser.dasm16
666
0
; void parser_skip_suite()
parser.dasm16
667
0
;----------------------------------------------------------------
parser.dasm16
668
0
:parser_skip_suite
parser.dasm16
669
1
0a5e
8701
    set push, 0
parser.dasm16
670
1
0a5f
8701
    set push, 0
parser.dasm16
671
2
0a60
7c20
0a61
2039
    jsr preamble
parser.dasm16
672
0

parser.dasm16
673
3
0a62
7fd2
0a63
0414
0a64
025c
    ife [lexer_token], token_newline
parser.dasm16
674
2
0a65
7c20
0a66
0a6f
        jsr parser_skip_suite_block
parser.dasm16
675
0

parser.dasm16
676
0
:parser_skip_suite_simple_stmt
parser.dasm16
677
2
0a67
7f01
0a68
0414
    set push, token_newline
parser.dasm16
678
2
0a69
7c20
0a6a
0a4e
    jsr parser_skip_until_token
parser.dasm16
679
0

parser.dasm16
680
0
:parser_skip_suite_simple_stmt_finish
parser.dasm16
681
2
0a6b
7c20
0a6c
1ba6
    jsr lexer_next        ; skip newline
parser.dasm16
682
2
0a6d
7f81
0a6e
2026
    set pc, postamble
parser.dasm16
683
0

parser.dasm16
684
0
:parser_skip_suite_block
parser.dasm16
685
2
0a6f
7c20
0a70
1ba6
    jsr lexer_next        ; skip newline
parser.dasm16
686
0

parser.dasm16
687
2
0a71
7f01
0a72
0418
    set push, token_indent    ; verify indent
parser.dasm16
688
2
0a73
7c20
0a74
1b9d
    jsr lexer_advance
parser.dasm16
689
0

parser.dasm16
690
1
0a75
8801
    set a, 1
parser.dasm16
691
0

parser.dasm16
692
0
:parser_skip_suite_block_loop
parser.dasm16
693
3
0a76
7fd2
0a77
0418
0a78
025c
    ife [lexer_token], token_indent
parser.dasm16
694
1
0a79
8802
        add a, 1
parser.dasm16
695
3
0a7a
7fd2
0a7b
041c
0a7c
025c
    ife [lexer_token], token_dedent
parser.dasm16
696
1
0a7d
8803
        sub a, 1        
parser.dasm16
697
0

parser.dasm16
698
2
0a7e
7c20
0a7f
1ba6
    jsr lexer_next
parser.dasm16
699
0

parser.dasm16
700
1
0a80
8412
    ife a, 0
parser.dasm16
701
2
0a81
7f81
0a82
2026
        set pc, postamble
parser.dasm16
702
0

parser.dasm16
703
2
0a83
7f81
0a84
0a76
    set pc, parser_skip_suite_block_loop
parser.dasm16
704
0

parser.dasm16
705
0
;----------------------------------------------------------------
parser.dasm16
706
0
; void parser_suite()
parser.dasm16
707
0
;----------------------------------------------------------------
parser.dasm16
708
0
:parser_suite
parser.dasm16
709
1
0a85
8701
    set push, 0
parser.dasm16
710
1
0a86
8701
    set push, 0
parser.dasm16
711
2
0a87
7c20
0a88
2039
    jsr preamble
parser.dasm16
712
0

parser.dasm16
713
3
0a89
7fd2
0a8a
0414
0a8b
025c
    ife [lexer_token], token_newline
parser.dasm16
714
2
0a8c
7f81
0a8d
0a92
        set pc, parser_suite_block
parser.dasm16
715
0

parser.dasm16
716
0
:parser_suite_simple_stmt
parser.dasm16
717
2
0a8e
7c20
0a8f
07a8
    jsr parser_simple_stmt
parser.dasm16
718
2
0a90
7f81
0a91
2026
    set pc, postamble
parser.dasm16
719
0

parser.dasm16
720
0
:parser_suite_block
parser.dasm16
721
2
0a92
7c20
0a93
1ba6
    jsr lexer_next        ; skip newline
parser.dasm16
722
0

parser.dasm16
723
2
0a94
7f01
0a95
0418
    set push, token_indent    ; verify indent
parser.dasm16
724
2
0a96
7c20
0a97
1b9d
    jsr lexer_advance
parser.dasm16
725
0
    
parser.dasm16
726
0
:parser_suite_block_loop
parser.dasm16
727
2
0a98
7c20
0a99
07a1
    jsr parser_stmt
parser.dasm16
728
0
    
parser.dasm16
729
3
0a9a
7e72
0a9b
2000
0a9c
0001
    ife [x + HANDLE_TYPE], TYPE_CONTROL
parser.dasm16
730
2
0a9d
7f81
0a9e
2026
        set pc, postamble
parser.dasm16
731
0

parser.dasm16
732
3
0a9f
7fd2
0aa0
041c
0aa1
025c
    ife [lexer_token], token_dedent
parser.dasm16
733
2
0aa2
7f81
0aa3
0aab
        set pc, parser_suite_block_break
parser.dasm16
734
0

parser.dasm16
735
3
0aa4
7fd2
0aa5
0410
0aa6
025c
    ife [lexer_token], token_eof
parser.dasm16
736
2
0aa7
7f81
0aa8
2026
        set pc, postamble
parser.dasm16
737
0

parser.dasm16
738
2
0aa9
7f81
0aaa
0a98
    set pc, parser_suite_block_loop
parser.dasm16
739
0

parser.dasm16
740
0
:parser_suite_block_break
parser.dasm16
741
2
0aab
7c20
0aac
1ba6
    jsr lexer_next    ; skip dedent
parser.dasm16
742
2
0aad
7f81
0aae
2026
    set pc, postamble
parser.dasm16
743
0

parser.dasm16
744
0
;----------------------------------------------------------------
parser.dasm16
745
0
:std_expression
parser.dasm16
746
0
;----------------------------------------------------------------
parser.dasm16
747
1
0aaf
8701
    set push, 0
parser.dasm16
748
2
0ab0
7c20
0ab1
0ab4
    jsr expression
parser.dasm16
749
0

parser.dasm16
750
2
0ab2
7f81
0ab3
2026
    set pc, postamble
parser.dasm16
751
0

parser.dasm16
752
0
;----------------------------------------------------------------
parser.dasm16
753
0
; struct handle *expression(uint16 rbp)
parser.dasm16
754
0
;----------------------------------------------------------------
parser.dasm16
755
0
:expression
parser.dasm16
756
1
0ab4
8b01
    set push, 1
parser.dasm16
757
1
0ab5
8b01
    set push, 1            ; struct handle *left
parser.dasm16
758
2
0ab6
7c20
0ab7
2039
    jsr preamble
parser.dasm16
759
0

parser.dasm16
760
2
0ab8
5421
0ab9
000a
    set b, [z+10]        ; rbp
parser.dasm16
761
0

parser.dasm16
762
2
0aba
7841
0abb
025c
    set c, [lexer_token]
parser.dasm16
763
2
0abc
4820
0abd
0001
    jsr [c + PROTOTYPE_NUD]
parser.dasm16
764
0
    
parser.dasm16
765
2
0abe
0ea1
0abf
ffff
    set [z-1], x       ; struct handle *left
parser.dasm16
766
0

parser.dasm16
767
0
:expr_loop
parser.dasm16
768
2
0ac0
7841
0ac1
025c
    set c, [lexer_token]
parser.dasm16
769
0

parser.dasm16
770
2
0ac2
4834
0ac3
0003
    ifg b, [c + PROTOTYPE_LBP]
parser.dasm16
771
2
0ac4
7f81
0ac5
0ad2
        set pc, expr_finish
parser.dasm16
772
2
0ac6
4832
0ac7
0003
    ife b, [c + PROTOTYPE_LBP]
parser.dasm16
773
2
0ac8
7f81
0ac9
0ad2
        set pc, expr_finish
parser.dasm16
774
0

parser.dasm16
775
2
0aca
5701
0acb
ffff
    set push, [z-1]
parser.dasm16
776
2
0acc
4820
0acd
0002
    jsr [c + PROTOTYPE_LED]
parser.dasm16
777
0
:expression_callback
parser.dasm16
778
2
0ace
0ea1
0acf
ffff
    set [z-1], x        ; struct handle *left
parser.dasm16
779
0

parser.dasm16
780
2
0ad0
7f81
0ad1
0ac0
    set pc, expr_loop
parser.dasm16
781
0

parser.dasm16
782
0
:expr_finish
parser.dasm16
783
2
0ad2
5461
0ad3
ffff
    set x, [z-1]       ; struct handle *left
parser.dasm16
784
2
0ad4
7f81
0ad5
2026
    set pc, postamble
parser.dasm16
785
0
    
parser.dasm16
786
0
;----------------------------------------------------------------
parser.dasm16
787
0
; struct handle *testlist(uint16 rbp)
parser.dasm16
788
0
;----------------------------------------------------------------
parser.dasm16
789
0
:testlist
parser.dasm16
790
1
0ad6
8b01
    set push, 1
parser.dasm16
791
1
0ad7
8b01
    set push, 1            ; struct handle *left
parser.dasm16
792
2
0ad8
7c20
0ad9
2039
    jsr preamble
parser.dasm16
793
0

parser.dasm16
794
2
0ada
5421
0adb
000a
    set b, [z+10]        ; rbp
parser.dasm16
795
0

parser.dasm16
796
1
0adc
8481
    set y, 0
parser.dasm16
797
3
0add
7fd2
0ade
042c
0adf
025c
    ife [lexer_token], token_name
parser.dasm16
798
2
0ae0
7c81
0ae1
0b0e
        set y, nud_name
parser.dasm16
799
3
0ae2
7fd2
0ae3
0510
0ae4
025c
    ife [lexer_token], token_lparen
parser.dasm16
800
2
0ae5
7c81
0ae6
0b3d
        set y, nud_lparen
parser.dasm16
801
0

parser.dasm16
802
1
0ae7
8492
    ife y, 0
parser.dasm16
803
2
0ae8
7c20
0ae9
00c6
        jsr recover
parser.dasm16
804
0
        
parser.dasm16
805
1
0aea
1020
    jsr y
parser.dasm16
806
2
0aeb
0ea1
0aec
ffff
    set [z-1], x       ; struct handle *left
parser.dasm16
807
0

parser.dasm16
808
0
:testlist_loop
parser.dasm16
809
2
0aed
7841
0aee
025c
    set c, [lexer_token]
parser.dasm16
810
0

parser.dasm16
811
2
0aef
4834
0af0
0003
    ifg b, [c + PROTOTYPE_LBP]
parser.dasm16
812
2
0af1
7f81
0af2
0ad2
        set pc, expr_finish
parser.dasm16
813
2
0af3
4832
0af4
0003
    ife b, [c + PROTOTYPE_LBP]
parser.dasm16
814
2
0af5
7f81
0af6
0ad2
        set pc, expr_finish
parser.dasm16
815
0

parser.dasm16
816
1
0af7
8481
    set y, 0
parser.dasm16
817
2
0af8
7c52
0af9
0508
    ife c, token_lbrack
parser.dasm16
818
2
0afa
7c81
0afb
0fa5
        set y, led_lbrack
parser.dasm16
819
2
0afc
7c52
0afd
0520
    ife c, token_reference
parser.dasm16
820
2
0afe
7c81
0aff
102b
        set y, led_reference
parser.dasm16
821
2
0b00
7c52
0b01
04a8
    ife c, token_comma
parser.dasm16
822
2
0b02
7c81
0b03
1079
        set y, led_comma
parser.dasm16
823
0
    
parser.dasm16
824
1
0b04
8492
    ife y, 0
parser.dasm16
825
2
0b05
7f81
0b06
0ad2
        set pc, expr_finish
parser.dasm16
826
0
    
parser.dasm16
827
2
0b07
5701
0b08
ffff
    set push, [z-1]
parser.dasm16
828
1
0b09
1020
    jsr y
parser.dasm16
829
0
:testlist_callback
parser.dasm16
830
2
0b0a
0ea1
0b0b
ffff
    set [z-1], x       ; struct handle *left
parser.dasm16
831
0

parser.dasm16
832
2
0b0c
7f81
0b0d
0aed
    set pc, testlist_loop
parser.dasm16
833
0

parser.dasm16
834
0
;----------------------------------------------------------------
parser.dasm16
835
0
; struct handle *nud_int()
parser.dasm16
836
0
;----------------------------------------------------------------
parser.dasm16
837
0
:nud_str
parser.dasm16
838
0
:nud_name
parser.dasm16
839
2
0b0e
7c20
0b0f
1b65
    jsr lexer_get_token_as_string
parser.dasm16
840
2
0b10
0ea1
0b11
ffff
    set [z-1], x
parser.dasm16
841
0

parser.dasm16
842
2
0b12
7c20
0b13
1ba6
    jsr lexer_next
parser.dasm16
843
0

parser.dasm16
844
2
0b14
5461
0b15
ffff
    set x, [z-1]
parser.dasm16
845
1
0b16
6381
    set pc, pop
parser.dasm16
846
0

parser.dasm16
847
0
:nud_hex
parser.dasm16
848
2
0b17
7c01
0b18
2313
    set a, int_parse_hex
parser.dasm16
849
2
0b19
7f81
0b1a
0b21
    set pc, nud_generic
parser.dasm16
850
0

parser.dasm16
851
0
:nud_float
parser.dasm16
852
2
0b1b
7c01
0b1c
1887
    set a, float__from_str
parser.dasm16
853
2
0b1d
7f81
0b1e
0b21
    set pc, nud_generic
parser.dasm16
854
0

parser.dasm16
855
0
:nud_int
parser.dasm16
856
2
0b1f
7c01
0b20
22c3
    set a, int_parse
parser.dasm16
857
0

parser.dasm16
858
0
:nud_generic
parser.dasm16
859
2
0b21
7c20
0b22
1b65
    jsr lexer_get_token_as_string
parser.dasm16
860
2
0b23
0ea1
0b24
ffff
    set [z-1], x
parser.dasm16
861
0

parser.dasm16
862
1
0b25
0f01
    set push, x
parser.dasm16
863
1
0b26
0020
    jsr a
parser.dasm16
864
2
0b27
0ea1
0b28
ffff
    set [z-1], x
parser.dasm16
865
0
        
parser.dasm16
866
2
0b29
7c20
0b2a
1ba6
    jsr lexer_next
parser.dasm16
867
0

parser.dasm16
868
2
0b2b
5461
0b2c
ffff
    set x, [z-1]
parser.dasm16
869
1
0b2d
6381
    set pc, pop
parser.dasm16
870
0

parser.dasm16
871
0
;----------------------------------------------------------------
parser.dasm16
872
0
; struct handle *nud_none()
parser.dasm16
873
0
;----------------------------------------------------------------
parser.dasm16
874
0
:nud_none
parser.dasm16
875
2
0b2e
7c20
0b2f
1ba6
    jsr lexer_next
parser.dasm16
876
2
0b30
7c61
0b31
029b
    set x, NONE
parser.dasm16
877
1
0b32
6381
    set pc, pop
parser.dasm16
878
0

parser.dasm16
879
0
;----------------------------------------------------------------
parser.dasm16
880
0
; struct handle *nud_true()
parser.dasm16
881
0
;----------------------------------------------------------------
parser.dasm16
882
0
:nud_true
parser.dasm16
883
2
0b33
7c20
0b34
1ba6
    jsr lexer_next
parser.dasm16
884
2
0b35
7c61
0b36
02e9
    set x, BOOL_TRUE
parser.dasm16
885
1
0b37
6381
    set pc, pop
parser.dasm16
886
0

parser.dasm16
887
0
;----------------------------------------------------------------
parser.dasm16
888
0
; struct handle *nud_false()
parser.dasm16
889
0
;----------------------------------------------------------------
parser.dasm16
890
0
:nud_false
parser.dasm16
891
2
0b38
7c20
0b39
1ba6
    jsr lexer_next
parser.dasm16
892
2
0b3a
7c61
0b3b
02e7
    set x, BOOL_FALSE
parser.dasm16
893
1
0b3c
6381
    set pc, pop
parser.dasm16
894
0

parser.dasm16
895
0
;----------------------------------------------------------------
parser.dasm16
896
0
; struct handle *nud_lparen()
parser.dasm16
897
0
; expression or tuple
parser.dasm16
898
0
;----------------------------------------------------------------
parser.dasm16
899
0
:nud_lparen
parser.dasm16
900
1
0b3d
8701
    set push, 0
parser.dasm16
901
1
0b3e
8b01
    set push, 1
parser.dasm16
902
2
0b3f
7c20
0b40
2039
    jsr preamble
parser.dasm16
903
0

parser.dasm16
904
2
0b41
7c20
0b42
1ba6
    jsr lexer_next    ; skip '('
parser.dasm16
905
0
    
parser.dasm16
906
3
0b43
7fd2
0b44
0514
0b45
025c
    ife [lexer_token], token_rparen
parser.dasm16
907
2
0b46
7f81
0b47
0b5a
        set pc, nud_lparen_empty
parser.dasm16
908
0

parser.dasm16
909
1
0b48
8701
    set push, 0
parser.dasm16
910
2
0b49
7c20
0b4a
0ab4
    jsr expression
parser.dasm16
911
2
0b4b
0ea1
0b4c
ffff
    set [z-1], x
parser.dasm16
912
0

parser.dasm16
913
3
0b4d
7e70
0b4e
0100
0b4f
0001
    ifb [x + HANDLE_TYPE], TYPE_TUPLE_COMMA
parser.dasm16
914
2
0b50
9661
0b51
0001
        set [x + HANDLE_TYPE], TYPE_TUPLE
parser.dasm16
915
0

parser.dasm16
916
2
0b52
7f01
0b53
0514
    set push, token_rparen
parser.dasm16
917
2
0b54
7c20
0b55
1b9d
    jsr lexer_advance
parser.dasm16
918
0

parser.dasm16
919
2
0b56
5461
0b57
ffff
    set x, [z-1]
parser.dasm16
920
2
0b58
7f81
0b59
2026
    set pc, postamble
parser.dasm16
921
0

parser.dasm16
922
0
:nud_lparen_empty
parser.dasm16
923
2
0b5a
7c20
0b5b
1ba6
    jsr lexer_next    ; skip ')'
parser.dasm16
924
0

parser.dasm16
925
1
0b5c
8701
    set push, 0
parser.dasm16
926
1
0b5d
9701
    set push, TYPE_TUPLE
parser.dasm16
927
2
0b5e
7c20
0b5f
2770
    jsr array_create
parser.dasm16
928
0

parser.dasm16
929
2
0b60
7f81
0b61
2026
    set pc, postamble
parser.dasm16
930
0

parser.dasm16
931
0
;----------------------------------------------------------------
parser.dasm16
932
0
; struct handle *nud_lbrack()
parser.dasm16
933
0
; list
parser.dasm16
934
0
;----------------------------------------------------------------
parser.dasm16
935
0
:nud_lbrack
parser.dasm16
936
1
0b62
8701
    set push, 0
parser.dasm16
937
1
0b63
8f01
    set push, 2
parser.dasm16
938
2
0b64
7c20
0b65
2039
    jsr preamble
parser.dasm16
939
0

parser.dasm16
940
2
0b66
7c20
0b67
1ba6
    jsr lexer_next    ; skip '['
parser.dasm16
941
0
    
parser.dasm16
942
3
0b68
7fd2
0b69
050c
0b6a
025c
    ife [lexer_token], token_rbrack
parser.dasm16
943
2
0b6b
7f81
0b6c
0b90
        set pc, nud_lbrack_empty
parser.dasm16
944
0

parser.dasm16
945
1
0b6d
8701
    set push, 0
parser.dasm16
946
2
0b6e
7c20
0b6f
0ab4
    jsr expression
parser.dasm16
947
2
0b70
0ea1
0b71
ffff
    set [z-1], x
parser.dasm16
948
0

parser.dasm16
949
3
0b72
7e72
0b73
0100
0b74
0001
    ife [x + HANDLE_TYPE], TYPE_TUPLE_COMMA
parser.dasm16
950
2
0b75
7f81
0b76
0b84
        set pc, nud_lbrack_change_type
parser.dasm16
951
0
    
parser.dasm16
952
1
0b77
9b01
    set push, 5
parser.dasm16
953
1
0b78
8f01
    set push, TYPE_LIST
parser.dasm16
954
2
0b79
7c20
0b7a
21d3
    jsr alloc
parser.dasm16
955
2
0b7b
0ea1
0b7c
fffe
    set [z-2], x
parser.dasm16
956
0

parser.dasm16
957
1
0b7d
2c01
    set a, [x]
parser.dasm16
958
1
0b7e
8901
    set    [a], 1
parser.dasm16
959
3
0b7f
5601
0b80
ffff
0b81
0001
    set [a+1], [z-1]
parser.dasm16
960
2
0b82
7f81
0b83
0b88
    set pc, nud_lbrack_continue
parser.dasm16
961
0
    
parser.dasm16
962
0
:nud_lbrack_change_type
parser.dasm16
963
2
0b84
8e61
0b85
0001
    set [x + HANDLE_TYPE], TYPE_LIST
parser.dasm16
964
2
0b86
0ea1
0b87
fffe
    set [z-2], x
parser.dasm16
965
0

parser.dasm16
966
0
:nud_lbrack_continue
parser.dasm16
967
2
0b88
7f01
0b89
050c
    set push, token_rbrack
parser.dasm16
968
2
0b8a
7c20
0b8b
1b9d
    jsr lexer_advance
parser.dasm16
969
0

parser.dasm16
970
2
0b8c
5461
0b8d
fffe
    set x, [z-2]
parser.dasm16
971
2
0b8e
7f81
0b8f
2026
    set pc, postamble
parser.dasm16
972
0

parser.dasm16
973
0
:nud_lbrack_empty
parser.dasm16
974
2
0b90
7c20
0b91
1ba6
    jsr lexer_next    ; skip ']'
parser.dasm16
975
0

parser.dasm16
976
1
0b92
9b01
    set push, 5
parser.dasm16
977
1
0b93
8f01
    set push, TYPE_LIST
parser.dasm16
978
2
0b94
7c20
0b95
21d3
    jsr alloc
parser.dasm16
979
0

parser.dasm16
980
2
0b96
7f81
0b97
2026
    set pc, postamble
parser.dasm16
981
0
;----------------------------------------------------------------
parser.dasm16
982
0
; struct handle *nud_lcurly()
parser.dasm16
983
0
; dict
parser.dasm16
984
0
;----------------------------------------------------------------
parser.dasm16
985
0
:nud_lcurly
parser.dasm16
986
1
0b98
8701
    set push, 0
parser.dasm16
987
1
0b99
9701
    set push, 4
parser.dasm16
988
2
0b9a
7c20
0b9b
2039
    jsr preamble
parser.dasm16
989
0

parser.dasm16
990
1
0b9c
9b01
    set push, 5
parser.dasm16
991
1
0b9d
8b01
    set push, TYPE_DICT
parser.dasm16
992
2
0b9e
7c20
0b9f
21d3
    jsr alloc
parser.dasm16
993
2
0ba0
0ea1
0ba1
ffff
    set [z-1], x
parser.dasm16
994
0

parser.dasm16
995
0
:nud_lcurly_loop
parser.dasm16
996
2
0ba2
7c20
0ba3
1ba6
    jsr lexer_next    ; skip '{' or ','
parser.dasm16
997
0

parser.dasm16
998
3
0ba4
7fd2
0ba5
051c
0ba6
025c
    ife [lexer_token], token_rcurly
parser.dasm16
999
2
0ba7
7f81
0ba8
0bda
        set pc, nud_lcurly_finish
parser.dasm16
1000
0

parser.dasm16
1001
0
    ; left side (key)
parser.dasm16
1002
1
0ba9
8701
    set push, 0
parser.dasm16
1003
2
0baa
7c20
0bab
0ab4
    jsr expression
parser.dasm16
1004
2
0bac
0ea1
0bad
fffd
    set [z-3], x
parser.dasm16
1005
0

parser.dasm16
1006
1
0bae
0f01
    set push, x
parser.dasm16
1007
2
0baf
7c20
0bb0
1dfc
    jsr eval
parser.dasm16
1008
2
0bb1
0ea1
0bb2
fffd
    set [z-3], x
parser.dasm16
1009
0

parser.dasm16
1010
2
0bb3
7f01
0bb4
04ac
    set push, token_colon
parser.dasm16
1011
2
0bb5
7c20
0bb6
1b9d
    jsr lexer_advance        ; skip ':'
parser.dasm16
1012
0

parser.dasm16
1013
0
    ; right side (value)
parser.dasm16
1014
2
0bb7
7f01
0bb8
0030
    set push, 0x0030        ; break at comma
parser.dasm16
1015
2
0bb9
7c20
0bba
0ab4
    jsr expression
parser.dasm16
1016
2
0bbb
0ea1
0bbc
fffc
    set [z-4], x
parser.dasm16
1017
0

parser.dasm16
1018
1
0bbd
0f01
    set push, x
parser.dasm16
1019
2
0bbe
7c20
0bbf
1dfc
    jsr eval
parser.dasm16
1020
2
0bc0
0ea1
0bc1
fffc
    set [z-4], x
parser.dasm16
1021
0

parser.dasm16
1022
0
    ; kv-pair
parser.dasm16
1023
1
0bc2
8f01
    set push, 2
parser.dasm16
1024
1
0bc3
9701
    set push, TYPE_TUPLE
parser.dasm16
1025
2
0bc4
7c20
0bc5
2770
    jsr array_create
parser.dasm16
1026
2
0bc6
0ea1
0bc7
fffe
    set [z-2], x
parser.dasm16
1027
0

parser.dasm16
1028
1
0bc8
2c01
    set a, [x]
parser.dasm16
1029
3
0bc9
5601
0bca
fffd
0bcb
0001
    set [a + DICT_ITEM_KEY],   [z-3]
parser.dasm16
1030
3
0bcc
5601
0bcd
fffc
0bce
0002
    set [a + DICT_ITEM_VALUE], [z-4]
parser.dasm16
1031
0

parser.dasm16
1032
2
0bcf
5701
0bd0
ffff
    set push, [z-1]
parser.dasm16
1033
2
0bd1
5701
0bd2
fffe
    set push, [z-2]
parser.dasm16
1034
2
0bd3
7c20
0bd4
27d8
    jsr array__append
parser.dasm16
1035
0

parser.dasm16
1036
3
0bd5
7fd2
0bd6
04a8
0bd7
025c
    ife [lexer_token], token_comma
parser.dasm16
1037
2
0bd8
7f81
0bd9
0ba2
        set pc, nud_lcurly_loop
parser.dasm16
1038
0

parser.dasm16
1039
0
:nud_lcurly_finish
parser.dasm16
1040
2
0bda
7f01
0bdb
051c
    set push, token_rcurly
parser.dasm16
1041
2
0bdc
7c20
0bdd
1b9d
    jsr lexer_advance
parser.dasm16
1042
0

parser.dasm16
1043
2
0bde
5461
0bdf
ffff
    set x, [z-1]
parser.dasm16
1044
2
0be0
7f81
0be1
2026
    set pc, postamble
parser.dasm16
1045
0

parser.dasm16
1046
0
;----------------------------------------------------------------
parser.dasm16
1047
0
; struct handle *nud_plus()
parser.dasm16
1048
0
;----------------------------------------------------------------
parser.dasm16
1049
0
:nud_plus
parser.dasm16
1050
2
0be2
7c20
0be3
1ba6
    jsr lexer_next
parser.dasm16
1051
0

parser.dasm16
1052
2
0be4
7f01
0be5
0150
    set push, 0x0150
parser.dasm16
1053
2
0be6
7c20
0be7
0ab4
    jsr expression
parser.dasm16
1054
0

parser.dasm16
1055
1
0be8
6381
    set pc, pop
parser.dasm16
1056
0

parser.dasm16
1057
0
;----------------------------------------------------------------
parser.dasm16
1058
0
; struct handle *nud_minus()
parser.dasm16
1059
0
;----------------------------------------------------------------
parser.dasm16
1060
0
:nud_minus
parser.dasm16
1061
1
0be9
8701
    set push, 0
parser.dasm16
1062
1
0bea
8b01
    set push, 1
parser.dasm16
1063
2
0beb
7c20
0bec
2039
    jsr preamble
parser.dasm16
1064
0

parser.dasm16
1065
2
0bed
7c20
0bee
1ba6
    jsr lexer_next
parser.dasm16
1066
0

parser.dasm16
1067
2
0bef
7f01
0bf0
0150
    set push, 0x0150
parser.dasm16
1068
2
0bf1
7c20
0bf2
0ab4
    jsr expression
parser.dasm16
1069
2
0bf3
0ea1
0bf4
ffff
    set [z-1], x
parser.dasm16
1070
0

parser.dasm16
1071
1
0bf5
0f01
    set push, x
parser.dasm16
1072
2
0bf6
7c20
0bf7
1dfc
    jsr eval
parser.dasm16
1073
2
0bf8
0ea1
0bf9
ffff
    set [z-1], x
parser.dasm16
1074
0

parser.dasm16
1075
1
0bfa
8481
    set y, 0
parser.dasm16
1076
3
0bfb
7e70
0bfc
0030
0bfd
0001
    ifb [x + HANDLE_TYPE], TYPE_INT + TYPE_BOOL
parser.dasm16
1077
2
0bfe
7c81
0bff
24c3
        set y, int_negate
parser.dasm16
1078
3
0c00
7e72
0c01
0040
0c02
0001
    ife [x + HANDLE_TYPE], TYPE_FLOAT
parser.dasm16
1079
2
0c03
7c81
0c04
1578
        set y, float__negate
parser.dasm16
1080
0

parser.dasm16
1081
1
0c05
8492
    ife y, 0
parser.dasm16
1082
2
0c06
7c20
0c07
00c6
        jsr recover
parser.dasm16
1083
0

parser.dasm16
1084
1
0c08
0f01
    set push, x
parser.dasm16
1085
1
0c09
1020
    jsr y
parser.dasm16
1086
0

parser.dasm16
1087
2
0c0a
7f81
0c0b
2026
    set pc, postamble
parser.dasm16
1088
0

parser.dasm16
1089
0
;----------------------------------------------------------------
parser.dasm16
1090
0
; struct handle *nud_tilde()
parser.dasm16
1091
0
;----------------------------------------------------------------
parser.dasm16
1092
0
:nud_tilde
parser.dasm16
1093
1
0c0c
8701
    set push, 0
parser.dasm16
1094
1
0c0d
8b01
    set push, 1
parser.dasm16
1095
2
0c0e
7c20
0c0f
2039
    jsr preamble
parser.dasm16
1096
0

parser.dasm16
1097
2
0c10
7c20
0c11
1ba6
    jsr lexer_next
parser.dasm16
1098
0

parser.dasm16
1099
2
0c12
7f01
0c13
0160
    set push, 0x0160
parser.dasm16
1100
2
0c14
7c20
0c15
0ab4
    jsr expression
parser.dasm16
1101
2
0c16
0ea1
0c17
ffff
    set [z-1], x
parser.dasm16
1102
0

parser.dasm16
1103
1
0c18
0f01
    set push, x
parser.dasm16
1104
2
0c19
7c20
0c1a
1dfc
    jsr eval
parser.dasm16
1105
2
0c1b
0ea1
0c1c
ffff
    set [z-1], x
parser.dasm16
1106
0

parser.dasm16
1107
3
0c1d
7e72
0c1e
0030
0c1f
0001
    ife [x + HANDLE_TYPE], TYPE_INT + TYPE_BOOL
parser.dasm16
1108
2
0c20
7f81
0c21
0c24
        set pc, nud_tilde_int
parser.dasm16
1109
0
        
parser.dasm16
1110
2
0c22
7c20
0c23
00c6
    jsr recover
parser.dasm16
1111
0

parser.dasm16
1112
0
:nud_tilde_int
parser.dasm16
1113
1
0c24
0f01
    set push, x
parser.dasm16
1114
2
0c25
7c20
0c26
24bc
    jsr int_complement
parser.dasm16
1115
0

parser.dasm16
1116
2
0c27
7f81
0c28
2026
    set pc, postamble
parser.dasm16
1117
0

parser.dasm16
1118
0
;----------------------------------------------------------------
parser.dasm16
1119
0
; struct handle *nud_not()
parser.dasm16
1120
0
;----------------------------------------------------------------
parser.dasm16
1121
0
:nud_not
parser.dasm16
1122
1
0c29
8701
    set push, 0
parser.dasm16
1123
1
0c2a
8b01
    set push, 1
parser.dasm16
1124
2
0c2b
7c20
0c2c
2039
    jsr preamble
parser.dasm16
1125
0

parser.dasm16
1126
2
0c2d
7c20
0c2e
1ba6
    jsr lexer_next
parser.dasm16
1127
0

parser.dasm16
1128
2
0c2f
7f01
0c30
0055
    set push, 0x0055
parser.dasm16
1129
2
0c31
7c20
0c32
0ab4
    jsr expression
parser.dasm16
1130
2
0c33
0ea1
0c34
ffff
    set [z-1], x
parser.dasm16
1131
0

parser.dasm16
1132
1
0c35
0f01
    set push, x
parser.dasm16
1133
2
0c36
7c20
0c37
1dfc
    jsr eval
parser.dasm16
1134
2
0c38
0ea1
0c39
ffff
    set [z-1], x
parser.dasm16
1135
0

parser.dasm16
1136
1
0c3a
0f01
    set push, x
parser.dasm16
1137
2
0c3b
7c20
0c3c
1ea9
    jsr boolean
parser.dasm16
1138
1
0c3d
0c01
    set a, x
parser.dasm16
1139
0

parser.dasm16
1140
2
0c3e
7c61
0c3f
02e7
    set x, BOOL_FALSE
parser.dasm16
1141
2
0c40
7c12
0c41
02e7
    ife a, BOOL_FALSE
parser.dasm16
1142
2
0c42
7c61
0c43
02e9
        set x, BOOL_TRUE
parser.dasm16
1143
0

parser.dasm16
1144
2
0c44
7f81
0c45
2026
    set pc, postamble
parser.dasm16
1145
0

parser.dasm16
1146
0
;----------------------------------------------------------------
parser.dasm16
1147
0
; struct handle *led_and(struct handle *left)
parser.dasm16
1148
0
;----------------------------------------------------------------
parser.dasm16
1149
0
:led_and
parser.dasm16
1150
1
0c46
8b01
    set push, 1
parser.dasm16
1151
1
0c47
8f01
    set push, 2
parser.dasm16
1152
2
0c48
7c20
0c49
2039
    jsr preamble
parser.dasm16
1153
0

parser.dasm16
1154
2
0c4a
7c20
0c4b
0c6e
    jsr boolean_operator
parser.dasm16
1155
0

parser.dasm16
1156
2
0c4c
7c61
0c4d
02e9
    set x, BOOL_TRUE
parser.dasm16
1157
3
0c4e
7eb2
0c4f
02e7
0c50
ffff
    ife [z-1], BOOL_FALSE   
parser.dasm16
1158
2
0c51
7c61
0c52
02e7
        set x, BOOL_FALSE
parser.dasm16
1159
3
0c53
7eb2
0c54
02e7
0c55
fffe
    ife [z-2], BOOL_FALSE   
parser.dasm16
1160
2
0c56
7c61
0c57
02e7
        set x, BOOL_FALSE
parser.dasm16
1161
0
            
parser.dasm16
1162
2
0c58
7f81
0c59
2026
    set pc, postamble
parser.dasm16
1163
0

parser.dasm16
1164
0
;----------------------------------------------------------------
parser.dasm16
1165
0
; struct handle *led_or(struct handle *left)
parser.dasm16
1166
0
;----------------------------------------------------------------
parser.dasm16
1167
0
:led_or
parser.dasm16
1168
1
0c5a
8b01
    set push, 1
parser.dasm16
1169
1
0c5b
8f01
    set push, 2
parser.dasm16
1170
2
0c5c
7c20
0c5d
2039
    jsr preamble
parser.dasm16
1171
0

parser.dasm16
1172
2
0c5e
7c20
0c5f
0c6e
    jsr boolean_operator
parser.dasm16
1173
0

parser.dasm16
1174
2
0c60
7c61
0c61
02e7
    set x, BOOL_FALSE
parser.dasm16
1175
3
0c62
7eb2
0c63
02e9
0c64
ffff
    ife [z-1], BOOL_TRUE    
parser.dasm16
1176
2
0c65
7c61
0c66
02e9
        set x, BOOL_TRUE
parser.dasm16
1177
3
0c67
7eb2
0c68
02e9
0c69
fffe
    ife [z-2], BOOL_TRUE    
parser.dasm16
1178
2
0c6a
7c61
0c6b
02e9
        set x, BOOL_TRUE
parser.dasm16
1179
0
            
parser.dasm16
1180
2
0c6c
7f81
0c6d
2026
    set pc, postamble
parser.dasm16
1181
0

parser.dasm16
1182
0
:boolean_operator
parser.dasm16
1183
2
0c6e
7c20
0c6f
1ba6
    jsr lexer_next
parser.dasm16
1184
0

parser.dasm16
1185
0
    ; evaluate left side
parser.dasm16
1186
2
0c70
5701
0c71
000a
    set push, [z+10]
parser.dasm16
1187
2
0c72
7c20
0c73
1dfc
    jsr eval
parser.dasm16
1188
2
0c74
0ea1
0c75
ffff
    set [z-1], x
parser.dasm16
1189
0

parser.dasm16
1190
1
0c76
0f01
    set push, x
parser.dasm16
1191
2
0c77
7c20
0c78
1ea9
    jsr boolean
parser.dasm16
1192
2
0c79
0ea1
0c7a
ffff
    set [z-1], x
parser.dasm16
1193
0

parser.dasm16
1194
0
    ; right side
parser.dasm16
1195
2
0c7b
7841
0c7c
025c
    set c, [lexer_token]
parser.dasm16
1196
2
0c7d
4b01
0c7e
0003
    set push, [c + PROTOTYPE_LBP]        ; push for expression call
parser.dasm16
1197
2
0c7f
7c20
0c80
0ab4
    jsr expression
parser.dasm16
1198
2
0c81
0ea1
0c82
fffe
    set [z-2], x
parser.dasm16
1199
0

parser.dasm16
1200
0
    ; evaluate right side
parser.dasm16
1201
2
0c83
5701
0c84
fffe
    set push, [z-2]
parser.dasm16
1202
2
0c85
7c20
0c86
1dfc
    jsr eval
parser.dasm16
1203
2
0c87
0ea1
0c88
fffe
    set [z-2], x
parser.dasm16
1204
0
    
parser.dasm16
1205
1
0c89
0f01
    set push, x
parser.dasm16
1206
2
0c8a
7c20
0c8b
1ea9
    jsr boolean
parser.dasm16
1207
2
0c8c
0ea1
0c8d
fffe
    set [z-2], x
parser.dasm16
1208
0

parser.dasm16
1209
1
0c8e
6381
    set pc, pop
parser.dasm16
1210
0

parser.dasm16
1211
0
;----------------------------------------------------------------
parser.dasm16
1212
0
; struct handle *led_is(struct handle *left)
parser.dasm16
1213
0
;----------------------------------------------------------------
parser.dasm16
1214
0
:led_is
parser.dasm16
1215
1
0c8f
8b01
    set push, 1
parser.dasm16
1216
1
0c90
8f01
    set push, 2
parser.dasm16
1217
2
0c91
7c20
0c92
2039
    jsr preamble
parser.dasm16
1218
0

parser.dasm16
1219
1
0c93
8801
    set a, TRUE
parser.dasm16
1220
0

parser.dasm16
1221
2
0c94
7c20
0c95
1ba6
    jsr lexer_next
parser.dasm16
1222
3
0c96
7fd3
0c97
04bc
0c98
025c
    ifn [lexer_token], token_not
parser.dasm16
1223
1
0c99
8401
        set a, FALSE
parser.dasm16
1224
3
0c9a
7fd2
0c9b
04bc
0c9c
025c
    ife [lexer_token], token_not
parser.dasm16
1225
2
0c9d
7c20
0c9e
1ba6
        jsr lexer_next
parser.dasm16
1226
0
    
parser.dasm16
1227
0
    ; evaluate left side
parser.dasm16
1228
2
0c9f
5701
0ca0
000a
    set push, [z+10]
parser.dasm16
1229
2
0ca1
7c20
0ca2
1dfc
    jsr eval
parser.dasm16
1230
2
0ca3
0ea1
0ca4
ffff
    set [z-1], x
parser.dasm16
1231
0

parser.dasm16
1232
0
    ; parse right side
parser.dasm16
1233
2
0ca5
7f01
0ca6
0070
    set push, 0x0070
parser.dasm16
1234
2
0ca7
7c20
0ca8
0ab4
    jsr expression
parser.dasm16
1235
2
0ca9
0ea1
0caa
fffe
    set [z-2], x
parser.dasm16
1236
0
    
parser.dasm16
1237
0
    ; evaluate right side
parser.dasm16
1238
2
0cab
5701
0cac
fffe
    set push, [z-2]
parser.dasm16
1239
2
0cad
7c20
0cae
1dfc
    jsr eval
parser.dasm16
1240
2
0caf
0ea1
0cb0
fffe
    set [z-2], x
parser.dasm16
1241
0

parser.dasm16
1242
1
0cb1
8812
    ife a, TRUE
parser.dasm16
1243
2
0cb2
7f81
0cb3
0cbc
        set pc, led_is_not
parser.dasm16
1244
0

parser.dasm16
1245
2
0cb4
7c61
0cb5
02e7
    set x, BOOL_FALSE
parser.dasm16
1246
2
0cb6
5472
0cb7
ffff
    ife x, [z-1]
parser.dasm16
1247
2
0cb8
7c61
0cb9
02e9
        set x, BOOL_TRUE
parser.dasm16
1248
0

parser.dasm16
1249
2
0cba
7f81
0cbb
2026
    set pc, postamble
parser.dasm16
1250
0

parser.dasm16
1251
0
:led_is_not
parser.dasm16
1252
2
0cbc
7c61
0cbd
02e9
    set x, BOOL_TRUE
parser.dasm16
1253
2
0cbe
5472
0cbf
ffff
    ife x, [z-1]
parser.dasm16
1254
2
0cc0
7c61
0cc1
02e7
        set x, BOOL_FALSE
parser.dasm16
1255
0

parser.dasm16
1256
2
0cc2
7f81
0cc3
2026
    set pc, postamble
parser.dasm16
1257
0

parser.dasm16
1258
0
;----------------------------------------------------------------
parser.dasm16
1259
0
; struct handle *led_not(struct handle *left)
parser.dasm16
1260
0
;----------------------------------------------------------------
parser.dasm16
1261
0
:led_not
parser.dasm16
1262
1
0cc4
8b01
    set push, 1
parser.dasm16
1263
1
0cc5
8f01
    set push, 2
parser.dasm16
1264
2
0cc6
7c20
0cc7
2039
    jsr preamble
parser.dasm16
1265
0

parser.dasm16
1266
2
0cc8
7c20
0cc9
1ba6
    jsr lexer_next    ; advance not
parser.dasm16
1267
0

parser.dasm16
1268
1
0cca
8801
    set a, TRUE
parser.dasm16
1269
2
0ccb
7f81
0ccc
0cd2
    set pc, led_in_1
parser.dasm16
1270
0

parser.dasm16
1271
0
;----------------------------------------------------------------
parser.dasm16
1272
0
; struct handle *led_in(struct handle *left)
parser.dasm16
1273
0
;----------------------------------------------------------------
parser.dasm16
1274
0
:led_in
parser.dasm16
1275
1
0ccd
8b01
    set push, 1
parser.dasm16
1276
1
0cce
8f01
    set push, 2
parser.dasm16
1277
2
0ccf
7c20
0cd0
2039
    jsr preamble
parser.dasm16
1278
0

parser.dasm16
1279
1
0cd1
8401
    set a, FALSE
parser.dasm16
1280
0

parser.dasm16
1281
0
:led_in_1
parser.dasm16
1282
2
0cd2
7f01
0cd3
04b8
    set push, token_in
parser.dasm16
1283
2
0cd4
7c20
0cd5
1b9d
    jsr lexer_advance    ; verify led
parser.dasm16
1284
0

parser.dasm16
1285
0
; evaluate left side
parser.dasm16
1286
2
0cd6
5701
0cd7
000a
    set push, [z+10]
parser.dasm16
1287
2
0cd8
7c20
0cd9
1dfc
    jsr eval
parser.dasm16
1288
2
0cda
0ea1
0cdb
ffff
    set [z-1], x
parser.dasm16
1289
0

parser.dasm16
1290
0
    ; parse right side
parser.dasm16
1291
2
0cdc
7f01
0cdd
0060
    set push, 0x0060
parser.dasm16
1292
2
0cde
7c20
0cdf
0ab4
    jsr expression
parser.dasm16
1293
2
0ce0
0ea1
0ce1
fffe
    set [z-2], x
parser.dasm16
1294
0
    
parser.dasm16
1295
0
    ; evaluate right side
parser.dasm16
1296
2
0ce2
5701
0ce3
fffe
    set push, [z-2]
parser.dasm16
1297
2
0ce4
7c20
0ce5
1dfc
    jsr eval
parser.dasm16
1298
2
0ce6
0ea1
0ce7
fffe
    set [z-2], x
parser.dasm16
1299
0

parser.dasm16
1300
2
0ce8
a670
0ce9
0001
    ifb [x + HANDLE_TYPE], TYPE_STR
parser.dasm16
1301
2
0cea
7f81
0ceb
0cf6
        set pc, led_in_string
parser.dasm16
1302
0

parser.dasm16
1303
2
0cec
8a70
0ced
0001
    ifb [x + HANDLE_TYPE], TYPE_DICT
parser.dasm16
1304
2
0cee
7f81
0cef
0d00
        set pc, led_in_dict
parser.dasm16
1305
0

parser.dasm16
1306
2
0cf0
9e70
0cf1
0001
    ifb [x + HANDLE_TYPE], TYPE_TUPLE + TYPE_LIST
parser.dasm16
1307
2
0cf2
7f81
0cf3
0d0a
        set pc, led_in_list
parser.dasm16
1308
0

parser.dasm16
1309
2
0cf4
7c20
0cf5
00c6
    jsr recover
parser.dasm16
1310
0

parser.dasm16
1311
0
:led_in_string
parser.dasm16
1312
1
0cf6
0f01
    set push, x
parser.dasm16
1313
2
0cf7
5701
0cf8
ffff
    set push, [z-1]
parser.dasm16
1314
2
0cf9
7c20
0cfa
29de
    jsr str_search
parser.dasm16
1315
1
0cfb
8072
    ife x, -1
parser.dasm16
1316
2
0cfc
7f81
0cfd
0d19
        set pc, led_in_not_found
parser.dasm16
1317
2
0cfe
7f81
0cff
0d12
    set pc, led_in_found
parser.dasm16
1318
0

parser.dasm16
1319
0
:led_in_dict
parser.dasm16
1320
1
0d00
0f01
    set push, x
parser.dasm16
1321
2
0d01
5701
0d02
ffff
    set push, [z-1]
parser.dasm16
1322
2
0d03
7c20
0d04
2f2e
    jsr dict_get
parser.dasm16
1323
1
0d05
8472
    ife x, 0
parser.dasm16
1324
2
0d06
7f81
0d07
0d19
        set pc, led_in_not_found
parser.dasm16
1325
2
0d08
7f81
0d09
0d12
    set pc, led_in_found
parser.dasm16
1326
0

parser.dasm16
1327
0
:led_in_list
parser.dasm16
1328
1
0d0a
0f01
    set push, x
parser.dasm16
1329
2
0d0b
5701
0d0c
ffff
    set push, [z-1]
parser.dasm16
1330
2
0d0d
7c20
0d0e
28f9
    jsr array_find
parser.dasm16
1331
1
0d0f
8072
    ife x, -1
parser.dasm16
1332
2
0d10
7f81
0d11
0d19
        set pc, led_in_not_found
parser.dasm16
1333
0

parser.dasm16
1334
0
:led_in_found
parser.dasm16
1335
2
0d12
7c61
0d13
02e9
    set x, BOOL_TRUE
parser.dasm16
1336
1
0d14
8812
    ife a, TRUE
parser.dasm16
1337
2
0d15
7c61
0d16
02e7
        set x, BOOL_FALSE
parser.dasm16
1338
0
        
parser.dasm16
1339
2
0d17
7f81
0d18
2026
    set pc, postamble
parser.dasm16
1340
0

parser.dasm16
1341
0
:led_in_not_found
parser.dasm16
1342
2
0d19
7c61
0d1a
02e7
    set x, BOOL_FALSE
parser.dasm16
1343
1
0d1b
8812
    ife a, TRUE
parser.dasm16
1344
2
0d1c
7c61
0d1d
02e9
        set x, BOOL_TRUE
parser.dasm16
1345
0
        
parser.dasm16
1346
2
0d1e
7f81
0d1f
2026
    set pc, postamble
parser.dasm16
1347
0

parser.dasm16
1348
0
;----------------------------------------------------------------
parser.dasm16
1349
0
; struct handle *led_less_or_equal(struct handle *left)
parser.dasm16
1350
0
;----------------------------------------------------------------
parser.dasm16
1351
0
:led_less_or_equal
parser.dasm16
1352
1
0d20
8b01
    set push, 1
parser.dasm16
1353
1
0d21
8f01
    set push, 2
parser.dasm16
1354
2
0d22
7c20
0d23
2039
    jsr preamble
parser.dasm16
1355
0

parser.dasm16
1356
2
0d24
7c20
0d25
0d6e
    jsr compare_operator
parser.dasm16
1357
0

parser.dasm16
1358
2
0d26
7c61
0d27
02e9
    set x, BOOL_TRUE
parser.dasm16
1359
1
0d28
8812
    ife a, 1
parser.dasm16
1360
2
0d29
7c61
0d2a
02e7
        set x, BOOL_FALSE
parser.dasm16
1361
0

parser.dasm16
1362
2
0d2b
7f81
0d2c
2026
    set pc, postamble
parser.dasm16
1363
0

parser.dasm16
1364
0
;----------------------------------------------------------------
parser.dasm16
1365
0
; struct handle *led_less(struct handle *left)
parser.dasm16
1366
0
;----------------------------------------------------------------
parser.dasm16
1367
0
:led_less
parser.dasm16
1368
1
0d2d
8b01
    set push, 1
parser.dasm16
1369
1
0d2e
8f01
    set push, 2
parser.dasm16
1370
2
0d2f
7c20
0d30
2039
    jsr preamble
parser.dasm16
1371
0

parser.dasm16
1372
2
0d31
7c20
0d32
0d6e
    jsr compare_operator
parser.dasm16
1373
0

parser.dasm16
1374
2
0d33
7c61
0d34
02e7
    set x, BOOL_FALSE
parser.dasm16
1375
1
0d35
8012
    ife a, -1
parser.dasm16
1376
2
0d36
7c61
0d37
02e9
        set x, BOOL_TRUE
parser.dasm16
1377
0

parser.dasm16
1378
2
0d38
7f81
0d39
2026
    set pc, postamble
parser.dasm16
1379
0

parser.dasm16
1380
0
;----------------------------------------------------------------
parser.dasm16
1381
0
; struct handle *led_greater_or_equal(struct handle *left)
parser.dasm16
1382
0
;----------------------------------------------------------------
parser.dasm16
1383
0
:led_greater_or_equal
parser.dasm16
1384
1
0d3a
8b01
    set push, 1
parser.dasm16
1385
1
0d3b
8f01
    set push, 2
parser.dasm16
1386
2
0d3c
7c20
0d3d
2039
    jsr preamble
parser.dasm16
1387
0

parser.dasm16
1388
2
0d3e
7c20
0d3f
0d6e
    jsr compare_operator
parser.dasm16
1389
0

parser.dasm16
1390
2
0d40
7c61
0d41
02e9
    set x, BOOL_TRUE
parser.dasm16
1391
1
0d42
8012
    ife a, -1
parser.dasm16
1392
2
0d43
7c61
0d44
02e7
        set x, BOOL_FALSE
parser.dasm16
1393
0

parser.dasm16
1394
2
0d45
7f81
0d46
2026
    set pc, postamble
parser.dasm16
1395
0

parser.dasm16
1396
0
;----------------------------------------------------------------
parser.dasm16
1397
0
; struct handle *led_greater(struct handle *left)
parser.dasm16
1398
0
;----------------------------------------------------------------
parser.dasm16
1399
0
:led_greater
parser.dasm16
1400
1
0d47
8b01
    set push, 1
parser.dasm16
1401
1
0d48
8f01
    set push, 2
parser.dasm16
1402
2
0d49
7c20
0d4a
2039
    jsr preamble
parser.dasm16
1403
0

parser.dasm16
1404
2
0d4b
7c20
0d4c
0d6e
    jsr compare_operator
parser.dasm16
1405
0

parser.dasm16
1406
2
0d4d
7c61
0d4e
02e7
    set x, BOOL_FALSE
parser.dasm16
1407
1
0d4f
8812
    ife a, 1
parser.dasm16
1408
2
0d50
7c61
0d51
02e9
        set x, BOOL_TRUE
parser.dasm16
1409
0

parser.dasm16
1410
2
0d52
7f81
0d53
2026
    set pc, postamble
parser.dasm16
1411
0

parser.dasm16
1412
0
;----------------------------------------------------------------
parser.dasm16
1413
0
; struct handle *led_not_equal(struct handle *left)
parser.dasm16
1414
0
;----------------------------------------------------------------
parser.dasm16
1415
0
:led_not_equal
parser.dasm16
1416
1
0d54
8b01
    set push, 1
parser.dasm16
1417
1
0d55
8f01
    set push, 2
parser.dasm16
1418
2
0d56
7c20
0d57
2039
    jsr preamble
parser.dasm16
1419
0

parser.dasm16
1420
2
0d58
7c20
0d59
0d6e
    jsr compare_operator
parser.dasm16
1421
0

parser.dasm16
1422
2
0d5a
7c61
0d5b
02e7
    set x, BOOL_FALSE
parser.dasm16
1423
1
0d5c
8413
    ifn a, 0
parser.dasm16
1424
2
0d5d
7c61
0d5e
02e9
        set x, BOOL_TRUE
parser.dasm16
1425
0

parser.dasm16
1426
2
0d5f
7f81
0d60
2026
    set pc, postamble
parser.dasm16
1427
0

parser.dasm16
1428
0
;----------------------------------------------------------------
parser.dasm16
1429
0
; struct handle *led_equal(struct handle *left)
parser.dasm16
1430
0
;----------------------------------------------------------------
parser.dasm16
1431
0
:led_equal
parser.dasm16
1432
1
0d61
8b01
    set push, 1
parser.dasm16
1433
1
0d62
8f01
    set push, 2
parser.dasm16
1434
2
0d63
7c20
0d64
2039
    jsr preamble
parser.dasm16
1435
0

parser.dasm16
1436
2
0d65
7c20
0d66
0d6e
    jsr compare_operator
parser.dasm16
1437
0

parser.dasm16
1438
2
0d67
7c61
0d68
02e7
    set x, BOOL_FALSE
parser.dasm16
1439
1
0d69
8412
    ife a, 0
parser.dasm16
1440
2
0d6a
7c61
0d6b
02e9
        set x, BOOL_TRUE
parser.dasm16
1441
0

parser.dasm16
1442
2
0d6c
7f81
0d6d
2026
    set pc, postamble
parser.dasm16
1443
0

parser.dasm16
1444
0
:compare_operator
parser.dasm16
1445
2
0d6e
7c20
0d6f
1ba6
    jsr lexer_next
parser.dasm16
1446
0

parser.dasm16
1447
0
    ; right side
parser.dasm16
1448
2
0d70
7f01
0d71
0080
    set push, 0x0080
parser.dasm16
1449
2
0d72
7c20
0d73
0ab4
    jsr expression
parser.dasm16
1450
2
0d74
0ea1
0d75
fffe
    set [z-2], x
parser.dasm16
1451
0

parser.dasm16
1452
0
    ; evaluate left side
parser.dasm16
1453
2
0d76
5701
0d77
000a
    set push, [z+10]
parser.dasm16
1454
2
0d78
7c20
0d79
1dfc
    jsr eval
parser.dasm16
1455
2
0d7a
0ea1
0d7b
ffff
    set [z-1], x
parser.dasm16
1456
0

parser.dasm16
1457
0
    ; evaluate right side
parser.dasm16
1458
2
0d7c
5701
0d7d
fffe
    set push, [z-2]
parser.dasm16
1459
2
0d7e
7c20
0d7f
1dfc
    jsr eval
parser.dasm16
1460
2
0d80
0ea1
0d81
fffe
    set [z-2], x
parser.dasm16
1461
0
    
parser.dasm16
1462
2
0d82
5701
0d83
ffff
    set push, [z-1]
parser.dasm16
1463
2
0d84
5701
0d85
fffe
    set push, [z-2]
parser.dasm16
1464
2
0d86
7c20
0d87
1dc0
    jsr val_cmp
parser.dasm16
1465
1
0d88
0c01
    set a, x
parser.dasm16
1466
0

parser.dasm16
1467
1
0d89
6381
    set pc, pop
parser.dasm16
1468
0

parser.dasm16
1469
0
;----------------------------------------------------------------
parser.dasm16
1470
0
; struct handle *led_plus(struct handle *left)
parser.dasm16
1471
0
;----------------------------------------------------------------
parser.dasm16
1472
0
:led_plus
parser.dasm16
1473
0
    ; todo str+str, tuple+tuple, list+list, int+int, float+int, int+float, float+float
parser.dasm16
1474
1
0d8a
8b01
    set push, 1
parser.dasm16
1475
1
0d8b
8f01
    set push, 2
parser.dasm16
1476
2
0d8c
7c20
0d8d
2039
    jsr preamble
parser.dasm16
1477
0

parser.dasm16
1478
2
0d8e
7c20
0d8f
105f
    jsr infix
parser.dasm16
1479
2
0d90
7c20
0d91
0d94
    jsr led_plus_operation    
parser.dasm16
1480
0
    
parser.dasm16
1481
2
0d92
7f81
0d93
2026
    set pc, postamble
parser.dasm16
1482
0

parser.dasm16
1483
0
:led_plus_operation
parser.dasm16
1484
2
0d94
7c20
0d95
2007
    jsr cast_common_number_type
parser.dasm16
1485
2
0d96
4041
0d97
0001
    set c, [a + HANDLE_TYPE]
parser.dasm16
1486
2
0d98
444b
0d99
0001
    bor c, [b + HANDLE_TYPE]
parser.dasm16
1487
0
    
parser.dasm16
1488
2
0d9a
7c51
0d9b
ffcf
    ifc c, TYPE_GROUP_NON_INTEGER
parser.dasm16
1489
2
0d9c
7c81
0d9d
254d
        set y, int_add
parser.dasm16
1490
2
0d9e
7c52
0d9f
0040
    ife c, TYPE_FLOAT
parser.dasm16
1491
2
0da0
7c81
0da1
15db
        set y, float__add
parser.dasm16
1492
1
0da2
a452
    ife c, TYPE_STR
parser.dasm16
1493
2
0da3
7c81
0da4
283b
        set y, array_merge
parser.dasm16
1494
1
0da5
8c52
    ife c, TYPE_LIST
parser.dasm16
1495
2
0da6
7c81
0da7
283b
        set y, array_merge
parser.dasm16
1496
1
0da8
9452
    ife c, TYPE_TUPLE
parser.dasm16
1497
2
0da9
7c81
0daa
283b
        set y, array_merge
parser.dasm16
1498
0

parser.dasm16
1499
0
:led_operation_tailer
parser.dasm16
1500
1
0dab
0301
    set push, a
parser.dasm16
1501
1
0dac
0701
    set push, b
parser.dasm16
1502
1
0dad
1020
    jsr y
parser.dasm16
1503
0

parser.dasm16
1504
1
0dae
6381
    set pc, pop
parser.dasm16
1505
0

parser.dasm16
1506
0
;----------------------------------------------------------------
parser.dasm16
1507
0
; struct handle *led_minus(struct handle *left)
parser.dasm16
1508
0
;----------------------------------------------------------------
parser.dasm16
1509
0
:led_minus
parser.dasm16
1510
0
    ; todo int-int, float-int, int-float, float-float
parser.dasm16
1511
1
0daf
8b01
    set push, 1
parser.dasm16
1512
1
0db0
8f01
    set push, 2
parser.dasm16
1513
2
0db1
7c20
0db2
2039
    jsr preamble
parser.dasm16
1514
0

parser.dasm16
1515
2
0db3
7c20
0db4
105f
    jsr infix
parser.dasm16
1516
2
0db5
7c20
0db6
0db9
    jsr led_minus_operation    
parser.dasm16
1517
0
    
parser.dasm16
1518
2
0db7
7f81
0db8
2026
    set pc, postamble
parser.dasm16
1519
0

parser.dasm16
1520
0
:led_minus_operation
parser.dasm16
1521
2
0db9
7c20
0dba
2007
    jsr cast_common_number_type
parser.dasm16
1522
2
0dbb
4041
0dbc
0001
    set c, [a + HANDLE_TYPE]
parser.dasm16
1523
2
0dbd
444b
0dbe
0001
    bor c, [b + HANDLE_TYPE]
parser.dasm16
1524
0

parser.dasm16
1525
2
0dbf
7c51
0dc0
ffcf
    ifc c, TYPE_GROUP_NON_INTEGER
parser.dasm16
1526
2
0dc1
7c81
0dc2
253b
        set y, int_sub
parser.dasm16
1527
2
0dc3
7c52
0dc4
0040
    ife c, TYPE_FLOAT
parser.dasm16
1528
2
0dc5
7c81
0dc6
164d
        set y, float__sub
parser.dasm16
1529
0

parser.dasm16
1530
2
0dc7
7f81
0dc8
0dab
    set pc, led_operation_tailer
parser.dasm16
1531
0

parser.dasm16
1532
0
;----------------------------------------------------------------
parser.dasm16
1533
0
; struct handle *led_star(struct handle *left)
parser.dasm16
1534
0
;----------------------------------------------------------------
parser.dasm16
1535
0
:led_star
parser.dasm16
1536
0
    ; todo int*int, int*float, float*int, float*float, int*str, str*int, int*tuple, tuple*int, int*list, list*int
parser.dasm16
1537
1
0dc9
8b01
    set push, 1
parser.dasm16
1538
1
0dca
8f01
    set push, 2
parser.dasm16
1539
2
0dcb
7c20
0dcc
2039
    jsr preamble
parser.dasm16
1540
0

parser.dasm16
1541
2
0dcd
7c20
0dce
105f
    jsr infix
parser.dasm16
1542
2
0dcf
7c20
0dd0
0dd3
    jsr led_star_operation    
parser.dasm16
1543
0
    
parser.dasm16
1544
2
0dd1
7f81
0dd2
2026
    set pc, postamble
parser.dasm16
1545
0

parser.dasm16
1546
0
:led_star_operation
parser.dasm16
1547
2
0dd3
7c20
0dd4
2007
    jsr cast_common_number_type
parser.dasm16
1548
2
0dd5
4041
0dd6
0001
    set c, [a + HANDLE_TYPE]
parser.dasm16
1549
2
0dd7
444b
0dd8
0001
    bor c, [b + HANDLE_TYPE]
parser.dasm16
1550
0

parser.dasm16
1551
2
0dd9
7c51
0dda
ffcf
    ifc c, TYPE_GROUP_NON_INTEGER
parser.dasm16
1552
2
0ddb
7c81
0ddc
25c7
        set y, int_mul
parser.dasm16
1553
2
0ddd
7c52
0dde
0040
    ife c, TYPE_FLOAT
parser.dasm16
1554
2
0ddf
7c81
0de0
165f
        set y, float__mul
parser.dasm16
1555
2
0de1
7c52
0de2
0028
    ife c, TYPE_STR + TYPE_INT
parser.dasm16
1556
2
0de3
7c81
0de4
2887
        set y, array_repeat
parser.dasm16
1557
2
0de5
7c52
0de6
0024
    ife c, TYPE_TUPLE + TYPE_INT
parser.dasm16
1558
2
0de7
7c81
0de8
2887
        set y, array_repeat
parser.dasm16
1559
2
0de9
7c52
0dea
0022
    ife c, TYPE_LIST + TYPE_INT
parser.dasm16
1560
2
0deb
7c81
0dec
2887
        set y, array_repeat
parser.dasm16
1561
0

parser.dasm16
1562
3
0ded
7e13
0dee
0020
0def
0001
    ifn [a + HANDLE_TYPE], TYPE_INT
parser.dasm16
1563
2
0df0
7f81
0df1
0dab
        set pc, led_operation_tailer
parser.dasm16
1564
0

parser.dasm16
1565
0
    ; swap a and b
parser.dasm16
1566
1
0df2
03a1
    set ex, a
parser.dasm16
1567
1
0df3
0401
    set a, b
parser.dasm16
1568
1
0df4
7421
    set b, ex
parser.dasm16
1569
0

parser.dasm16
1570
2
0df5
7f81
0df6
0dab
    set pc, led_operation_tailer
parser.dasm16
1571
0

parser.dasm16
1572
0
;----------------------------------------------------------------
parser.dasm16
1573
0
; struct handle *led_power(struct handle *left)
parser.dasm16
1574
0
;----------------------------------------------------------------
parser.dasm16
1575
0
:led_power
parser.dasm16
1576
0
    ; todo int*int, int*float, float*int, float*float
parser.dasm16
1577
1
0df7
8b01
    set push, 1
parser.dasm16
1578
1
0df8
8f01
    set push, 2
parser.dasm16
1579
2
0df9
7c20
0dfa
2039
    jsr preamble
parser.dasm16
1580
0

parser.dasm16
1581
2
0dfb
7c20
0dfc
1057
    jsr infixr
parser.dasm16
1582
2
0dfd
7c20
0dfe
0e01
    jsr led_power_operation    
parser.dasm16
1583
0
    
parser.dasm16
1584
2
0dff
7f81
0e00
2026
    set pc, postamble
parser.dasm16
1585
0

parser.dasm16
1586
0
:led_power_operation
parser.dasm16
1587
2
0e01
4041
0e02
0001
    set c, [a + HANDLE_TYPE]
parser.dasm16
1588
2
0e03
444b
0e04
0001
    bor c, [b + HANDLE_TYPE]
parser.dasm16
1589
0

parser.dasm16
1590
2
0e05
7c51
0e06
ffcf
    ifc c, TYPE_GROUP_NON_INTEGER
parser.dasm16
1591
2
0e07
7c81
0e08
2589
        set y, int_pow
parser.dasm16
1592
0
        
parser.dasm16
1593
3
0e09
7e12
0e0a
0040
0e0b
0001
    ife [a + HANDLE_TYPE], TYPE_FLOAT
parser.dasm16
1594
3
0e0c
7e32
0e0d
0020
0e0e
0001
        ife [b + HANDLE_TYPE], TYPE_INT
parser.dasm16
1595
2
0e0f
7c81
0e10
1846
            set y, float__pow
parser.dasm16
1596
0

parser.dasm16
1597
2
0e11
7f81
0e12
0dab
    set pc, led_operation_tailer
parser.dasm16
1598
0

parser.dasm16
1599
0
;----------------------------------------------------------------
parser.dasm16
1600
0
; struct handle *led_bitwise_or(struct handle *left)
parser.dasm16
1601
0
;----------------------------------------------------------------
parser.dasm16
1602
0
:led_bitwise_or
parser.dasm16
1603
0
    ; int*int
parser.dasm16
1604
1
0e13
8b01
    set push, 1
parser.dasm16
1605
1
0e14
8f01
    set push, 2
parser.dasm16
1606
2
0e15
7c20
0e16
2039
    jsr preamble
parser.dasm16
1607
0

parser.dasm16
1608
2
0e17
7c20
0e18
105f
    jsr infix
parser.dasm16
1609
2
0e19
7c20
0e1a
0e1d
    jsr led_bitwise_or_operation    
parser.dasm16
1610
0
    
parser.dasm16
1611
2
0e1b
7f81
0e1c
2026
    set pc, postamble
parser.dasm16
1612
0

parser.dasm16
1613
0
:led_bitwise_or_operation
parser.dasm16
1614
2
0e1d
4041
0e1e
0001
    set c, [a + HANDLE_TYPE]
parser.dasm16
1615
2
0e1f
444b
0e20
0001
    bor c, [b + HANDLE_TYPE]
parser.dasm16
1616
0

parser.dasm16
1617
2
0e21
7c51
0e22
ffcf
    ifc c, TYPE_GROUP_NON_INTEGER
parser.dasm16
1618
2
0e23
7c81
0e24
23fa
        set y, int_bitwise_or
parser.dasm16
1619
0

parser.dasm16
1620
2
0e25
7f81
0e26
0dab
    set pc, led_operation_tailer
parser.dasm16
1621
0

parser.dasm16
1622
0

parser.dasm16
1623
0
;----------------------------------------------------------------
parser.dasm16
1624
0
; struct handle *led_bitwise_xor(struct handle *left)
parser.dasm16
1625
0
;----------------------------------------------------------------
parser.dasm16
1626
0
:led_bitwise_xor
parser.dasm16
1627
0
    ; int*int
parser.dasm16
1628
1
0e27
8b01
    set push, 1
parser.dasm16
1629
1
0e28
8f01
    set push, 2
parser.dasm16
1630
2
0e29
7c20
0e2a
2039
    jsr preamble
parser.dasm16
1631
0

parser.dasm16
1632
2
0e2b
7c20
0e2c
105f
    jsr infix
parser.dasm16
1633
2
0e2d
7c20
0e2e
0e31
    jsr led_bitwise_xor_operation    
parser.dasm16
1634
0
    
parser.dasm16
1635
2
0e2f
7f81
0e30
2026
    set pc, postamble
parser.dasm16
1636
0

parser.dasm16
1637
0
:led_bitwise_xor_operation
parser.dasm16
1638
2
0e31
4041
0e32
0001
    set c, [a + HANDLE_TYPE]
parser.dasm16
1639
2
0e33
444b
0e34
0001
    bor c, [b + HANDLE_TYPE]
parser.dasm16
1640
0

parser.dasm16
1641
2
0e35
7c51
0e36
ffcf
    ifc c, TYPE_GROUP_NON_INTEGER
parser.dasm16
1642
2
0e37
7c81
0e38
242e
        set y, int_bitwise_xor
parser.dasm16
1643
0

parser.dasm16
1644
2
0e39
7f81
0e3a
0dab
    set pc, led_operation_tailer
parser.dasm16
1645
0

parser.dasm16
1646
0
;----------------------------------------------------------------
parser.dasm16
1647
0
; struct handle *led_bitwise_and(struct handle *left)
parser.dasm16
1648
0
;----------------------------------------------------------------
parser.dasm16
1649
0
:led_bitwise_and
parser.dasm16
1650
0
    ; int*int
parser.dasm16
1651
1
0e3b
8b01
    set push, 1
parser.dasm16
1652
1
0e3c
8f01
    set push, 2
parser.dasm16
1653
2
0e3d
7c20
0e3e
2039
    jsr preamble
parser.dasm16
1654
0

parser.dasm16
1655
2
0e3f
7c20
0e40
105f
    jsr infix
parser.dasm16
1656
2
0e41
7c20
0e42
0e45
    jsr led_bitwise_and_operation    
parser.dasm16
1657
0
    
parser.dasm16
1658
2
0e43
7f81
0e44
2026
    set pc, postamble
parser.dasm16
1659
0

parser.dasm16
1660
0
:led_bitwise_and_operation
parser.dasm16
1661
2
0e45
4041
0e46
0001
    set c, [a + HANDLE_TYPE]
parser.dasm16
1662
2
0e47
444b
0e48
0001
    bor c, [b + HANDLE_TYPE]
parser.dasm16
1663
0

parser.dasm16
1664
2
0e49
7c51
0e4a
ffcf
    ifc c, TYPE_GROUP_NON_INTEGER
parser.dasm16
1665
2
0e4b
7c81
0e4c
2436
        set y, int_bitwise_and
parser.dasm16
1666
0

parser.dasm16
1667
2
0e4d
7f81
0e4e
0dab
    set pc, led_operation_tailer
parser.dasm16
1668
0

parser.dasm16
1669
0
;----------------------------------------------------------------
parser.dasm16
1670
0
; struct handle *led_lshift(struct handle *left)
parser.dasm16
1671
0
;----------------------------------------------------------------
parser.dasm16
1672
0
:led_lshift
parser.dasm16
1673
0
    ; int << int
parser.dasm16
1674
1
0e4f
8b01
    set push, 1
parser.dasm16
1675
1
0e50
8f01
    set push, 2
parser.dasm16
1676
2
0e51
7c20
0e52
2039
    jsr preamble
parser.dasm16
1677
0

parser.dasm16
1678
2
0e53
7c20
0e54
105f
    jsr infix
parser.dasm16
1679
2
0e55
7c20
0e56
0e59
    jsr led_lshift_operation    
parser.dasm16
1680
0
    
parser.dasm16
1681
2
0e57
7f81
0e58
2026
    set pc, postamble
parser.dasm16
1682
0

parser.dasm16
1683
0
:led_lshift_operation
parser.dasm16
1684
2
0e59
4041
0e5a
0001
    set c, [a + HANDLE_TYPE]
parser.dasm16
1685
2
0e5b
444b
0e5c
0001
    bor c, [b + HANDLE_TYPE]
parser.dasm16
1686
0

parser.dasm16
1687
2
0e5d
7c51
0e5e
ffcf
    ifc c, TYPE_GROUP_NON_INTEGER
parser.dasm16
1688
2
0e5f
7c81
0e60
243e
        set y, int_lshift
parser.dasm16
1689
0

parser.dasm16
1690
2
0e61
7f81
0e62
0dab
    set pc, led_operation_tailer
parser.dasm16
1691
0

parser.dasm16
1692
0
;----------------------------------------------------------------
parser.dasm16
1693
0
; struct handle *led_rshift(struct handle *left)
parser.dasm16
1694
0
;----------------------------------------------------------------
parser.dasm16
1695
0
:led_rshift
parser.dasm16
1696
0
    ; int >> int
parser.dasm16
1697
1
0e63
8b01
    set push, 1
parser.dasm16
1698
1
0e64
8f01
    set push, 2
parser.dasm16
1699
2
0e65
7c20
0e66
2039
    jsr preamble
parser.dasm16
1700
0

parser.dasm16
1701
2
0e67
7c20
0e68
105f
    jsr infix
parser.dasm16
1702
2
0e69
7c20
0e6a
0e6d
    jsr led_rshift_operation    
parser.dasm16
1703
0
    
parser.dasm16
1704
2
0e6b
7f81
0e6c
2026
    set pc, postamble
parser.dasm16
1705
0

parser.dasm16
1706
0
:led_rshift_operation
parser.dasm16
1707
2
0e6d
4041
0e6e
0001
    set c, [a + HANDLE_TYPE]
parser.dasm16
1708
2
0e6f
444b
0e70
0001
    bor c, [b + HANDLE_TYPE]
parser.dasm16
1709
0

parser.dasm16
1710
2
0e71
7c51
0e72
ffcf
    ifc c, TYPE_GROUP_NON_INTEGER
parser.dasm16
1711
2
0e73
7c81
0e74
2476
        set y, int_rshift
parser.dasm16
1712
0

parser.dasm16
1713
2
0e75
7f81
0e76
0dab
    set pc, led_operation_tailer
parser.dasm16
1714
0

parser.dasm16
1715
0
;----------------------------------------------------------------
parser.dasm16
1716
0
; struct handle *led_slash(struct handle *left)
parser.dasm16
1717
0
;----------------------------------------------------------------
parser.dasm16
1718
0
:led_slash
parser.dasm16
1719
0
    ; todo int/int, int/float, float/int, float/float
parser.dasm16
1720
1
0e77
8b01
    set push, 1
parser.dasm16
1721
1
0e78
8f01
    set push, 2
parser.dasm16
1722
2
0e79
7c20
0e7a
2039
    jsr preamble
parser.dasm16
1723
0

parser.dasm16
1724
2
0e7b
7c20
0e7c
105f
    jsr infix
parser.dasm16
1725
2
0e7d
7c20
0e7e
0e81
    jsr led_slash_operation    
parser.dasm16
1726
0
    
parser.dasm16
1727
2
0e7f
7f81
0e80
2026
    set pc, postamble
parser.dasm16
1728
0

parser.dasm16
1729
0
:led_slash_operation
parser.dasm16
1730
2
0e81
7c20
0e82
2007
    jsr cast_common_number_type
parser.dasm16
1731
2
0e83
4041
0e84
0001
    set c, [a + HANDLE_TYPE]
parser.dasm16
1732
2
0e85
444b
0e86
0001
    bor c, [b + HANDLE_TYPE]
parser.dasm16
1733
0

parser.dasm16
1734
2
0e87
7c51
0e88
ffcf
    ifc c, TYPE_GROUP_NON_INTEGER
parser.dasm16
1735
2
0e89
7c81
0e8a
2621
        set y, int_div
parser.dasm16
1736
2
0e8b
7c52
0e8c
0040
    ife c, TYPE_FLOAT
parser.dasm16
1737
2
0e8d
7c81
0e8e
16d2
        set y, float__div
parser.dasm16
1738
0

parser.dasm16
1739
2
0e8f
7f81
0e90
0dab
    set pc, led_operation_tailer
parser.dasm16
1740
0

parser.dasm16
1741
0
;----------------------------------------------------------------
parser.dasm16
1742
0
; struct handle *led_percent(struct handle *left)
parser.dasm16
1743
0
;----------------------------------------------------------------
parser.dasm16
1744
0
:led_percent
parser.dasm16
1745
0
    ; todo int/int, int/float, float/int, float/float
parser.dasm16
1746
1
0e91
8b01
    set push, 1
parser.dasm16
1747
1
0e92
8f01
    set push, 2
parser.dasm16
1748
2
0e93
7c20
0e94
2039
    jsr preamble
parser.dasm16
1749
0

parser.dasm16
1750
2
0e95
7c20
0e96
105f
    jsr infix
parser.dasm16
1751
2
0e97
7c20
0e98
0e9b
    jsr led_percent_operation    
parser.dasm16
1752
0
    
parser.dasm16
1753
2
0e99
7f81
0e9a
2026
    set pc, postamble
parser.dasm16
1754
0

parser.dasm16
1755
0
:led_percent_operation
parser.dasm16
1756
2
0e9b
4041
0e9c
0001
    set c, [a + HANDLE_TYPE]
parser.dasm16
1757
2
0e9d
444b
0e9e
0001
    bor c, [b + HANDLE_TYPE]
parser.dasm16
1758
0

parser.dasm16
1759
2
0e9f
7c51
0ea0
ffcf
    ifc c, TYPE_GROUP_NON_INTEGER
parser.dasm16
1760
2
0ea1
7c81
0ea2
262d
        set y, int_mod
parser.dasm16
1761
0

parser.dasm16
1762
2
0ea3
7f81
0ea4
0dab
    set pc, led_operation_tailer
parser.dasm16
1763
0

parser.dasm16
1764
0
;----------------------------------------------------------------
parser.dasm16
1765
0
; struct handle *led_assign(struct handle *left)
parser.dasm16
1766
0
;----------------------------------------------------------------
parser.dasm16
1767
0
:led_assign
parser.dasm16
1768
1
0ea5
8b01
    set push, 1
parser.dasm16
1769
1
0ea6
8b01
    set push, 1
parser.dasm16
1770
2
0ea7
7c20
0ea8
2039
    jsr preamble
parser.dasm16
1771
0

parser.dasm16
1772
2
0ea9
7c20
0eaa
1ba6
    jsr lexer_next
parser.dasm16
1773
0

parser.dasm16
1774
0
    ; right side
parser.dasm16
1775
1
0eab
ab01
    set push, 0x0009                     ; right binding power
parser.dasm16
1776
2
0eac
7c20
0ead
0ab4
    jsr expression
parser.dasm16
1777
2
0eae
0ea1
0eaf
ffff
    set [z-1], x
parser.dasm16
1778
0
    
parser.dasm16
1779
1
0eb0
0f01
    set push, x
parser.dasm16
1780
2
0eb1
7c20
0eb2
1dfc
    jsr eval
parser.dasm16
1781
2
0eb3
0ea1
0eb4
ffff
    set [z-1], x
parser.dasm16
1782
0

parser.dasm16
1783
2
0eb5
5701
0eb6
000a
    set push, [z+10]
parser.dasm16
1784
1
0eb7
0f01
    set push, x
parser.dasm16
1785
2
0eb8
7c20
0eb9
1f3a
    jsr assign
parser.dasm16
1786
0
    
parser.dasm16
1787
2
0eba
7f81
0ebb
2026
    set pc, postamble
parser.dasm16
1788
0

parser.dasm16
1789
0
;----------------------------------------------------------------
parser.dasm16
1790
0
:led_augass
parser.dasm16
1791
0
;----------------------------------------------------------------
parser.dasm16
1792
0
    ; we cheat here, as stack is wrongly organized
parser.dasm16
1793
0
    ; z+10
parser.dasm16
1794
0
    ; rts
parser.dasm16
1795
0
    ; z+11
parser.dasm16
1796
0
    ; we must copy rts and z11 to get proper stack bottom
parser.dasm16
1797
2
0ebc
6b01
0ebd
0002
    set push, [sp+2]
parser.dasm16
1798
2
0ebe
6b01
0ebf
0002
    set push, [sp+2]
parser.dasm16
1799
0

parser.dasm16
1800
0
    ; here we claim 4 parameters, to make postamble clean them all
parser.dasm16
1801
1
0ec0
9701
    set push, 4
parser.dasm16
1802
1
0ec1
8f01
    set push, 2
parser.dasm16
1803
2
0ec2
7c20
0ec3
2039
    jsr preamble
parser.dasm16
1804
0

parser.dasm16
1805
2
0ec4
7c20
0ec5
1057
    jsr infixr
parser.dasm16
1806
0

parser.dasm16
1807
2
0ec6
5420
0ec7
000b
    jsr [z+11]
parser.dasm16
1808
2
0ec8
0ea1
0ec9
ffff
    set [z-1], x
parser.dasm16
1809
0

parser.dasm16
1810
2
0eca
5701
0ecb
000a
    set push, [z+10]
parser.dasm16
1811
1
0ecc
0f01
    set push, x
parser.dasm16
1812
2
0ecd
7c20
0ece
1f3a
    jsr assign
parser.dasm16
1813
0
    
parser.dasm16
1814
2
0ecf
7f81
0ed0
2026
    set pc, postamble
parser.dasm16
1815
0

parser.dasm16
1816
0
;----------------------------------------------------------------
parser.dasm16
1817
0
; struct handle *led_augass_lshift(struct handle *left)
parser.dasm16
1818
0
;----------------------------------------------------------------
parser.dasm16
1819
0
:led_augass_lshift
parser.dasm16
1820
2
0ed1
7f01
0ed2
0e59
    set push, led_lshift_operation
parser.dasm16
1821
2
0ed3
7f81
0ed4
0ebc
    set pc, led_augass
parser.dasm16
1822
0

parser.dasm16
1823
0
;----------------------------------------------------------------
parser.dasm16
1824
0
; struct handle *led_augass_rshift(struct handle *left)
parser.dasm16
1825
0
;----------------------------------------------------------------
parser.dasm16
1826
0
:led_augass_rshift
parser.dasm16
1827
2
0ed5
7f01
0ed6
0e6d
    set push, led_rshift_operation
parser.dasm16
1828
2
0ed7
7f81
0ed8
0ebc
    set pc, led_augass
parser.dasm16
1829
0

parser.dasm16
1830
0
;----------------------------------------------------------------
parser.dasm16
1831
0
; struct handle *led_augass_or(struct handle *left)
parser.dasm16
1832
0
;----------------------------------------------------------------
parser.dasm16
1833
0
:led_augass_or
parser.dasm16
1834
2
0ed9
7f01
0eda
0e1d
    set push, led_bitwise_or_operation
parser.dasm16
1835
2
0edb
7f81
0edc
0ebc
    set pc, led_augass
parser.dasm16
1836
0

parser.dasm16
1837
0
;----------------------------------------------------------------
parser.dasm16
1838
0
; struct handle *led_augass_xor(struct handle *left)
parser.dasm16
1839
0
;----------------------------------------------------------------
parser.dasm16
1840
0
:led_augass_xor
parser.dasm16
1841
2
0edd
7f01
0ede
0e31
    set push, led_bitwise_xor_operation
parser.dasm16
1842
2
0edf
7f81
0ee0
0ebc
    set pc, led_augass
parser.dasm16
1843
0

parser.dasm16
1844
0
;----------------------------------------------------------------
parser.dasm16
1845
0
; struct handle *led_augass_and(struct handle *left)
parser.dasm16
1846
0
;----------------------------------------------------------------
parser.dasm16
1847
0
:led_augass_and
parser.dasm16
1848
2
0ee1
7f01
0ee2
0e45
    set push, led_bitwise_and_operation
parser.dasm16
1849
2
0ee3
7f81
0ee4
0ebc
    set pc, led_augass
parser.dasm16
1850
0

parser.dasm16
1851
0
;----------------------------------------------------------------
parser.dasm16
1852
0
; struct handle *led_augass_plus(struct handle *left)
parser.dasm16
1853
0
;----------------------------------------------------------------
parser.dasm16
1854
0
:led_augass_plus
parser.dasm16
1855
2
0ee5
7f01
0ee6
0d94
    set push, led_plus_operation
parser.dasm16
1856
2
0ee7
7f81
0ee8
0ebc
    set pc, led_augass
parser.dasm16
1857
0

parser.dasm16
1858
0
;----------------------------------------------------------------
parser.dasm16
1859
0
; struct handle *led_augass_minus(struct handle *left)
parser.dasm16
1860
0
;----------------------------------------------------------------
parser.dasm16
1861
0
:led_augass_minus
parser.dasm16
1862
2
0ee9
7f01
0eea
0db9
    set push, led_minus_operation
parser.dasm16
1863
2
0eeb
7f81
0eec
0ebc
    set pc, led_augass
parser.dasm16
1864
0

parser.dasm16
1865
0
;----------------------------------------------------------------
parser.dasm16
1866
0
; struct handle *led_augass_star(struct handle *left)
parser.dasm16
1867
0
;----------------------------------------------------------------
parser.dasm16
1868
0
:led_augass_star
parser.dasm16
1869
2
0eed
7f01
0eee
0dd3
    set push, led_star_operation
parser.dasm16
1870
2
0eef
7f81
0ef0
0ebc
    set pc, led_augass
parser.dasm16
1871
0

parser.dasm16
1872
0
;----------------------------------------------------------------
parser.dasm16
1873
0
; struct handle *led_augass_slash(struct handle *left)
parser.dasm16
1874
0
;----------------------------------------------------------------
parser.dasm16
1875
0
:led_augass_slash
parser.dasm16
1876
2
0ef1
7f01
0ef2
0e81
    set push, led_slash_operation
parser.dasm16
1877
2
0ef3
7f81
0ef4
0ebc
    set pc, led_augass
parser.dasm16
1878
0

parser.dasm16
1879
0
;----------------------------------------------------------------
parser.dasm16
1880
0
; struct handle *led_augass_percent(struct handle *left)
parser.dasm16
1881
0
;----------------------------------------------------------------
parser.dasm16
1882
0
:led_augass_percent
parser.dasm16
1883
2
0ef5
7f01
0ef6
0e9b
    set push, led_percent_operation
parser.dasm16
1884
2
0ef7
7f81
0ef8
0ebc
    set pc, led_augass
parser.dasm16
1885
0

parser.dasm16
1886
0
;----------------------------------------------------------------
parser.dasm16
1887
0
; struct handle *led_lparen(struct handle *left)
parser.dasm16
1888
0
; function call
parser.dasm16
1889
0
;----------------------------------------------------------------
parser.dasm16
1890
0
:led_lparen
parser.dasm16
1891
1
0ef9
8b01
    set push, 1
parser.dasm16
1892
1
0efa
9701
    set push, 4
parser.dasm16
1893
2
0efb
7c20
0efc
2039
    jsr preamble
parser.dasm16
1894
0

parser.dasm16
1895
2
0efd
7f81
0efe
10b1
    set pc, built_in
parser.dasm16
1896
0

parser.dasm16
1897
0
:led_lparen_user_defined
parser.dasm16
1898
0
    ; prepare scope
parser.dasm16
1899
1
0eff
af01
    set push, 10        ; create scope for function call
parser.dasm16
1900
1
0f00
8b01
    set push, TYPE_DICT
parser.dasm16
1901
2
0f01
7c20
0f02
21d3
    jsr alloc
parser.dasm16
1902
2
0f03
0ea1
0f04
ffff
    set [z-1], x
parser.dasm16
1903
0

parser.dasm16
1904
1
0f05
0f01
    set push, x            ; add global scope (ex)
parser.dasm16
1905
2
0f06
7f01
0f07
03d6
    set push, STR_EX
parser.dasm16
1906
2
0f08
7b01
0f09
0235
    set push, [global_scope]
parser.dasm16
1907
2
0f0a
7c20
0f0b
2f54
    jsr dict__set
parser.dasm16
1908
0
    
parser.dasm16
1909
0
    ; create tuple for arguments
parser.dasm16
1910
1
0f0c
9b01
    set push, 5
parser.dasm16
1911
1
0f0d
9701
    set push, TYPE_TUPLE
parser.dasm16
1912
2
0f0e
7c20
0f0f
21d3
    jsr alloc
parser.dasm16
1913
2
0f10
0ea1
0f11
fffc
    set [z-4], x
parser.dasm16
1914
0

parser.dasm16
1915
0
    ; add argument tuple to function scope
parser.dasm16
1916
2
0f12
5701
0f13
ffff
    set push, [z-1]
parser.dasm16
1917
2
0f14
7f01
0f15
03e0
    set push, STR_ARGV
parser.dasm16
1918
1
0f16
0f01
    set push, x
parser.dasm16
1919
2
0f17
7c20
0f18
2f54
    jsr dict__set
parser.dasm16
1920
0
    
parser.dasm16
1921
2
0f19
5401
0f1a
000a
    set a, [z+10]        ; if call is by reference, add path dict to scope (me)
parser.dasm16
1922
3
0f1b
7e13
0f1c
0400
0f1d
0001
    ifn [a + HANDLE_TYPE], TYPE_REFERENCE
parser.dasm16
1923
2
0f1e
7f81
0f1f
0f29
        set pc, led_lparen_args
parser.dasm16
1924
0
        
parser.dasm16
1925
1
0f20
2001
    set a, [a]            ; a = struct reference *
parser.dasm16
1926
0
        
parser.dasm16
1927
2
0f21
5701
0f22
ffff
    set push, [z-1]
parser.dasm16
1928
2
0f23
7f01
0f24
03db
    set push, STR_ME
parser.dasm16
1929
2
0f25
4301
0f26
0001
    set push, [a + REFERENCE_LEFT]
parser.dasm16
1930
2
0f27
7c20
0f28
2f54
    jsr dict__set
parser.dasm16
1931
0

parser.dasm16
1932
0
:led_lparen_args
parser.dasm16
1933
2
0f29
7c20
0f2a
1ba6
    jsr lexer_next    ; skip '(' or ','
parser.dasm16
1934
0

parser.dasm16
1935
3
0f2b
7fd2
0f2c
0514
0f2d
025c
    ife [lexer_token], token_rparen
parser.dasm16
1936
2
0f2e
7f81
0f2f
0f66
        set pc, led_lparen_prepare_call
parser.dasm16
1937
0

parser.dasm16
1938
0
    ; read value or name    
parser.dasm16
1939
2
0f30
7f01
0f31
0030
    set push, 0x0030
parser.dasm16
1940
2
0f32
7c20
0f33
0ab4
    jsr expression
parser.dasm16
1941
2
0f34
0ea1
0f35
fffe
    set [z-2], x
parser.dasm16
1942
0

parser.dasm16
1943
3
0f36
7fd2
0f37
047c
0f38
025c
    ife [lexer_token], token_assign
parser.dasm16
1944
0
        ; key=value
parser.dasm16
1945
2
0f39
7f81
0f3a
0f47
        set pc, parse_testlist_item_assign
parser.dasm16
1946
0

parser.dasm16
1947
0
    ; argv[n]=value
parser.dasm16
1948
1
0f3b
0f01
    set push, x
parser.dasm16
1949
2
0f3c
7c20
0f3d
1dfc
    jsr eval
parser.dasm16
1950
2
0f3e
0ea1
0f3f
fffe
    set [z-2], x
parser.dasm16
1951
0
    
parser.dasm16
1952
2
0f40
5701
0f41
fffc
    set push, [z-4]
parser.dasm16
1953
1
0f42
0f01
    set push, x
parser.dasm16
1954
2
0f43
7c20
0f44
27d8
    jsr array__append
parser.dasm16
1955
0

parser.dasm16
1956
2
0f45
7f81
0f46
0f61
    set pc, led_lparen_arg_loop_condition
parser.dasm16
1957
0

parser.dasm16
1958
0
:parse_testlist_item_assign
parser.dasm16
1959
0
    ; f(a=1)
parser.dasm16
1960
3
0f47
7e73
0f48
0800
0f49
0001
    ifn [x + HANDLE_TYPE], TYPE_NAME
parser.dasm16
1961
2
0f4a
7c20
0f4b
00c6
        jsr recover    
parser.dasm16
1962
0

parser.dasm16
1963
2
0f4c
7c20
0f4d
1ba6
    jsr lexer_next    ; skip '='
parser.dasm16
1964
0

parser.dasm16
1965
0
    ; read value
parser.dasm16
1966
2
0f4e
7f01
0f4f
0030
    set push, 0x0030
parser.dasm16
1967
2
0f50
7c20
0f51
0ab4
    jsr expression
parser.dasm16
1968
2
0f52
0ea1
0f53
fffd
    set [z-3], x
parser.dasm16
1969
0

parser.dasm16
1970
1
0f54
0f01
    set push, x
parser.dasm16
1971
2
0f55
7c20
0f56
1dfc
    jsr eval
parser.dasm16
1972
2
0f57
0ea1
0f58
fffd
    set [z-3], x
parser.dasm16
1973
0

parser.dasm16
1974
2
0f59
5701
0f5a
ffff
    set push, [z-1]
parser.dasm16
1975
2
0f5b
5701
0f5c
fffe
    set push, [z-2]
parser.dasm16
1976
2
0f5d
5701
0f5e
fffd
    set push, [z-3]
parser.dasm16
1977
2
0f5f
7c20
0f60
2f54
    jsr dict__set
parser.dasm16
1978
0

parser.dasm16
1979
0
:led_lparen_arg_loop_condition
parser.dasm16
1980
3
0f61
7fd2
0f62
04a8
0f63
025c
    ife [lexer_token], token_comma
parser.dasm16
1981
2
0f64
7f81
0f65
0f29
        set pc, led_lparen_args
parser.dasm16
1982
0

parser.dasm16
1983
0
:led_lparen_prepare_call
parser.dasm16
1984
2
0f66
7f01
0f67
0514
    set push, token_rparen
parser.dasm16
1985
2
0f68
7c20
0f69
1b9d
    jsr lexer_advance    ; skip ')'
parser.dasm16
1986
0

parser.dasm16
1987
2
0f6a
5701
0f6b
000a
    set push, [z+10]
parser.dasm16
1988
2
0f6c
7c20
0f6d
1dfc
    jsr eval
parser.dasm16
1989
2
0f6e
0ea1
0f6f
fffe
    set [z-2], x
parser.dasm16
1990
0
    
parser.dasm16
1991
2
0f70
a673
0f71
0001
    ifn [x + HANDLE_TYPE], TYPE_STR
parser.dasm16
1992
2
0f72
7c20
0f73
00c6
        jsr recover    
parser.dasm16
1993
0

parser.dasm16
1994
2
0f74
7b01
0f75
0236
    set push, [current_scope]
parser.dasm16
1995
3
0f76
57c1
0f77
ffff
0f78
0236
    set [current_scope], [z-1]
parser.dasm16
1996
0

parser.dasm16
1997
2
0f79
7c20
0f7a
1b44
    jsr lexer_store
parser.dasm16
1998
0

parser.dasm16
1999
2
0f7b
5461
0f7c
fffe
    set x, [z-2]
parser.dasm16
2000
2
0f7d
7c20
0f7e
1b35
    jsr lexer_init
parser.dasm16
2001
0

parser.dasm16
2002
0
:led_lparen_call
parser.dasm16
2003
2
0f7f
7c20
0f80
07a1
    jsr parser_stmt
parser.dasm16
2004
2
0f81
0ea1
0f82
fffd
    set [z-3], x
parser.dasm16
2005
0

parser.dasm16
2006
3
0f83
7e72
0f84
2000
0f85
0001
    ife [x+HANDLE_TYPE], TYPE_CONTROL
parser.dasm16
2007
2
0f86
7f81
0f87
0f97
        set pc, led_lparen_control
parser.dasm16
2008
0

parser.dasm16
2009
3
0f88
7fd3
0f89
0410
0f8a
025c
    ifn [lexer_token], token_eof
parser.dasm16
2010
2
0f8b
7f81
0f8c
0f7f
        set pc, led_lparen_call
parser.dasm16
2011
0

parser.dasm16
2012
2
0f8d
7c01
0f8e
029d
    set a, VOID
parser.dasm16
2013
0

parser.dasm16
2014
0
:led_lparen_finish
parser.dasm16
2015
2
0f8f
7c20
0f90
1b52
    jsr lexer_restore
parser.dasm16
2016
3
0f91
6bc1
0f92
0006
0f93
0236
    set [current_scope], [sp+6]
parser.dasm16
2017
1
0f94
0061
    set x, a
parser.dasm16
2018
2
0f95
7f81
0f96
2026
    set pc, postamble
parser.dasm16
2019
0

parser.dasm16
2020
0
:led_lparen_control
parser.dasm16
2021
1
0f97
2c01
    set a, [x]
parser.dasm16
2022
3
0f98
7e13
0f99
0474
0f9a
0001
    ifn [a + CONTROL_SIGNAL], token_return
parser.dasm16
2023
2
0f9b
7c20
0f9c
00c6
        jsr recover            ; break and continue
parser.dasm16
2024
0

parser.dasm16
2025
2
0f9d
4301
0f9e
0002
    set push, [a + CONTROL_VALUE]
parser.dasm16
2026
2
0f9f
7c20
0fa0
1dfc
    jsr eval
parser.dasm16
2027
1
0fa1
0c01
    set a, x
parser.dasm16
2028
0
    
parser.dasm16
2029
2
0fa2
7f81
0fa3
0f8f
    set pc, led_lparen_finish
parser.dasm16
2030
0

parser.dasm16
2031
0
;----------------------------------------------------------------
parser.dasm16
2032
0
:parse_testlist_item
parser.dasm16
2033
0
;----------------------------------------------------------------
parser.dasm16
2034
1
0fa4
6381
    set pc, pop
parser.dasm16
2035
0

parser.dasm16
2036
0
;----------------------------------------------------------------
parser.dasm16
2037
0
; struct handle *led_lbrack(struct handle *left)
parser.dasm16
2038
0
;----------------------------------------------------------------
parser.dasm16
2039
0
:led_lbrack
parser.dasm16
2040
1
0fa5
8b01
    set push, 1
parser.dasm16
2041
1
0fa6
9301
    set push, 3
parser.dasm16
2042
2
0fa7
7c20
0fa8
2039
    jsr preamble
parser.dasm16
2043
0

parser.dasm16
2044
2
0fa9
7c20
0faa
1ba6
    jsr lexer_next            ; skip '['
parser.dasm16
2045
0

parser.dasm16
2046
0
    ; eval left side
parser.dasm16
2047
2
0fab
5701
0fac
000a
    set push, [z+10]
parser.dasm16
2048
2
0fad
7c20
0fae
1dfc
    jsr eval
parser.dasm16
2049
2
0faf
0ea1
0fb0
ffff
    set [z-1], x
parser.dasm16
2050
0

parser.dasm16
2051
2
0fb1
8a72
0fb2
0001
    ife [x + HANDLE_TYPE], TYPE_DICT    ; branch dict
parser.dasm16
2052
2
0fb3
7f81
0fb4
1008
        set pc, led_lbrack_dict
parser.dasm16
2053
0

parser.dasm16
2054
2
0fb5
be71
0fb6
0001
    ifc [x + HANDLE_TYPE], TYPE_STR + TYPE_TUPLE + TYPE_LIST
parser.dasm16
2055
2
0fb7
7c20
0fb8
00c6
        jsr recover
parser.dasm16
2056
0

parser.dasm16
2057
0
    ; handle str, tuple, list
parser.dasm16
2058
3
0fb9
7fd3
0fba
04ac
0fbb
025c
    ifn [lexer_token], token_colon
parser.dasm16
2059
2
0fbc
7f81
0fbd
0fc3
        set pc, led_lbrack_parse_first
parser.dasm16
2060
0

parser.dasm16
2061
0
    ; no slice start, assume 0
parser.dasm16
2062
3
0fbe
7ea1
0fbf
02a3
0fc0
fffe
    set [z-2], INT_0
parser.dasm16
2063
2
0fc1
7f81
0fc2
0fd2
    set pc, led_lbrack_after_colon
parser.dasm16
2064
0

parser.dasm16
2065
0
:led_lbrack_parse_first
parser.dasm16
2066
0
    ; parse slice start or index
parser.dasm16
2067
1
0fc3
8701
    set push, 0
parser.dasm16
2068
2
0fc4
7c20
0fc5
0ab4
    jsr expression
parser.dasm16
2069
2
0fc6
0ea1
0fc7
fffe
    set [z-2], x
parser.dasm16
2070
0
    
parser.dasm16
2071
1
0fc8
0f01
    set push, x
parser.dasm16
2072
2
0fc9
7c20
0fca
1dfc
    jsr eval
parser.dasm16
2073
2
0fcb
0ea1
0fcc
fffe
    set [z-2], x
parser.dasm16
2074
0

parser.dasm16
2075
3
0fcd
7fd3
0fce
04ac
0fcf
025c
    ifn [lexer_token], token_colon
parser.dasm16
2076
2
0fd0
7f81
0fd1
1017
        set pc, led_lbrack_finish    ; no colon -> index
parser.dasm16
2077
0

parser.dasm16
2078
0
:led_lbrack_after_colon
parser.dasm16
2079
2
0fd2
7c20
0fd3
1ba6
    jsr lexer_next                ; skip ':'
parser.dasm16
2080
0
    ; [z-2] now contains slice start
parser.dasm16
2081
3
0fd4
56a1
0fd5
fffe
0fd6
fffd
    set [z-3], [z-2]
parser.dasm16
2082
0

parser.dasm16
2083
1
0fd7
8f01
    set push, 2
parser.dasm16
2084
1
0fd8
9701
    set push, TYPE_TUPLE
parser.dasm16
2085
2
0fd9
7c20
0fda
2770
    jsr array_create
parser.dasm16
2086
2
0fdb
0ea1
0fdc
fffe
    set [z-2], x
parser.dasm16
2087
0

parser.dasm16
2088
1
0fdd
2c61
    set x, [x]
parser.dasm16
2089
3
0fde
5661
0fdf
fffd
0fe0
0001
    set [x+1], [z-3]           ; slice start
parser.dasm16
2090
0

parser.dasm16
2091
3
0fe1
7fd2
0fe2
050c
0fe3
025c
    ife [lexer_token], token_rbrack
parser.dasm16
2092
2
0fe4
7f81
0fe5
0ff8
        set pc, led_lbrack_empty_after_colon
parser.dasm16
2093
0

parser.dasm16
2094
1
0fe6
8701
    set push, 0
parser.dasm16
2095
2
0fe7
7c20
0fe8
0ab4
    jsr expression
parser.dasm16
2096
2
0fe9
0ea1
0fea
fffd
    set [z-3], x
parser.dasm16
2097
0
    
parser.dasm16
2098
1
0feb
0f01
    set push, x
parser.dasm16
2099
2
0fec
7c20
0fed
1dfc
    jsr eval
parser.dasm16
2100
2
0fee
0ea1
0fef
fffd
    set [z-3], x
parser.dasm16
2101
0

parser.dasm16
2102
2
0ff0
5401
0ff1
fffe
    set a, [z-2]
parser.dasm16
2103
1
0ff2
2001
    set a, [a]
parser.dasm16
2104
3
0ff3
5601
0ff4
fffd
0ff5
0002
    set [a+2], [z-3]        ; slice end
parser.dasm16
2105
0

parser.dasm16
2106
2
0ff6
7f81
0ff7
1017
    set pc, led_lbrack_finish
parser.dasm16
2107
0

parser.dasm16
2108
0
:led_lbrack_empty_after_colon
parser.dasm16
2109
0
    ; set array len to slice end
parser.dasm16
2110
2
0ff8
5401
0ff9
ffff
    set a, [z-1]
parser.dasm16
2111
1
0ffa
2001
    set a, [a]
parser.dasm16
2112
0

parser.dasm16
2113
1
0ffb
2301
    set push, [a]
parser.dasm16
2114
2
0ffc
7c20
0ffd
22a2
    jsr  uint16_to_int
parser.dasm16
2115
2
0ffe
0ea1
0fff
fffd
    set [z-3], x
parser.dasm16
2116
0
    
parser.dasm16
2117
2
1000
5401
1001
fffe
    set a, [z-2]
parser.dasm16
2118
1
1002
2001
    set a, [a]
parser.dasm16
2119
3
1003
5601
1004
fffd
1005
0002
    set [a+2], [z-3]        ; slice end
parser.dasm16
2120
0
    
parser.dasm16
2121
2
1006
7f81
1007
1017
    set pc, led_lbrack_finish
parser.dasm16
2122
0

parser.dasm16
2123
0
:led_lbrack_dict
parser.dasm16
2124
1
1008
8701
    set push, 0
parser.dasm16
2125
2
1009
7c20
100a
0ab4
    jsr expression
parser.dasm16
2126
2
100b
0ea1
100c
fffe
    set [z-2], x
parser.dasm16
2127
0
        
parser.dasm16
2128
1
100d
0f01
    set push, x
parser.dasm16
2129
2
100e
7c20
100f
1dfc
    jsr eval
parser.dasm16
2130
2
1010
0ea1
1011
fffe
    set [z-2], x
parser.dasm16
2131
0

parser.dasm16
2132
3
1012
7e71
1013
00fc
1014
0001
    ifc [x + HANDLE_TYPE], TYPE_STR + TYPE_TUPLE + TYPE_INT + TYPE_BOOL + TYPE_FLOAT + TYPE_NONE
parser.dasm16
2133
2
1015
7c20
1016
00c6
        jsr recover
parser.dasm16
2134
0

parser.dasm16
2135
0
:led_lbrack_finish
parser.dasm16
2136
2
1017
7f01
1018
050c
    set push, token_rbrack
parser.dasm16
2137
2
1019
7c20
101a
1b9d
    jsr lexer_advance
parser.dasm16
2138
0

parser.dasm16
2139
0
    ; construct return value
parser.dasm16
2140
1
101b
8f01
    set push, 2
parser.dasm16
2141
2
101c
7f01
101d
0200
    set push, TYPE_SUBSCRIPTION
parser.dasm16
2142
2
101e
7c20
101f
2770
    jsr array_create
parser.dasm16
2143
2
1020
0ea1
1021
fffd
    set [z-3], x            ; result
parser.dasm16
2144
0

parser.dasm16
2145
1
1022
2c01
    set a, [x]
parser.dasm16
2146
3
1023
5601
1024
ffff
1025
0001
    set [a + SUBSCRIPTION_LIST], [z-1]
parser.dasm16
2147
3
1026
5601
1027
fffe
1028
0002
    set [a + SUBSCRIPTION_INDEX], [z-2]
parser.dasm16
2148
0

parser.dasm16
2149
2
1029
7f81
102a
2026
    set pc, postamble
parser.dasm16
2150
0

parser.dasm16
2151
0
;----------------------------------------------------------------
parser.dasm16
2152
0
; struct handle *led_reference(struct handle *left)
parser.dasm16
2153
0
; attribute reference
parser.dasm16
2154
0
;----------------------------------------------------------------
parser.dasm16
2155
0
:led_reference
parser.dasm16
2156
1
102b
8b01
    set push, 1
parser.dasm16
2157
1
102c
9301
    set push, 3
parser.dasm16
2158
2
102d
7c20
102e
2039
    jsr preamble
parser.dasm16
2159
0

parser.dasm16
2160
1
102f
8f01
    set push, 2
parser.dasm16
2161
2
1030
7f01
1031
0400
    set push, TYPE_REFERENCE
parser.dasm16
2162
2
1032
7c20
1033
2770
    jsr array_create
parser.dasm16
2163
2
1034
0ea1
1035
ffff
    set [z-1], x
parser.dasm16
2164
0
    
parser.dasm16
2165
2
1036
5701
1037
000a
    set push, [z+10]
parser.dasm16
2166
2
1038
7c20
1039
1dfc
    jsr eval
parser.dasm16
2167
0

parser.dasm16
2168
2
103a
b271
103b
0001
    ifc [x + HANDLE_TYPE], TYPE_GROUP_CAN_REFERENCE
parser.dasm16
2169
2
103c
7c20
103d
00c6
        jsr recover
parser.dasm16
2170
0

parser.dasm16
2171
2
103e
5401
103f
ffff
    set a, [z-1]
parser.dasm16
2172
1
1040
2001
    set a, [a]
parser.dasm16
2173
2
1041
0e01
1042
0001
    set [a + REFERENCE_LEFT], x
parser.dasm16
2174
0
    
parser.dasm16
2175
2
1043
7c20
1044
1ba6
    jsr lexer_next
parser.dasm16
2176
0

parser.dasm16
2177
3
1045
7fd3
1046
042c
1047
025c
    ifn [lexer_token], token_name
parser.dasm16
2178
2
1048
7c20
1049
00c6
        jsr recover
parser.dasm16
2179
0

parser.dasm16
2180
2
104a
7c20
104b
1b65
    jsr lexer_get_token_as_string
parser.dasm16
2181
0
;    set [x + HANDLE_TYPE], TYPE_STR
parser.dasm16
2182
0

parser.dasm16
2183
2
104c
5401
104d
ffff
    set a, [z-1]
parser.dasm16
2184
1
104e
2001
    set a, [a]
parser.dasm16
2185
2
104f
0e01
1050
0002
    set [a + REFERENCE_RIGHT], x
parser.dasm16
2186
0

parser.dasm16
2187
2
1051
7c20
1052
1ba6
    jsr lexer_next
parser.dasm16
2188
0
    
parser.dasm16
2189
2
1053
5461
1054
ffff
    set x, [z-1]
parser.dasm16
2190
2
1055
7f81
1056
2026
    set pc, postamble
parser.dasm16
2191
0

parser.dasm16
2192
0
;----------------------------------------------------------------
parser.dasm16
2193
0
:infixr
parser.dasm16
2194
2
1057
7801
1058
025c
    set a, [lexer_token]
parser.dasm16
2195
2
1059
4001
105a
0003
    set a, [a + PROTOTYPE_LBP]        ; push for expression call
parser.dasm16
2196
1
105b
8803
    sub a, 1
parser.dasm16
2197
1
105c
0301
    set push, a
parser.dasm16
2198
2
105d
7f81
105e
1063
    set pc, infix_1
parser.dasm16
2199
0

parser.dasm16
2200
0
;----------------------------------------------------------------
parser.dasm16
2201
0
:infix
parser.dasm16
2202
0
; fastcall
parser.dasm16
2203
0
; return 
parser.dasm16
2204
0
;   a: struct handle *left
parser.dasm16
2205
0
;   b: struct handle *right
parser.dasm16
2206
0
;   y: 0
parser.dasm16
2207
0
;----------------------------------------------------------------
parser.dasm16
2208
2
105f
7801
1060
025c
    set a, [lexer_token]
parser.dasm16
2209
2
1061
4301
1062
0003
    set push, [a + PROTOTYPE_LBP]        ; push for expression call
parser.dasm16
2210
0

parser.dasm16
2211
0
:infix_1
parser.dasm16
2212
0
    ; left
parser.dasm16
2213
2
1063
5701
1064
000a
    set push, [z+10]
parser.dasm16
2214
2
1065
7c20
1066
1dfc
    jsr eval
parser.dasm16
2215
2
1067
0ea1
1068
ffff
    set [z-1], x
parser.dasm16
2216
1
1069
0c01
    set a, x
parser.dasm16
2217
0

parser.dasm16
2218
2
106a
7c20
106b
1ba6
    jsr lexer_next
parser.dasm16
2219
0

parser.dasm16
2220
0
    ; right side
parser.dasm16
2221
2
106c
7c20
106d
0ab4
    jsr expression
parser.dasm16
2222
2
106e
0ea1
106f
fffe
    set [z-2], x
parser.dasm16
2223
0

parser.dasm16
2224
1
1070
0f01
    set push, x
parser.dasm16
2225
2
1071
7c20
1072
1dfc
    jsr eval
parser.dasm16
2226
2
1073
0ea1
1074
fffe
    set [z-2], x
parser.dasm16
2227
1
1075
0c21
    set b, x
parser.dasm16
2228
0
    
parser.dasm16
2229
2
1076
7c81
1077
00c6
    set y, recover
parser.dasm16
2230
0

parser.dasm16
2231
1
1078
6381
    set pc, pop
parser.dasm16
2232
0
    
parser.dasm16
2233
0
;----------------------------------------------------------------
parser.dasm16
2234
0
; struct handle *led_comma(struct handle *left)
parser.dasm16
2235
0
; tuple
parser.dasm16
2236
0
;----------------------------------------------------------------
parser.dasm16
2237
0
:led_comma
parser.dasm16
2238
1
1079
8b01
    set push, 1
parser.dasm16
2239
1
107a
8f01
    set push, 2
parser.dasm16
2240
2
107b
7c20
107c
2039
    jsr preamble
parser.dasm16
2241
0

parser.dasm16
2242
2
107d
5401
107e
000a
    set a, [z+10]
parser.dasm16
2243
2
107f
02a1
1080
ffff
    set [z-1], a
parser.dasm16
2244
3
1081
7e12
1082
0100
1083
0001
    ife [a + HANDLE_TYPE], TYPE_TUPLE_COMMA
parser.dasm16
2245
2
1084
7f81
1085
1091
        set pc, led_comma_add
parser.dasm16
2246
0
        
parser.dasm16
2247
1
1086
9b01
    set push, 5
parser.dasm16
2248
2
1087
7f01
1088
0100
    set push, TYPE_TUPLE_COMMA
parser.dasm16
2249
2
1089
7c20
108a
21d3
    jsr alloc
parser.dasm16
2250
2
108b
0ea1
108c
ffff
    set [z-1], x
parser.dasm16
2251
0

parser.dasm16
2252
1
108d
2c61
    set x, [x]
parser.dasm16
2253
1
108e
8961
    set [x], 1
parser.dasm16
2254
2
108f
0261
1090
0001
    set [x+1], a
parser.dasm16
2255
0
    
parser.dasm16
2256
0
:led_comma_add
parser.dasm16
2257
2
1091
7c20
1092
1ba6
    jsr lexer_next
parser.dasm16
2258
0

parser.dasm16
2259
2
1093
7801
1094
025c
    set a, [lexer_token]
parser.dasm16
2260
2
1095
7d13
1096
0aaf
    ifn [a + PROTOTYPE_STD], std_expression
parser.dasm16
2261
2
1097
7f81
1098
10ad
        set pc, led_comma_end
parser.dasm16
2262
0

parser.dasm16
2263
2
1099
7f01
109a
0020
    set push, 0x0020
parser.dasm16
2264
3
109b
7eb2
109c
0ace
109d
0009
    ife [z+9], expression_callback
parser.dasm16
2265
2
109e
7c20
109f
0ab4
        jsr expression
parser.dasm16
2266
3
10a0
7eb2
10a1
0b0a
10a2
0009
    ife [z+9], testlist_callback
parser.dasm16
2267
2
10a3
7c20
10a4
0ad6
        jsr testlist    
parser.dasm16
2268
2
10a5
0ea1
10a6
fffe
    set [z-2], x
parser.dasm16
2269
0

parser.dasm16
2270
2
10a7
5701
10a8
ffff
    set push, [z-1]
parser.dasm16
2271
2
10a9
5701
10aa
fffe
    set push, [z-2]
parser.dasm16
2272
2
10ab
7c20
10ac
27d8
    jsr array__append
parser.dasm16
2273
0

parser.dasm16
2274
0
:led_comma_end
parser.dasm16
2275
2
10ad
5461
10ae
ffff
    set x, [z-1]    ; expr
parser.dasm16
2276
2
10af
7f81
10b0
2026
    set pc, postamble
parser.dasm16
2277
0

parser.dasm16
2278
0
;----------------------------------------------------------------
parser.dasm16
2279
0
:built_in
parser.dasm16
2280
0
;----------------------------------------------------------------
parser.dasm16
2281
2
10b1
5401
10b2
000a
    set a, [z+10]
parser.dasm16
2282
3
10b3
7e12
10b4
0800
10b5
0001
    ife [a+HANDLE_TYPE], TYPE_NAME
parser.dasm16
2283
2
10b6
7f81
10b7
10da
        set pc, built_in__global_functions
parser.dasm16
2284
3
10b8
7e12
10b9
0400
10ba
0001
    ife [a+HANDLE_TYPE], TYPE_REFERENCE
parser.dasm16
2285
2
10bb
7f81
10bc
10bf
        set pc, built_in__object_functions
parser.dasm16
2286
0
        
parser.dasm16
2287
2
10bd
7f81
10be
0eff
    set pc, led_lparen_user_defined
parser.dasm16
2288
0

parser.dasm16
2289
0
:built_in__object_functions
parser.dasm16
2290
1
10bf
2001
    set a, [a]
parser.dasm16
2291
2
10c0
4021
10c1
0001
    set b, [a + REFERENCE_LEFT]
parser.dasm16
2292
0

parser.dasm16
2293
0
    ; ADD HERE OBJECT TYPES THAT HAVE METHODS
parser.dasm16
2294
1
10c2
8461
    set x, 0
parser.dasm16
2295
2
10c3
8e32
10c4
0001
    ife [b + HANDLE_TYPE], TYPE_LIST
parser.dasm16
2296
2
10c5
7c61
10c6
0618
        set x, built_in__list_methods
parser.dasm16
2297
2
10c7
a632
10c8
0001
    ife [b + HANDLE_TYPE], TYPE_STR
parser.dasm16
2298
2
10c9
7c61
10ca
0634
        set x, built_in__str_methods
parser.dasm16
2299
2
10cb
8a32
10cc
0001
    ife [b + HANDLE_TYPE], TYPE_DICT
parser.dasm16
2300
2
10cd
7c61
10ce
062a
        set x, built_in__dict_methods
parser.dasm16
2301
0

parser.dasm16
2302
1
10cf
8472
    ife x, 0
parser.dasm16
2303
2
10d0
7f81
10d1
0eff
        set pc, led_lparen_user_defined
parser.dasm16
2304
0

parser.dasm16
2305
2
10d2
4001
10d3
0002
    set a, [a + REFERENCE_RIGHT]
parser.dasm16
2306
1
10d4
2001
    set a, [a]
parser.dasm16
2307
0
    
parser.dasm16
2308
1
10d5
2021
    set b, [a]
parser.dasm16
2309
1
10d6
8802
    add a, 1
parser.dasm16
2310
0

parser.dasm16
2311
2
10d7
7c20
10d8
2168
    jsr built_in_matcher
parser.dasm16
2312
1
10d9
0b81
    set pc, c
parser.dasm16
2313
0

parser.dasm16
2314
0
:built_in__global_functions
parser.dasm16
2315
1
10da
2001
    set a, [a]
parser.dasm16
2316
0
    
parser.dasm16
2317
1
10db
2021
    set b, [a]
parser.dasm16
2318
1
10dc
8802
    add a, 1
parser.dasm16
2319
0
    
parser.dasm16
2320
2
10dd
7c61
10de
0524
    set x, built_in_functions
parser.dasm16
2321
2
10df
7c20
10e0
2168
    jsr built_in_matcher
parser.dasm16
2322
1
10e1
0b81
    set pc, c
parser.dasm16
2323
0

parser.dasm16
2324
0
;----------------------------------------------------------------
parser.dasm16
2325
0
:built_in__object_method__init
parser.dasm16
2326
0
;----------------------------------------------------------------
parser.dasm16
2327
2
10e2
7c20
10e3
1542
    jsr built_in_params
parser.dasm16
2328
0

parser.dasm16
2329
2
10e4
5401
10e5
000a
    set a, [z+10]
parser.dasm16
2330
1
10e6
2001
    set a, [a]
parser.dasm16
2331
2
10e7
4001
10e8
0001
    set a, [a + REFERENCE_LEFT]
parser.dasm16
2332
0

parser.dasm16
2333
1
10e9
6381
    set pc, pop
parser.dasm16
2334
0

parser.dasm16
2335
0
;----------------------------------------------------------------
parser.dasm16
2336
0
:built_in__dict_create
parser.dasm16
2337
0
;----------------------------------------------------------------
parser.dasm16
2338
2
10ea
7c20
10eb
10e2
    jsr built_in__object_method__init
parser.dasm16
2339
0

parser.dasm16
2340
1
10ec
84d3
    ifn i, 0
parser.dasm16
2341
2
10ed
7c20
10ee
00c6
        jsr recover
parser.dasm16
2342
0

parser.dasm16
2343
1
10ef
9b01
    set push, 5
parser.dasm16
2344
1
10f0
8b01
    set push, TYPE_DICT
parser.dasm16
2345
2
10f1
7c20
10f2
21d3
    jsr alloc
parser.dasm16
2346
2
10f3
0ea1
10f4
ffff
    set [z-1], x
parser.dasm16
2347
0
    
parser.dasm16
2348
1
10f5
0f01
    set push, x
parser.dasm16
2349
2
10f6
7f01
10f7
03d2
    set push, STR_UNDERSCORE
parser.dasm16
2350
1
10f8
0301
    set push, a
parser.dasm16
2351
2
10f9
7c20
10fa
2f54
    jsr dict__set
parser.dasm16
2352
0

parser.dasm16
2353
2
10fb
5461
10fc
ffff
    set x, [z-1]
parser.dasm16
2354
2
10fd
7f81
10fe
2026
    set pc, postamble
parser.dasm16
2355
0

parser.dasm16
2356
0
    
parser.dasm16
2357
0
;----------------------------------------------------------------
parser.dasm16
2358
0
:built_in__list_append
parser.dasm16
2359
0
;----------------------------------------------------------------
parser.dasm16
2360
2
10ff
7c20
1100
10e2
    jsr built_in__object_method__init
parser.dasm16
2361
0

parser.dasm16
2362
1
1101
88d3
    ifn i, 1
parser.dasm16
2363
2
1102
7c20
1103
00c6
        jsr recover
parser.dasm16
2364
0

parser.dasm16
2365
1
1104
0301
    set push, a
parser.dasm16
2366
2
1105
5701
1106
ffff
    set push, [z-1]
parser.dasm16
2367
2
1107
7c20
1108
27d8
    jsr array__append
parser.dasm16
2368
0

parser.dasm16
2369
1
1109
0061
    set x, a
parser.dasm16
2370
2
110a
7f81
110b
2026
    set pc, postamble
parser.dasm16
2371
0

parser.dasm16
2372
0
;----------------------------------------------------------------
parser.dasm16
2373
0
:built_in__list_insert
parser.dasm16
2374
0
;----------------------------------------------------------------
parser.dasm16
2375
2
110c
7c20
110d
10e2
    jsr built_in__object_method__init
parser.dasm16
2376
1
110e
8cd3
    ifn i, 2
parser.dasm16
2377
2
110f
7c20
1110
00c6
        jsr recover
parser.dasm16
2378
0

parser.dasm16
2379
2
1111
5701
1112
ffff
    set push, [z-1]        ; struct handle *index
parser.dasm16
2380
2
1113
7c20
1114
22bc
    jsr int_to_int16
parser.dasm16
2381
0

parser.dasm16
2382
1
1115
0301
    set push, a
parser.dasm16
2383
1
1116
0f01
    set push, x
parser.dasm16
2384
2
1117
5701
1118
fffe
    set push, [z-2]
parser.dasm16
2385
2
1119
7c20
111a
27b5
    jsr array__insert
parser.dasm16
2386
0

parser.dasm16
2387
1
111b
0061
    set x, a
parser.dasm16
2388
2
111c
7f81
111d
2026
    set pc, postamble
parser.dasm16
2389
0

parser.dasm16
2390
0
;----------------------------------------------------------------
parser.dasm16
2391
0
:built_in_id
parser.dasm16
2392
0
;----------------------------------------------------------------
parser.dasm16
2393
2
111e
7c20
111f
1542
    jsr built_in_params
parser.dasm16
2394
1
1120
88d3
    ifn i, 1
parser.dasm16
2395
2
1121
7c20
1122
00c6
        jsr recover
parser.dasm16
2396
0
        
parser.dasm16
2397
2
1123
5701
1124
ffff
    set push, [z-1]
parser.dasm16
2398
2
1125
7c20
1126
22a2
    jsr uint16_to_int
parser.dasm16
2399
0

parser.dasm16
2400
2
1127
7f81
1128
2026
    set pc, postamble
parser.dasm16
2401
0

parser.dasm16
2402
0
;----------------------------------------------------------------
parser.dasm16
2403
0
:built_in_input
parser.dasm16
2404
0
;----------------------------------------------------------------
parser.dasm16
2405
2
1129
7c20
112a
1542
    jsr built_in_params
parser.dasm16
2406
0

parser.dasm16
2407
1
112b
88d4
    ifg i, 1
parser.dasm16
2408
2
112c
7c20
112d
00c6
        jsr recover
parser.dasm16
2409
0

parser.dasm16
2410
2
112e
5701
112f
ffff
    set push, [z-1]
parser.dasm16
2411
2
1130
7c20
1131
211a
    jsr raw_input
parser.dasm16
2412
2
1132
0ea1
1133
ffff
    set [z-1], x
parser.dasm16
2413
0

parser.dasm16
2414
1
1134
2c01
    set a, [x]
parser.dasm16
2415
1
1135
8903
    sub [a], 1
parser.dasm16
2416
0

parser.dasm16
2417
1
1136
ac41
    set c, 10
parser.dasm16
2418
2
1137
7c20
1138
2ef4
    jsr screen_add_char
parser.dasm16
2419
0

parser.dasm16
2420
2
1139
5461
113a
ffff
    set x, [z-1]
parser.dasm16
2421
2
113b
7f81
113c
2026
    set pc, postamble
parser.dasm16
2422
0
    
parser.dasm16
2423
0
;----------------------------------------------------------------
parser.dasm16
2424
0
:built_in_range
parser.dasm16
2425
0
;----------------------------------------------------------------
parser.dasm16
2426
2
113d
7c20
113e
1542
    jsr built_in_params
parser.dasm16
2427
0

parser.dasm16
2428
1
113f
84d2
    ife i, 0
parser.dasm16
2429
2
1140
7c20
1141
00c6
        jsr recover
parser.dasm16
2430
0

parser.dasm16
2431
1
1142
88d4
    ifg i, 1
parser.dasm16
2432
2
1143
7f81
1144
114b
        set pc, built_in_range_2
parser.dasm16
2433
0

parser.dasm16
2434
3
1145
56a1
1146
ffff
1147
fffe
    set [z-2], [z-1]
parser.dasm16
2435
3
1148
7ea1
1149
02a3
114a
ffff
    set [z-1], INT_0
parser.dasm16
2436
0

parser.dasm16
2437
0
:built_in_range_2    
parser.dasm16
2438
1
114b
8cd4
    ifg i, 2
parser.dasm16
2439
2
114c
7f81
114d
1151
        set pc, built_in_range_3
parser.dasm16
2440
0

parser.dasm16
2441
3
114e
7ea1
114f
02a7
1150
fffd
    set [z-3], INT_1
parser.dasm16
2442
0

parser.dasm16
2443
0
:built_in_range_3
parser.dasm16
2444
1
1151
90d4
    ifg i, 3
parser.dasm16
2445
2
1152
7c20
1153
00c6
        jsr recover
parser.dasm16
2446
0

parser.dasm16
2447
2
1154
5701
1155
ffff
    set push, [z-1]
parser.dasm16
2448
2
1156
572b
1157
fffe
    bor [sp], [z-2]
parser.dasm16
2449
2
1158
572b
1159
fffd
    bor [sp], [z-3]
parser.dasm16
2450
2
115a
63f1
115b
ffcf
    ifc TYPE_GROUP_NON_INTEGER, pop
parser.dasm16
2451
2
115c
7c20
115d
00c6
        jsr recover
parser.dasm16
2452
0

parser.dasm16
2453
2
115e
5701
115f
fffd
    set push, [z-3]
parser.dasm16
2454
2
1160
7c20
1161
24df
    jsr int_sgn
parser.dasm16
2455
1
1162
0c81
    set y, x
parser.dasm16
2456
1
1163
808c
    xor y, 0xffff
parser.dasm16
2457
1
1164
8882
    add y, 1
parser.dasm16
2458
0

parser.dasm16
2459
1
1165
d701
    set push, 20
parser.dasm16
2460
1
1166
8f01
    set push, TYPE_LIST
parser.dasm16
2461
2
1167
7c20
1168
21d3
    jsr alloc
parser.dasm16
2462
2
1169
0ea1
116a
fffc
    set [z-4], x
parser.dasm16
2463
0

parser.dasm16
2464
0
:built_in_range_loop
parser.dasm16
2465
2
116b
5701
116c
ffff
    set push, [z-1]
parser.dasm16
2466
2
116d
5701
116e
fffe
    set push, [z-2]
parser.dasm16
2467
2
116f
7c20
1170
1dc0
    jsr val_cmp
parser.dasm16
2468
0
    
parser.dasm16
2469
1
1171
1073
    ifn x, y
parser.dasm16
2470
2
1172
7f81
1173
1184
        set pc, built_in_range_break
parser.dasm16
2471
0

parser.dasm16
2472
2
1174
5701
1175
fffc
    set push, [z-4]
parser.dasm16
2473
2
1176
5701
1177
ffff
    set push, [z-1]
parser.dasm16
2474
2
1178
7c20
1179
27d8
    jsr array__append
parser.dasm16
2475
0

parser.dasm16
2476
2
117a
5701
117b
ffff
    set push, [z-1]
parser.dasm16
2477
2
117c
5701
117d
fffd
    set push, [z-3]
parser.dasm16
2478
2
117e
7c20
117f
254d
    jsr int_add
parser.dasm16
2479
2
1180
0ea1
1181
ffff
    set [z-1], x
parser.dasm16
2480
0
    
parser.dasm16
2481
2
1182
7f81
1183
116b
    set pc, built_in_range_loop
parser.dasm16
2482
0

parser.dasm16
2483
0
:built_in_range_break
parser.dasm16
2484
2
1184
5461
1185
fffc
    set x, [z-4]
parser.dasm16
2485
2
1186
7f81
1187
2026
    set pc, postamble
parser.dasm16
2486
0

parser.dasm16
2487
0
;----------------------------------------------------------------
parser.dasm16
2488
0
:built_in_mem
parser.dasm16
2489
0
;----------------------------------------------------------------
parser.dasm16
2490
2
1188
7c20
1189
1542
    jsr built_in_params
parser.dasm16
2491
1
118a
84d3
    ifn i, 0
parser.dasm16
2492
2
118b
7c20
118c
00c6
        jsr recover
parser.dasm16
2493
0

parser.dasm16
2494
2
118d
7c20
118e
2237
    jsr mark
parser.dasm16
2495
2
118f
7c20
1190
2214
    jsr compact
parser.dasm16
2496
0

parser.dasm16
2497
2
1191
7801
1192
0255
    set a, [heap_handle_start]
parser.dasm16
2498
2
1193
7803
1194
0254
    sub a, [heap_free_start]
parser.dasm16
2499
0
    
parser.dasm16
2500
1
1195
0301
    set push, a
parser.dasm16
2501
2
1196
7c20
1197
22a2
    jsr uint16_to_int
parser.dasm16
2502
0

parser.dasm16
2503
2
1198
7f81
1199
2026
    set pc, postamble    
parser.dasm16
2504
0

parser.dasm16
2505
0
;----------------------------------------------------------------
parser.dasm16
2506
0
:built_in_exit
parser.dasm16
2507
0
;----------------------------------------------------------------
parser.dasm16
2508
0
; TODO
parser.dasm16
2509
2
119a
7c20
119b
00c6
    jsr recover
parser.dasm16
2510
0

parser.dasm16
2511
0
;----------------------------------------------------------------
parser.dasm16
2512
0
:built_in_locals
parser.dasm16
2513
0
;----------------------------------------------------------------
parser.dasm16
2514
2
119c
7c20
119d
1542
    jsr built_in_params
parser.dasm16
2515
1
119e
84d3
    ifn i, 0
parser.dasm16
2516
2
119f
7c20
11a0
00c6
        jsr recover
parser.dasm16
2517
0

parser.dasm16
2518
2
11a1
7861
11a2
0236
    set x, [current_scope]
parser.dasm16
2519
2
11a3
7f81
11a4
2026
    set pc, postamble    
parser.dasm16
2520
0

parser.dasm16
2521
0
;----------------------------------------------------------------
parser.dasm16
2522
0
:built_in_globals
parser.dasm16
2523
0
;----------------------------------------------------------------
parser.dasm16
2524
2
11a5
7c20
11a6
1542
    jsr built_in_params
parser.dasm16
2525
1
11a7
84d3
    ifn i, 0
parser.dasm16
2526
2
11a8
7c20
11a9
00c6
        jsr recover
parser.dasm16
2527
0

parser.dasm16
2528
2
11aa
7861
11ab
0235
    set x, [global_scope]
parser.dasm16
2529
2
11ac
7f81
11ad
2026
    set pc, postamble    
parser.dasm16
2530
0

parser.dasm16
2531
0
;----------------------------------------------------------------
parser.dasm16
2532
0
:built_in_cmp
parser.dasm16
2533
0
;----------------------------------------------------------------
parser.dasm16
2534
2
11ae
7c20
11af
1542
    jsr built_in_params
parser.dasm16
2535
1
11b0
8cd3
    ifn i, 2
parser.dasm16
2536
2
11b1
7c20
11b2
00c6
        jsr recover
parser.dasm16
2537
0

parser.dasm16
2538
2
11b3
5701
11b4
ffff
    set push, [z-1]
parser.dasm16
2539
2
11b5
5701
11b6
fffe
    set push, [z-2]
parser.dasm16
2540
2
11b7
7c20
11b8
1dc0
    jsr val_cmp
parser.dasm16
2541
1
11b9
0c01
    set a, x
parser.dasm16
2542
0
    
parser.dasm16
2543
2
11ba
7c61
11bb
02a3
    set x, INT_0
parser.dasm16
2544
1
11bc
8012
    ife a, -1
parser.dasm16
2545
2
11bd
7c61
11be
029f
        set x, INT_N1
parser.dasm16
2546
1
11bf
8812
    ife a, 1
parser.dasm16
2547
2
11c0
7c61
11c1
02a7
        set x, INT_1
parser.dasm16
2548
0
    
parser.dasm16
2549
2
11c2
7f81
11c3
2026
    set pc, postamble
parser.dasm16
2550
0

parser.dasm16
2551
0
;----------------------------------------------------------------
parser.dasm16
2552
0
:built_in_chr
parser.dasm16
2553
0
;----------------------------------------------------------------
parser.dasm16
2554
2
11c4
7c20
11c5
1542
    jsr built_in_params
parser.dasm16
2555
1
11c6
88d3
    ifn i, 1
parser.dasm16
2556
2
11c7
7c20
11c8
00c6
        jsr recover
parser.dasm16
2557
0

parser.dasm16
2558
2
11c9
5401
11ca
ffff
    set a, [z-1]
parser.dasm16
2559
3
11cb
7e11
11cc
0030
11cd
0001
    ifc [a + HANDLE_TYPE], TYPE_GROUP_INTEGER
parser.dasm16
2560
2
11ce
7c20
11cf
00c6
        jsr recover
parser.dasm16
2561
0

parser.dasm16
2562
1
11d0
2001
    set a, [a]
parser.dasm16
2563
1
11d1
2002
    add a, [a]
parser.dasm16
2564
0

parser.dasm16
2565
1
11d2
8b01
    set push, 1
parser.dasm16
2566
1
11d3
a701
    set push, TYPE_STR
parser.dasm16
2567
2
11d4
7c20
11d5
2770
    jsr array_create
parser.dasm16
2568
0
    
parser.dasm16
2569
1
11d6
2cde
    sti i, [x]
parser.dasm16
2570
1
11d7
21c1
    set [i], [a]
parser.dasm16
2571
0

parser.dasm16
2572
2
11d8
7f81
11d9
2026
    set pc, postamble    
parser.dasm16
2573
0

parser.dasm16
2574
0
;----------------------------------------------------------------
parser.dasm16
2575
0
:built_in_ord
parser.dasm16
2576
0
;----------------------------------------------------------------
parser.dasm16
2577
2
11da
7c20
11db
1542
    jsr built_in_params
parser.dasm16
2578
1
11dc
88d3
    ifn i, 1
parser.dasm16
2579
2
11dd
7c20
11de
00c6
        jsr recover
parser.dasm16
2580
0

parser.dasm16
2581
2
11df
5401
11e0
ffff
    set a, [z-1]
parser.dasm16
2582
2
11e1
a613
11e2
0001
    ifn [a + HANDLE_TYPE], TYPE_STR
parser.dasm16
2583
2
11e3
7c20
11e4
00c6
        jsr recover
parser.dasm16
2584
0

parser.dasm16
2585
1
11e5
2001
    set a, [a]
parser.dasm16
2586
1
11e6
8913
    ifn [a], 1
parser.dasm16
2587
2
11e7
7c20
11e8
00c6
        jsr recover
parser.dasm16
2588
0

parser.dasm16
2589
2
11e9
4301
11ea
0001
    set push, [a+1]
parser.dasm16
2590
2
11eb
7c20
11ec
22a2
    jsr uint16_to_int
parser.dasm16
2591
0

parser.dasm16
2592
2
11ed
7f81
11ee
2026
    set pc, postamble    
parser.dasm16
2593
0

parser.dasm16
2594
0
;----------------------------------------------------------------
parser.dasm16
2595
0
:built_in_edit
parser.dasm16
2596
0
;----------------------------------------------------------------
parser.dasm16
2597
2
11ef
7c20
11f0
1542
    jsr built_in_params
parser.dasm16
2598
1
11f1
88d4
    ifg i, 1
parser.dasm16
2599
2
11f2
7c20
11f3
00c6
        jsr recover
parser.dasm16
2600
0

parser.dasm16
2601
2
11f4
5401
11f5
ffff
    set a, [z-1]
parser.dasm16
2602
1
11f6
84d2
    ife i, 0
parser.dasm16
2603
2
11f7
7c01
11f8
03fd
        set a, STR_EMPTY
parser.dasm16
2604
0

parser.dasm16
2605
2
11f9
a613
11fa
0001
    ifn [a + HANDLE_TYPE], TYPE_STR
parser.dasm16
2606
2
11fb
7c20
11fc
00c6
        jsr recover
parser.dasm16
2607
0

parser.dasm16
2608
1
11fd
0301
    set push, a
parser.dasm16
2609
2
11fe
7c20
11ff
2be1
    jsr edit_main
parser.dasm16
2610
0

parser.dasm16
2611
2
1200
7f81
1201
2026
    set pc, postamble    
parser.dasm16
2612
0

parser.dasm16
2613
0
;----------------------------------------------------------------
parser.dasm16
2614
0
:built_in_rnd
parser.dasm16
2615
0
;----------------------------------------------------------------
parser.dasm16
2616
2
1202
7c20
1203
1542
    jsr built_in_params
parser.dasm16
2617
1
1204
84d4
    ifg i, 0
parser.dasm16
2618
2
1205
7f81
1206
120d
        set pc, built_in_rnd_1
parser.dasm16
2619
0
        
parser.dasm16
2620
2
1207
7801
1208
030d
    set a, [FLOAT_0]
parser.dasm16
2621
2
1209
7821
120a
0313
    set b, [FLOAT_1]
parser.dasm16
2622
0
    
parser.dasm16
2623
2
120b
7f81
120c
122e
    set pc, built_in_rnd_finish
parser.dasm16
2624
0

parser.dasm16
2625
0
:built_in_rnd_1
parser.dasm16
2626
1
120d
88d4
    ifg i, 1
parser.dasm16
2627
2
120e
7f81
120f
1220
        set pc, built_in_rnd_2
parser.dasm16
2628
0

parser.dasm16
2629
2
1210
5421
1211
ffff
    set b, [z-1]
parser.dasm16
2630
2
1212
4441
1213
0001
    set c, [b + HANDLE_TYPE]
parser.dasm16
2631
0

parser.dasm16
2632
2
1214
7c51
1215
0070
    ifc c, TYPE_INT + TYPE_FLOAT + TYPE_BOOL
parser.dasm16
2633
2
1216
7c20
1217
00c6
        jsr recover
parser.dasm16
2634
0

parser.dasm16
2635
2
1218
7c01
1219
02a3
    set a, INT_0
parser.dasm16
2636
2
121a
7c52
121b
0040
    ife c, TYPE_FLOAT
parser.dasm16
2637
2
121c
7801
121d
030d
        set a, [FLOAT_0]
parser.dasm16
2638
0

parser.dasm16
2639
2
121e
7f81
121f
122e
    set pc, built_in_rnd_finish
parser.dasm16
2640
0

parser.dasm16
2641
0
:built_in_rnd_2
parser.dasm16
2642
2
1220
5401
1221
ffff
    set a, [z-1]
parser.dasm16
2643
2
1222
5421
1223
fffe
    set b, [z-2]
parser.dasm16
2644
0

parser.dasm16
2645
3
1224
7e11
1225
0070
1226
0001
    ifc [a + HANDLE_TYPE], TYPE_FLOAT + TYPE_INT + TYPE_BOOL
parser.dasm16
2646
2
1227
7c20
1228
00c6
        jsr recover
parser.dasm16
2647
3
1229
7e31
122a
0070
122b
0001
    ifc [b + HANDLE_TYPE], TYPE_FLOAT + TYPE_INT + TYPE_BOOL
parser.dasm16
2648
2
122c
7c20
122d
00c6
        jsr recover
parser.dasm16
2649
0

parser.dasm16
2650
0
:built_in_rnd_finish
parser.dasm16
2651
2
122e
7c20
122f
2007
    jsr cast_common_number_type
parser.dasm16
2652
0

parser.dasm16
2653
2
1230
7c81
1231
23b8
    set y, int_random
parser.dasm16
2654
3
1232
7e12
1233
0040
1234
0001
    ife [a + HANDLE_TYPE], TYPE_FLOAT
parser.dasm16
2655
2
1235
7c81
1236
180b
        set y, float__random
parser.dasm16
2656
0

parser.dasm16
2657
1
1237
0301
    set push, a
parser.dasm16
2658
1
1238
0701
    set push, b
parser.dasm16
2659
1
1239
1020
    jsr y    
parser.dasm16
2660
0

parser.dasm16
2661
2
123a
7f81
123b
2026
    set pc, postamble
parser.dasm16
2662
0

parser.dasm16
2663
0
;----------------------------------------------------------------
parser.dasm16
2664
0
:built_in_abs
parser.dasm16
2665
0
;----------------------------------------------------------------
parser.dasm16
2666
2
123c
7c20
123d
1542
    jsr built_in_params
parser.dasm16
2667
1
123e
88d3
    ifn i, 1
parser.dasm16
2668
2
123f
7c20
1240
00c6
        jsr recover
parser.dasm16
2669
0

parser.dasm16
2670
2
1241
5401
1242
ffff
    set a, [z-1]
parser.dasm16
2671
0

parser.dasm16
2672
1
1243
8481
    set y, 0
parser.dasm16
2673
0
    
parser.dasm16
2674
3
1244
7e10
1245
0030
1246
0001
    ifb [a + HANDLE_TYPE], TYPE_INT + TYPE_BOOL
parser.dasm16
2675
2
1247
7c81
1248
24ab
        set y, int_abs
parser.dasm16
2676
3
1249
7e10
124a
0040
124b
0001
    ifb [a + HANDLE_TYPE], TYPE_FLOAT
parser.dasm16
2677
2
124c
7c81
124d
158d
        set y, float__abs
parser.dasm16
2678
0

parser.dasm16
2679
1
124e
8492
    ife y, 0
parser.dasm16
2680
2
124f
7c20
1250
00c6
        jsr recover
parser.dasm16
2681
0

parser.dasm16
2682
1
1251
0301
    set push, a
parser.dasm16
2683
1
1252
1020
    jsr y
parser.dasm16
2684
0

parser.dasm16
2685
2
1253
7f81
1254
2026
    set pc, postamble    
parser.dasm16
2686
0

parser.dasm16
2687
0
;----------------------------------------------------------------
parser.dasm16
2688
0
:built_in_len
parser.dasm16
2689
0
;----------------------------------------------------------------
parser.dasm16
2690
2
1255
7c20
1256
1542
    jsr built_in_params
parser.dasm16
2691
1
1257
88d3
    ifn i, 1
parser.dasm16
2692
2
1258
7c20
1259
00c6
        jsr recover
parser.dasm16
2693
0

parser.dasm16
2694
2
125a
5401
125b
ffff
    set a, [z-1]
parser.dasm16
2695
3
125c
7e11
125d
080f
125e
0001
    ifc [a + HANDLE_TYPE], TYPE_NAME + TYPE_STR + TYPE_TUPLE + TYPE_DICT + TYPE_LIST
parser.dasm16
2696
2
125f
7c20
1260
00c6
        jsr recover
parser.dasm16
2697
0

parser.dasm16
2698
1
1261
2001
    set a, [a]
parser.dasm16
2699
0

parser.dasm16
2700
1
1262
2301
    set push, [a]
parser.dasm16
2701
2
1263
7c20
1264
22a2
    jsr uint16_to_int
parser.dasm16
2702
0

parser.dasm16
2703
2
1265
7f81
1266
2026
    set pc, postamble    
parser.dasm16
2704
0

parser.dasm16
2705
0
;----------------------------------------------------------------
parser.dasm16
2706
0
:built_in_type
parser.dasm16
2707
0
;----------------------------------------------------------------
parser.dasm16
2708
2
1267
7c20
1268
1542
    jsr built_in_params
parser.dasm16
2709
1
1269
88d3
    ifn i, 1
parser.dasm16
2710
2
126a
7c20
126b
00c6
        jsr recover
parser.dasm16
2711
0

parser.dasm16
2712
2
126c
5461
126d
ffff
    set x, [z-1]
parser.dasm16
2713
2
126e
4f01
126f
0001
    set push, [x + HANDLE_TYPE]
parser.dasm16
2714
2
1270
7c20
1271
22a2
    jsr uint16_to_int
parser.dasm16
2715
0

parser.dasm16
2716
2
1272
7f81
1273
2026
    set pc, postamble    
parser.dasm16
2717
0

parser.dasm16
2718
0
;----------------------------------------------------------------
parser.dasm16
2719
0
:built_in_dir
parser.dasm16
2720
0
;----------------------------------------------------------------
parser.dasm16
2721
2
1274
7c20
1275
1542
    jsr built_in_params
parser.dasm16
2722
1
1276
84d3
    ifn i, 0
parser.dasm16
2723
2
1277
7c20
1278
00c6
        jsr recover
parser.dasm16
2724
0

parser.dasm16
2725
2
1279
7c20
127a
3058
    jsr floppy__dir__read
parser.dasm16
2726
0

parser.dasm16
2727
2
127b
7f81
127c
2026
    set pc, postamble    
parser.dasm16
2728
0

parser.dasm16
2729
0
;----------------------------------------------------------------
parser.dasm16
2730
0
:built_in_format
parser.dasm16
2731
0
;----------------------------------------------------------------
parser.dasm16
2732
2
127d
7c20
127e
1542
    jsr built_in_params
parser.dasm16
2733
1
127f
84d3
    ifn i, 0
parser.dasm16
2734
2
1280
7c20
1281
00c6
        jsr recover
parser.dasm16
2735
0

parser.dasm16
2736
2
1282
7c20
1283
3028
    jsr floppy__format
parser.dasm16
2737
0

parser.dasm16
2738
2
1284
7c61
1285
029d
    set x, VOID
parser.dasm16
2739
2
1286
7f81
1287
2026
    set pc, postamble    
parser.dasm16
2740
0

parser.dasm16
2741
0
;----------------------------------------------------------------
parser.dasm16
2742
0
:built_in_load
parser.dasm16
2743
0
;----------------------------------------------------------------
parser.dasm16
2744
2
1288
7c20
1289
1542
    jsr built_in_params
parser.dasm16
2745
1
128a
88d3
    ifn i, 1
parser.dasm16
2746
2
128b
7c20
128c
00c6
        jsr recover
parser.dasm16
2747
0

parser.dasm16
2748
2
128d
5401
128e
ffff
    set a, [z-1]
parser.dasm16
2749
2
128f
a611
1290
0001
    ifc [a + HANDLE_TYPE], TYPE_STR
parser.dasm16
2750
2
1291
7c20
1292
00c6
        jsr recover
parser.dasm16
2751
0

parser.dasm16
2752
1
1293
0301
    set push, a
parser.dasm16
2753
2
1294
7c20
1295
3094
    jsr floppy__file__read
parser.dasm16
2754
0

parser.dasm16
2755
2
1296
7f81
1297
2026
    set pc, postamble    
parser.dasm16
2756
0

parser.dasm16
2757
0
;----------------------------------------------------------------
parser.dasm16
2758
0
:built_in_save
parser.dasm16
2759
0
;----------------------------------------------------------------
parser.dasm16
2760
2
1298
7c20
1299
1542
    jsr built_in_params
parser.dasm16
2761
1
129a
8cd3
    ifn i, 2
parser.dasm16
2762
2
129b
7c20
129c
00c6
        jsr recover
parser.dasm16
2763
0

parser.dasm16
2764
2
129d
5401
129e
ffff
    set a, [z-1]
parser.dasm16
2765
2
129f
a611
12a0
0001
    ifc [a + HANDLE_TYPE], TYPE_STR
parser.dasm16
2766
2
12a1
7c20
12a2
00c6
        jsr recover
parser.dasm16
2767
0

parser.dasm16
2768
1
12a3
0301
    set push, a
parser.dasm16
2769
2
12a4
5701
12a5
fffe
    set push, [z-2]
parser.dasm16
2770
2
12a6
7c20
12a7
3061
    jsr floppy__file__write
parser.dasm16
2771
0

parser.dasm16
2772
2
12a8
7c61
12a9
029d
    set x, VOID
parser.dasm16
2773
2
12aa
7f81
12ab
2026
    set pc, postamble    
parser.dasm16
2774
0

parser.dasm16
2775
0
;----------------------------------------------------------------
parser.dasm16
2776
0
:built_in_rm
parser.dasm16
2777
0
;----------------------------------------------------------------
parser.dasm16
2778
2
12ac
7c20
12ad
1542
    jsr built_in_params
parser.dasm16
2779
1
12ae
88d3
    ifn i, 1
parser.dasm16
2780
2
12af
7c20
12b0
00c6
        jsr recover
parser.dasm16
2781
0

parser.dasm16
2782
2
12b1
5401
12b2
ffff
    set a, [z-1]
parser.dasm16
2783
2
12b3
a611
12b4
0001
    ifc [a + HANDLE_TYPE], TYPE_STR
parser.dasm16
2784
2
12b5
7c20
12b6
00c6
        jsr recover
parser.dasm16
2785
0

parser.dasm16
2786
1
12b7
0301
    set push, a
parser.dasm16
2787
2
12b8
7c20
12b9
30b1
    jsr floppy__file__delete
parser.dasm16
2788
0

parser.dasm16
2789
2
12ba
7f81
12bb
2026
    set pc, postamble    
parser.dasm16
2790
0

parser.dasm16
2791
0
;----------------------------------------------------------------
parser.dasm16
2792
0
:built_in_int
parser.dasm16
2793
0
;----------------------------------------------------------------
parser.dasm16
2794
2
12bc
7c20
12bd
1542
    jsr built_in_params
parser.dasm16
2795
1
12be
88d3
    ifn i, 1
parser.dasm16
2796
2
12bf
7c20
12c0
00c6
        jsr recover
parser.dasm16
2797
0

parser.dasm16
2798
2
12c1
5401
12c2
ffff
    set a, [z-1]
parser.dasm16
2799
0

parser.dasm16
2800
3
12c3
7e12
12c4
0020
12c5
0001
    ife [a + HANDLE_TYPE], TYPE_INT
parser.dasm16
2801
2
12c6
7f81
12c7
12d7
        set pc, built_in_int_int
parser.dasm16
2802
2
12c8
c612
12c9
0001
    ife [a + HANDLE_TYPE], TYPE_BOOL
parser.dasm16
2803
2
12ca
7f81
12cb
12da
        set pc, built_in_int_bool
parser.dasm16
2804
2
12cc
a612
12cd
0001
    ife [a + HANDLE_TYPE], TYPE_STR
parser.dasm16
2805
2
12ce
7f81
12cf
12e4
        set pc, built_in_int_string
parser.dasm16
2806
3
12d0
7e12
12d1
0040
12d2
0001
    ife [a + HANDLE_TYPE], TYPE_FLOAT
parser.dasm16
2807
2
12d3
7f81
12d4
12e9
        set pc, built_in_int_float
parser.dasm16
2808
0

parser.dasm16
2809
2
12d5
7c20
12d6
00c6
    jsr recover
parser.dasm16
2810
0

parser.dasm16
2811
0
:built_in_int_int
parser.dasm16
2812
1
12d7
0061
    set x, a
parser.dasm16
2813
2
12d8
7f81
12d9
2026
    set pc, postamble
parser.dasm16
2814
0

parser.dasm16
2815
0
:built_in_int_bool
parser.dasm16
2816
2
12da
7c12
12db
02e7
    ife a, BOOL_FALSE
parser.dasm16
2817
2
12dc
7c61
12dd
02a3
        set x, INT_0
parser.dasm16
2818
2
12de
7c12
12df
02e9
    ife a, BOOL_TRUE
parser.dasm16
2819
2
12e0
7c61
12e1
02a7
        set x, INT_1
parser.dasm16
2820
2
12e2
7f81
12e3
2026
    set pc, postamble
parser.dasm16
2821
0

parser.dasm16
2822
0
:built_in_int_string
parser.dasm16
2823
1
12e4
0301
    set push, a
parser.dasm16
2824
2
12e5
7c20
12e6
22c3
    jsr int_parse
parser.dasm16
2825
2
12e7
7f81
12e8
2026
    set pc, postamble
parser.dasm16
2826
0

parser.dasm16
2827
0
:built_in_int_float
parser.dasm16
2828
1
12e9
0301
    set push, a
parser.dasm16
2829
2
12ea
7c20
12eb
179f
    jsr float__to_int
parser.dasm16
2830
2
12ec
7f81
12ed
2026
    set pc, postamble
parser.dasm16
2831
0

parser.dasm16
2832
0
;----------------------------------------------------------------
parser.dasm16
2833
0
:built_in_float
parser.dasm16
2834
0
;----------------------------------------------------------------
parser.dasm16
2835
2
12ee
7c20
12ef
1542
    jsr built_in_params
parser.dasm16
2836
1
12f0
88d3
    ifn i, 1
parser.dasm16
2837
2
12f1
7c20
12f2
00c6
        jsr recover
parser.dasm16
2838
0

parser.dasm16
2839
2
12f3
5401
12f4
ffff
    set a, [z-1]
parser.dasm16
2840
0

parser.dasm16
2841
3
12f5
7e12
12f6
0020
12f7
0001
    ife [a + HANDLE_TYPE], TYPE_INT
parser.dasm16
2842
2
12f8
7f81
12f9
1309
        set pc, built_in_float_int
parser.dasm16
2843
2
12fa
c612
12fb
0001
    ife [a + HANDLE_TYPE], TYPE_BOOL
parser.dasm16
2844
2
12fc
7f81
12fd
130e
        set pc, built_in_float_bool
parser.dasm16
2845
2
12fe
a612
12ff
0001
    ife [a + HANDLE_TYPE], TYPE_STR
parser.dasm16
2846
2
1300
7f81
1301
1318
        set pc, built_in_float_string
parser.dasm16
2847
3
1302
7e12
1303
0040
1304
0001
    ife [a + HANDLE_TYPE], TYPE_FLOAT
parser.dasm16
2848
2
1305
7f81
1306
131d
        set pc, built_in_float_float
parser.dasm16
2849
0

parser.dasm16
2850
2
1307
7c20
1308
00c6
    jsr recover
parser.dasm16
2851
0

parser.dasm16
2852
0
:built_in_float_int
parser.dasm16
2853
1
1309
0301
    set push, a
parser.dasm16
2854
2
130a
7c20
130b
1757
    jsr float__from_int
parser.dasm16
2855
2
130c
7f81
130d
2026
    set pc, postamble
parser.dasm16
2856
0

parser.dasm16
2857
0
:built_in_float_bool
parser.dasm16
2858
2
130e
7c12
130f
02e7
    ife a, BOOL_FALSE
parser.dasm16
2859
2
1310
7861
1311
030d
        set x, [FLOAT_0]
parser.dasm16
2860
2
1312
7c12
1313
02e9
    ife a, BOOL_TRUE
parser.dasm16
2861
2
1314
7861
1315
0313
        set x, [FLOAT_1]
parser.dasm16
2862
2
1316
7f81
1317
2026
    set pc, postamble
parser.dasm16
2863
0

parser.dasm16
2864
0
:built_in_float_string
parser.dasm16
2865
1
1318
0301
    set push, a
parser.dasm16
2866
2
1319
7c20
131a
1887
    jsr float__from_str
parser.dasm16
2867
2
131b
7f81
131c
2026
    set pc, postamble
parser.dasm16
2868
0

parser.dasm16
2869
0
:built_in_float_float
parser.dasm16
2870
1
131d
0061
    set x, a
parser.dasm16
2871
2
131e
7f81
131f
2026
    set pc, postamble
parser.dasm16
2872
0
    
parser.dasm16
2873
0
;----------------------------------------------------------------
parser.dasm16
2874
0
:built_in_repr
parser.dasm16
2875
0
;----------------------------------------------------------------
parser.dasm16
2876
2
1320
7c20
1321
1542
    jsr built_in_params
parser.dasm16
2877
1
1322
88d3
    ifn i, 1
parser.dasm16
2878
2
1323
7c20
1324
00c6
        jsr recover
parser.dasm16
2879
0

parser.dasm16
2880
2
1325
5701
1326
ffff
    set push, [z-1]
parser.dasm16
2881
2
1327
7c20
1328
2086
    jsr repr
parser.dasm16
2882
2
1329
0ea1
132a
ffff
    set [z-1], x
parser.dasm16
2883
0
    
parser.dasm16
2884
2
132b
7f81
132c
2026
    set pc, postamble
parser.dasm16
2885
0

parser.dasm16
2886
0
;----------------------------------------------------------------
parser.dasm16
2887
0
:built_in_hex
parser.dasm16
2888
0
;----------------------------------------------------------------
parser.dasm16
2889
2
132d
7c20
132e
1542
    jsr built_in_params
parser.dasm16
2890
1
132f
88d3
    ifn i, 1
parser.dasm16
2891
2
1330
7c20
1331
00c6
        jsr recover
parser.dasm16
2892
0

parser.dasm16
2893
2
1332
5461
1333
ffff
    set x, [z-1]
parser.dasm16
2894
0

parser.dasm16
2895
3
1334
7e73
1335
0020
1336
0001
    ifn [x + HANDLE_TYPE], TYPE_INT
parser.dasm16
2896
2
1337
7c20
1338
00c6
        jsr recover
parser.dasm16
2897
0

parser.dasm16
2898
1
1339
0f01
    set push, x
parser.dasm16
2899
2
133a
7c20
133b
2369
    jsr int_to_hex
parser.dasm16
2900
0

parser.dasm16
2901
2
133c
7f81
133d
2026
    set pc, postamble
parser.dasm16
2902
0

parser.dasm16
2903
0
;----------------------------------------------------------------
parser.dasm16
2904
0
:built_in_str
parser.dasm16
2905
0
;----------------------------------------------------------------
parser.dasm16
2906
2
133e
7c20
133f
1542
    jsr built_in_params
parser.dasm16
2907
1
1340
88d3
    ifn i, 1
parser.dasm16
2908
2
1341
7c20
1342
00c6
        jsr recover
parser.dasm16
2909
0

parser.dasm16
2910
2
1343
5461
1344
ffff
    set x, [z-1]
parser.dasm16
2911
0

parser.dasm16
2912
2
1345
a672
1346
0001
    ife [x + HANDLE_TYPE], TYPE_STR
parser.dasm16
2913
2
1347
7f81
1348
2026
        set pc, postamble
parser.dasm16
2914
0

parser.dasm16
2915
1
1349
0f01
    set push, x
parser.dasm16
2916
2
134a
7c20
134b
2086
    jsr repr
parser.dasm16
2917
0

parser.dasm16
2918
2
134c
7f81
134d
2026
    set pc, postamble
parser.dasm16
2919
0

parser.dasm16
2920
0
;----------------------------------------------------------------
parser.dasm16
2921
0
:built_in_bool
parser.dasm16
2922
0
;----------------------------------------------------------------
parser.dasm16
2923
2
134e
7c20
134f
1542
    jsr built_in_params
parser.dasm16
2924
1
1350
88d3
    ifn i, 1
parser.dasm16
2925
2
1351
7c20
1352
00c6
        jsr recover
parser.dasm16
2926
0

parser.dasm16
2927
2
1353
5701
1354
ffff
    set push, [z-1]
parser.dasm16
2928
2
1355
7c20
1356
1ea9
    jsr boolean
parser.dasm16
2929
0

parser.dasm16
2930
2
1357
7f81
1358
2026
    set pc, postamble
parser.dasm16
2931
0

parser.dasm16
2932
0
;----------------------------------------------------------------
parser.dasm16
2933
0
:built_in_getchar
parser.dasm16
2934
0
;----------------------------------------------------------------
parser.dasm16
2935
2
1359
7c20
135a
1542
    jsr built_in_params
parser.dasm16
2936
1
135b
84d3
    ifn i, 0
parser.dasm16
2937
2
135c
7c20
135d
00c6
        jsr recover
parser.dasm16
2938
0

parser.dasm16
2939
0
:built_in_getchar_loop
parser.dasm16
2940
1
135e
8801
    set a, 1              ; store next key mode
parser.dasm16
2941
2
135f
7a40
1360
024f
    hwi [keyboard]
parser.dasm16
2942
0

parser.dasm16
2943
1
1361
8452
    ife c, 0
parser.dasm16
2944
2
1362
7f81
1363
135e
        set pc, built_in_getchar_loop
parser.dasm16
2945
0

parser.dasm16
2946
1
1364
8b01
    set push, 1
parser.dasm16
2947
1
1365
a701
    set push, TYPE_STR
parser.dasm16
2948
2
1366
7c20
1367
2770
    jsr array_create
parser.dasm16
2949
0
    
parser.dasm16
2950
1
1368
2cde
    sti i, [x]
parser.dasm16
2951
1
1369
09c1
    set [i], c
parser.dasm16
2952
0

parser.dasm16
2953
2
136a
7f81
136b
2026
    set pc, postamble    
parser.dasm16
2954
0

parser.dasm16
2955
0
;----------------------------------------------------------------
parser.dasm16
2956
0
:built_in_key
parser.dasm16
2957
0
;----------------------------------------------------------------
parser.dasm16
2958
2
136c
7c20
136d
1542
    jsr built_in_params
parser.dasm16
2959
1
136e
88d2
    ife i, 1
parser.dasm16
2960
2
136f
7f81
1370
1381
        set pc, built_in_key_1
parser.dasm16
2961
0
    
parser.dasm16
2962
1
1371
84d3
    ifn i, 0
parser.dasm16
2963
2
1372
7c20
1373
00c6
        jsr recover
parser.dasm16
2964
0

parser.dasm16
2965
1
1374
8801
    set a, 1              ; store next key mode
parser.dasm16
2966
2
1375
7a40
1376
024f
    hwi [keyboard]
parser.dasm16
2967
0
    
parser.dasm16
2968
2
1377
7c61
1378
02a3
    set x, INT_0
parser.dasm16
2969
1
1379
8452
    ife c, 0
parser.dasm16
2970
2
137a
7f81
137b
2026
        set pc, postamble 
parser.dasm16
2971
0

parser.dasm16
2972
1
137c
0b01
    set push, c
parser.dasm16
2973
2
137d
7c20
137e
22a2
    jsr uint16_to_int
parser.dasm16
2974
0

parser.dasm16
2975
2
137f
7f81
1380
2026
    set pc, postamble
parser.dasm16
2976
0

parser.dasm16
2977
0
:built_in_key_1
parser.dasm16
2978
2
1381
5401
1382
ffff
    set a, [z-1]
parser.dasm16
2979
3
1383
7e10
1384
0030
1385
0001
    ifb [a + HANDLE_TYPE], TYPE_INT + TYPE_BOOL
parser.dasm16
2980
2
1386
7f81
1387
1394
        set pc, built_in_key_1_int
parser.dasm16
2981
0
        
parser.dasm16
2982
2
1388
a613
1389
0001
    ifn [a + HANDLE_TYPE], TYPE_STR
parser.dasm16
2983
2
138a
7c20
138b
00c6
        jsr recover
parser.dasm16
2984
0
        
parser.dasm16
2985
1
138c
2001
    set a, [a]
parser.dasm16
2986
1
138d
8913
    ifn [a], 1
parser.dasm16
2987
2
138e
7c20
138f
00c6
        jsr recover
parser.dasm16
2988
0

parser.dasm16
2989
2
1390
4021
1391
0001
    set b, [a + 1]
parser.dasm16
2990
2
1392
7f81
1393
1398
    set pc, built_in_key_1_key
parser.dasm16
2991
0

parser.dasm16
2992
0
:built_in_key_1_int
parser.dasm16
2993
1
1394
0301
    set push, a
parser.dasm16
2994
2
1395
7c20
1396
22bc
    jsr int_to_int16
parser.dasm16
2995
1
1397
0c21
    set b, x
parser.dasm16
2996
0

parser.dasm16
2997
0
:built_in_key_1_key
parser.dasm16
2998
1
1398
8c01
    set a, 2              ; store next key mode
parser.dasm16
2999
2
1399
7a40
139a
024f
    hwi [keyboard]
parser.dasm16
3000
0
    
parser.dasm16
3001
2
139b
7c61
139c
02e9
    set x, BOOL_TRUE
parser.dasm16
3002
1
139d
8452
    ife c, 0
parser.dasm16
3003
2
139e
7c61
139f
02e7
        set x, BOOL_FALSE
parser.dasm16
3004
0

parser.dasm16
3005
2
13a0
7f81
13a1
2026
    set pc, postamble
parser.dasm16
3006
0

parser.dasm16
3007
0
;----------------------------------------------------------------
parser.dasm16
3008
0
:built_in_sort
parser.dasm16
3009
0
;----------------------------------------------------------------
parser.dasm16
3010
2
13a2
7c20
13a3
1542
    jsr built_in_params
parser.dasm16
3011
1
13a4
88d4
    ifg i, 1
parser.dasm16
3012
2
13a5
7c20
13a6
13af
        jsr built_in_sort_2
parser.dasm16
3013
0

parser.dasm16
3014
2
13a7
5701
13a8
ffff
    set push, [z-1]
parser.dasm16
3015
2
13a9
7f01
13aa
02e7
    set push, BOOL_FALSE
parser.dasm16
3016
2
13ab
7c20
13ac
1ee1
    jsr sort
parser.dasm16
3017
0
    
parser.dasm16
3018
2
13ad
7f81
13ae
2026
    set pc, postamble
parser.dasm16
3019
0

parser.dasm16
3020
0
:built_in_sort_2
parser.dasm16
3021
1
13af
8cd4
    ifg i, 2
parser.dasm16
3022
2
13b0
7c20
13b1
00c6
        jsr recover
parser.dasm16
3023
0
    
parser.dasm16
3024
2
13b2
5701
13b3
ffff
    set push, [z-1]
parser.dasm16
3025
2
13b4
5701
13b5
fffe
    set push, [z-2]
parser.dasm16
3026
2
13b6
7c20
13b7
1ee1
    jsr sort
parser.dasm16
3027
0

parser.dasm16
3028
2
13b8
7f81
13b9
2026
    set pc, postamble
parser.dasm16
3029
0

parser.dasm16
3030
0
;----------------------------------------------------------------
parser.dasm16
3031
0
:built_in_cursor
parser.dasm16
3032
0
;----------------------------------------------------------------
parser.dasm16
3033
2
13ba
7c20
13bb
1542
    jsr built_in_params
parser.dasm16
3034
1
13bc
84d2
    ife i, 0
parser.dasm16
3035
2
13bd
7f81
13be
13ca
        set pc, built_in_cursor_coords
parser.dasm16
3036
1
13bf
8cd3
    ifn i, 2
parser.dasm16
3037
2
13c0
7c20
13c1
00c6
        jsr recover
parser.dasm16
3038
0

parser.dasm16
3039
2
13c2
7c20
13c3
13ce
    jsr screen__get_x
parser.dasm16
3040
1
13c4
0f01
    set push, x
parser.dasm16
3041
0

parser.dasm16
3042
2
13c5
7c20
13c6
13e0
    jsr screen__get_y
parser.dasm16
3043
1
13c7
0f01
    set push, x
parser.dasm16
3044
0

parser.dasm16
3045
2
13c8
7c20
13c9
2e28
    jsr screen_move_cursor
parser.dasm16
3046
0
    
parser.dasm16
3047
0
:built_in_cursor_coords
parser.dasm16
3048
2
13ca
7c20
13cb
2ebe
    jsr screen__get_cursor
parser.dasm16
3049
0
    
parser.dasm16
3050
2
13cc
7f81
13cd
2026
    set pc, postamble
parser.dasm16
3051
0

parser.dasm16
3052
0
:screen__get_x
parser.dasm16
3053
2
13ce
5461
13cf
ffff
    set x, [z-1]
parser.dasm16
3054
3
13d0
7e71
13d1
0030
13d2
0001
    ifc [x + HANDLE_TYPE], TYPE_GROUP_INTEGER
parser.dasm16
3055
2
13d3
7c20
13d4
00c6
        jsr recover
parser.dasm16
3056
0
        
parser.dasm16
3057
1
13d5
0f01
    set push, x
parser.dasm16
3058
2
13d6
7c20
13d7
22bc
    jsr int_to_int16
parser.dasm16
3059
0

parser.dasm16
3060
2
13d8
7c70
13d9
8000
    ifb x, 0x8000
parser.dasm16
3061
1
13da
8461
        set x, 0        
parser.dasm16
3062
2
13db
7c74
13dc
001f
    ifg x, SCREEN_COLS - 1
parser.dasm16
3063
2
13dd
7c61
13de
001f
        set x, SCREEN_COLS - 1
parser.dasm16
3064
0
        
parser.dasm16
3065
1
13df
6381
    set pc, pop
parser.dasm16
3066
0

parser.dasm16
3067
0
:screen__get_y
parser.dasm16
3068
2
13e0
5461
13e1
fffe
    set x, [z-2]
parser.dasm16
3069
3
13e2
7e71
13e3
0030
13e4
0001
    ifc [x + HANDLE_TYPE], TYPE_GROUP_INTEGER
parser.dasm16
3070
2
13e5
7c20
13e6
00c6
        jsr recover
parser.dasm16
3071
0
        
parser.dasm16
3072
1
13e7
0f01
    set push, x
parser.dasm16
3073
2
13e8
7c20
13e9
22bc
    jsr int_to_int16
parser.dasm16
3074
0

parser.dasm16
3075
2
13ea
7c70
13eb
8000
    ifb x, 0x8000
parser.dasm16
3076
1
13ec
8461
        set x, 0        
parser.dasm16
3077
1
13ed
b074
    ifg x, SCREEN_ROWS - 1
parser.dasm16
3078
1
13ee
b061
        set x, SCREEN_ROWS - 1
parser.dasm16
3079
0

parser.dasm16
3080
1
13ef
6381
    set pc, pop
parser.dasm16
3081
0

parser.dasm16
3082
0
;----------------------------------------------------------------
parser.dasm16
3083
0
:built_in_win_get
parser.dasm16
3084
0
;----------------------------------------------------------------
parser.dasm16
3085
2
13f0
7c20
13f1
1542
    jsr built_in_params
parser.dasm16
3086
1
13f2
8cd3
    ifn i, 2
parser.dasm16
3087
2
13f3
7c20
13f4
00c6
        jsr recover
parser.dasm16
3088
0

parser.dasm16
3089
2
13f5
7c20
13f6
13ce
    jsr screen__get_x
parser.dasm16
3090
1
13f7
0f01
    set push, x
parser.dasm16
3091
0

parser.dasm16
3092
2
13f8
7c20
13f9
13e0
    jsr screen__get_y
parser.dasm16
3093
1
13fa
0f01
    set push, x
parser.dasm16
3094
0

parser.dasm16
3095
2
13fb
7c20
13fc
2e97
    jsr screen__get
parser.dasm16
3096
1
13fd
0c41
    set c, x
parser.dasm16
3097
0

parser.dasm16
3098
1
13fe
8b01
    set push, 1
parser.dasm16
3099
1
13ff
a701
    set push, TYPE_STR
parser.dasm16
3100
2
1400
7c20
1401
2770
    jsr array_create
parser.dasm16
3101
0
    
parser.dasm16
3102
1
1402
2cde
    sti i, [x]
parser.dasm16
3103
1
1403
09c1
    set [i], c
parser.dasm16
3104
0

parser.dasm16
3105
2
1404
7f81
1405
2026
    set pc, postamble        
parser.dasm16
3106
0

parser.dasm16
3107
0
;----------------------------------------------------------------
parser.dasm16
3108
0
:built_in_win_set
parser.dasm16
3109
0
;----------------------------------------------------------------
parser.dasm16
3110
2
1406
7c20
1407
1542
    jsr built_in_params
parser.dasm16
3111
1
1408
90d3
    ifn i, 3
parser.dasm16
3112
2
1409
7c20
140a
00c6
        jsr recover
parser.dasm16
3113
0

parser.dasm16
3114
2
140b
7c20
140c
13ce
    jsr screen__get_x
parser.dasm16
3115
1
140d
0f01
    set push, x
parser.dasm16
3116
0

parser.dasm16
3117
2
140e
7c20
140f
13e0
    jsr screen__get_y
parser.dasm16
3118
1
1410
0f01
    set push, x
parser.dasm16
3119
0

parser.dasm16
3120
2
1411
5461
1412
fffd
    set x, [z-3]
parser.dasm16
3121
1
1413
2c61
    set x, [x]
parser.dasm16
3122
2
1414
4f01
1415
0001
    set push, [x+1]
parser.dasm16
3123
0

parser.dasm16
3124
2
1416
7c20
1417
2ea9
    jsr screen__set
parser.dasm16
3125
0

parser.dasm16
3126
2
1418
7c61
1419
029d
    set x, VOID
parser.dasm16
3127
2
141a
7f81
141b
2026
    set pc, postamble
parser.dasm16
3128
0

parser.dasm16
3129
0
;----------------------------------------------------------------
parser.dasm16
3130
0
:built_in_call
parser.dasm16
3131
0
;----------------------------------------------------------------
parser.dasm16
3132
2
141c
7c20
141d
1542
    jsr built_in_params
parser.dasm16
3133
0
    
parser.dasm16
3134
2
141e
7c61
141f
d980
    set x, MEM_FLOPPY_START
parser.dasm16
3135
1
1420
84d2
    ife i, 0
parser.dasm16
3136
2
1421
7f81
1422
1430
        set pc, built_in_call_registers
parser.dasm16
3137
0
    
parser.dasm16
3138
1
1423
88d3
    ifn i, 1
parser.dasm16
3139
2
1424
7c20
1425
00c6
        jsr recover
parser.dasm16
3140
0

parser.dasm16
3141
2
1426
5461
1427
ffff
    set x, [z-1]
parser.dasm16
3142
3
1428
7e73
1429
0020
142a
0001
    ifn [x + HANDLE_TYPE], TYPE_INT
parser.dasm16
3143
2
142b
7c20
142c
00c6
        jsr recover
parser.dasm16
3144
0

parser.dasm16
3145
1
142d
0f01
    set push, x
parser.dasm16
3146
2
142e
7c20
142f
22bc
    jsr int_to_int16
parser.dasm16
3147
0

parser.dasm16
3148
0
:built_in_call_registers
parser.dasm16
3149
1
1430
1701
    set push, z
parser.dasm16
3150
1
1431
0f01
    set push, x
parser.dasm16
3151
0

parser.dasm16
3152
2
1432
7c20
1433
1562
    jsr load_registers
parser.dasm16
3153
0

parser.dasm16
3154
1
1434
6020
    jsr pop
parser.dasm16
3155
0

parser.dasm16
3156
2
1435
7c20
1436
156d
    jsr save_registers
parser.dasm16
3157
0

parser.dasm16
3158
1
1437
60a1
    set z, pop
parser.dasm16
3159
2
1438
7c61
1439
029d
    set x, VOID
parser.dasm16
3160
2
143a
7f81
143b
2026
    set pc, postamble
parser.dasm16
3161
0

parser.dasm16
3162
0
;----------------------------------------------------------------
parser.dasm16
3163
0
:built_in_peek
parser.dasm16
3164
0
;----------------------------------------------------------------
parser.dasm16
3165
2
143c
7c20
143d
1542
    jsr built_in_params
parser.dasm16
3166
0

parser.dasm16
3167
2
143e
5461
143f
ffff
    set x, [z-1]
parser.dasm16
3168
3
1440
7e73
1441
0020
1442
0001
    ifn [x + HANDLE_TYPE], TYPE_INT
parser.dasm16
3169
2
1443
7c20
1444
00c6
        jsr recover
parser.dasm16
3170
0

parser.dasm16
3171
1
1445
0f01
    set push, x
parser.dasm16
3172
2
1446
7c20
1447
22bc
    jsr int_to_int16
parser.dasm16
3173
0

parser.dasm16
3174
1
1448
8cd2
    ife i, 2
parser.dasm16
3175
2
1449
7f81
144a
1453
        set pc, built_in_peek_str
parser.dasm16
3176
0
        
parser.dasm16
3177
1
144b
88d3
    ifn i, 1
parser.dasm16
3178
2
144c
7c20
144d
00c6
        jsr recover
parser.dasm16
3179
0

parser.dasm16
3180
1
144e
2f01
    set push, [x]
parser.dasm16
3181
2
144f
7c20
1450
22a2
    jsr uint16_to_int
parser.dasm16
3182
0

parser.dasm16
3183
2
1451
7f81
1452
2026
    set pc, postamble
parser.dasm16
3184
0

parser.dasm16
3185
0
:built_in_peek_str
parser.dasm16
3186
0
    ; x: UINT16 *from
parser.dasm16
3187
1
1453
0cc1
    set i, x
parser.dasm16
3188
0

parser.dasm16
3189
2
1454
5461
1455
fffe
    set x, [z-2]
parser.dasm16
3190
3
1456
7e73
1457
0020
1458
0001
    ifn [x + HANDLE_TYPE], TYPE_INT
parser.dasm16
3191
2
1459
7c20
145a
00c6
        jsr recover
parser.dasm16
3192
0

parser.dasm16
3193
1
145b
0f01
    set push, x
parser.dasm16
3194
2
145c
7c20
145d
22bc
    jsr int_to_int16
parser.dasm16
3195
1
145e
0cc2
    add i, x
parser.dasm16
3196
1
145f
88c3
    sub i, 1
parser.dasm16
3197
0

parser.dasm16
3198
1
1460
0f01
    set push, x
parser.dasm16
3199
1
1461
a701
    set push, TYPE_STR
parser.dasm16
3200
2
1462
7c20
1463
2770
    jsr array_create
parser.dasm16
3201
1
1464
2ce1
    set j, [x]
parser.dasm16
3202
1
1465
3ce2
    add j, [j]
parser.dasm16
3203
0

parser.dasm16
3204
0
:built_in_peek_str_loop
parser.dasm16
3205
1
1466
2cf2
    ife j, [x]
parser.dasm16
3206
2
1467
7f81
1468
2026
        set pc, postamble
parser.dasm16
3207
0

parser.dasm16
3208
1
1469
39ff
    std [j], [i]
parser.dasm16
3209
2
146a
7f81
146b
1466
    set pc, built_in_peek_str_loop
parser.dasm16
3210
0

parser.dasm16
3211
0
;----------------------------------------------------------------
parser.dasm16
3212
0
:built_in_poke
parser.dasm16
3213
0
;----------------------------------------------------------------
parser.dasm16
3214
2
146c
7c20
146d
1542
    jsr built_in_params
parser.dasm16
3215
1
146e
8cd3
    ifn i, 2
parser.dasm16
3216
2
146f
7c20
1470
00c6
        jsr recover
parser.dasm16
3217
0

parser.dasm16
3218
2
1471
5461
1472
ffff
    set x, [z-1]
parser.dasm16
3219
3
1473
7e73
1474
0020
1475
0001
    ifn [x + HANDLE_TYPE], TYPE_INT
parser.dasm16
3220
2
1476
7c20
1477
00c6
        jsr recover
parser.dasm16
3221
0

parser.dasm16
3222
1
1478
0f01
    set push, x
parser.dasm16
3223
2
1479
7c20
147a
22bc
    jsr int_to_int16
parser.dasm16
3224
1
147b
0ce1
    set j, x
parser.dasm16
3225
0

parser.dasm16
3226
2
147c
5461
147d
fffe
    set x, [z-2]
parser.dasm16
3227
2
147e
a672
147f
0001
    ife [x + HANDLE_TYPE], TYPE_STR
parser.dasm16
3228
2
1480
7f81
1481
148f
        set pc, built_in_poke_str
parser.dasm16
3229
0

parser.dasm16
3230
3
1482
7e73
1483
0020
1484
0001
    ifn [x + HANDLE_TYPE], TYPE_INT
parser.dasm16
3231
2
1485
7c20
1486
00c6
        jsr recover
parser.dasm16
3232
0

parser.dasm16
3233
1
1487
0f01
    set push, x
parser.dasm16
3234
2
1488
7c20
1489
22bc
    jsr int_to_int16
parser.dasm16
3235
1
148a
0de1
    set [j], x
parser.dasm16
3236
0
    
parser.dasm16
3237
2
148b
5461
148c
fffe
    set x, [z-2]
parser.dasm16
3238
2
148d
7f81
148e
2026
    set pc, postamble
parser.dasm16
3239
0

parser.dasm16
3240
0
:built_in_poke_str
parser.dasm16
3241
1
148f
2cc1
    set i, [x]
parser.dasm16
3242
1
1490
38e2
    add j, [i]
parser.dasm16
3243
1
1491
88e3
    sub j, 1
parser.dasm16
3244
1
1492
38c2
    add i, [i]
parser.dasm16
3245
0

parser.dasm16
3246
0
:built_in_poke_str_loop
parser.dasm16
3247
1
1493
2cd2
    ife i, [x]
parser.dasm16
3248
2
1494
7f81
1495
2026
        set pc, postamble
parser.dasm16
3249
0

parser.dasm16
3250
1
1496
39ff
    std [j], [i]
parser.dasm16
3251
2
1497
7f81
1498
1493
    set pc, built_in_poke_str_loop
parser.dasm16
3252
0
    
parser.dasm16
3253
0
;----------------------------------------------------------------
parser.dasm16
3254
0
:built_in_read
parser.dasm16
3255
0
;----------------------------------------------------------------
parser.dasm16
3256
1
1499
8421
    set b, 0
parser.dasm16
3257
2
149a
7f81
149b
149d
    set pc, built_in_read_and_write
parser.dasm16
3258
0
;----------------------------------------------------------------
parser.dasm16
3259
0
:built_in_write
parser.dasm16
3260
0
;----------------------------------------------------------------
parser.dasm16
3261
1
149c
8821
    set b, 1
parser.dasm16
3262
0

parser.dasm16
3263
0
:built_in_read_and_write
parser.dasm16
3264
2
149d
7c20
149e
1542
    jsr built_in_params
parser.dasm16
3265
1
149f
88d3
    ifn i, 1
parser.dasm16
3266
2
14a0
7c20
14a1
00c6
        jsr recover
parser.dasm16
3267
0

parser.dasm16
3268
0
    ; verify that first parameter is int
parser.dasm16
3269
2
14a2
5461
14a3
ffff
    set x, [z-1]
parser.dasm16
3270
3
14a4
7e73
14a5
0020
14a6
0001
    ifn [x + HANDLE_TYPE], TYPE_INT
parser.dasm16
3271
2
14a7
7c20
14a8
00c6
        jsr recover
parser.dasm16
3272
0

parser.dasm16
3273
0
    ; push first parameter value to stack
parser.dasm16
3274
1
14a9
0f01
    set push, x
parser.dasm16
3275
2
14aa
7c20
14ab
22bc
    jsr int_to_int16
parser.dasm16
3276
1
14ac
0f01
    set push, x
parser.dasm16
3277
0

parser.dasm16
3278
1
14ad
8432
    ife b, 0
parser.dasm16
3279
2
14ae
7c20
14af
312c
        jsr floppy__sector__read
parser.dasm16
3280
1
14b0
8832
    ife b, 1
parser.dasm16
3281
2
14b1
7c20
14b2
311d
        jsr floppy__sector__write
parser.dasm16
3282
0

parser.dasm16
3283
2
14b3
7f81
14b4
2026
    set pc, postamble
parser.dasm16
3284
0

parser.dasm16
3285
0
;----------------------------------------------------------------
parser.dasm16
3286
0
:built_in_hwn
parser.dasm16
3287
0
;----------------------------------------------------------------
parser.dasm16
3288
2
14b5
7c20
14b6
1542
    jsr built_in_params
parser.dasm16
3289
1
14b7
84d3
    ifn i, 0
parser.dasm16
3290
2
14b8
7c20
14b9
00c6
        jsr recover
parser.dasm16
3291
0

parser.dasm16
3292
1
14ba
0e00
    hwn x
parser.dasm16
3293
0

parser.dasm16
3294
1
14bb
0f01
    set push, x
parser.dasm16
3295
2
14bc
7c20
14bd
22a2
    jsr uint16_to_int
parser.dasm16
3296
0

parser.dasm16
3297
2
14be
7f81
14bf
2026
    set pc, postamble
parser.dasm16
3298
0

parser.dasm16
3299
0
;----------------------------------------------------------------
parser.dasm16
3300
0
:built_in_hwi
parser.dasm16
3301
0
;----------------------------------------------------------------
parser.dasm16
3302
2
14c0
7c20
14c1
1542
    jsr built_in_params
parser.dasm16
3303
0

parser.dasm16
3304
0
    ; verify two parameters
parser.dasm16
3305
1
14c2
88d3
    ifn i, 1
parser.dasm16
3306
2
14c3
7c20
14c4
00c6
        jsr recover
parser.dasm16
3307
0

parser.dasm16
3308
0
    ; verify that first parameter is int
parser.dasm16
3309
2
14c5
5461
14c6
ffff
    set x, [z-1]
parser.dasm16
3310
3
14c7
7e73
14c8
0020
14c9
0001
    ifn [x + HANDLE_TYPE], TYPE_INT
parser.dasm16
3311
2
14ca
7c20
14cb
00c6
        jsr recover
parser.dasm16
3312
0

parser.dasm16
3313
0
    ; push first parameter value to stack
parser.dasm16
3314
1
14cc
0f01
    set push, x
parser.dasm16
3315
2
14cd
7c20
14ce
22bc
    jsr int_to_int16
parser.dasm16
3316
1
14cf
0f01
    set push, x
parser.dasm16
3317
0

parser.dasm16
3318
2
14d0
7c20
14d1
1562
    jsr load_registers
parser.dasm16
3319
0

parser.dasm16
3320
1
14d2
6240
    hwi pop
parser.dasm16
3321
0

parser.dasm16
3322
2
14d3
7c20
14d4
156d
    jsr save_registers
parser.dasm16
3323
0

parser.dasm16
3324
2
14d5
7f81
14d6
2026
    set pc, postamble
parser.dasm16
3325
0

parser.dasm16
3326
0
;----------------------------------------------------------------
parser.dasm16
3327
0
:built_in_hwq
parser.dasm16
3328
0
;----------------------------------------------------------------
parser.dasm16
3329
2
14d7
7c20
14d8
1542
    jsr built_in_params
parser.dasm16
3330
1
14d9
88d3
    ifn i, 1
parser.dasm16
3331
2
14da
7c20
14db
00c6
        jsr recover
parser.dasm16
3332
0

parser.dasm16
3333
2
14dc
5461
14dd
ffff
    set x, [z-1]
parser.dasm16
3334
3
14de
7e73
14df
0020
14e0
0001
    ifn [x + HANDLE_TYPE], TYPE_INT
parser.dasm16
3335
2
14e1
7c20
14e2
00c6
        jsr recover
parser.dasm16
3336
0

parser.dasm16
3337
2
14e3
5701
14e4
ffff
    set push, [z-1]
parser.dasm16
3338
2
14e5
7c20
14e6
22bc
    jsr int_to_int16
parser.dasm16
3339
1
14e7
0e20
    hwq x
parser.dasm16
3340
0

parser.dasm16
3341
1
14e8
0f01
    set push, x
parser.dasm16
3342
1
14e9
1301
    set push, y
parser.dasm16
3343
1
14ea
0b01
    set push, c
parser.dasm16
3344
1
14eb
0301
    set push, a
parser.dasm16
3345
1
14ec
0701
    set push, b
parser.dasm16
3346
0

parser.dasm16
3347
1
14ed
9301
    set push, 3
parser.dasm16
3348
1
14ee
9701
    set push, TYPE_TUPLE
parser.dasm16
3349
2
14ef
7c20
14f0
2770
    jsr array_create
parser.dasm16
3350
2
14f1
0ea1
14f2
ffff
    set [z-1], x
parser.dasm16
3351
1
14f3
0c01
    set a, x
parser.dasm16
3352
0

parser.dasm16
3353
0
    ; pop a
parser.dasm16
3354
2
14f4
7c20
14f5
22a2
    jsr uint16_to_int
parser.dasm16
3355
2
14f6
0ea1
14f7
fffe
    set [z-2], x
parser.dasm16
3356
0
    
parser.dasm16
3357
1
14f8
0f01
    set push, x
parser.dasm16
3358
2
14f9
7f01
14fa
02e3
    set push, INT_16
parser.dasm16
3359
2
14fb
7c20
14fc
243e
    jsr int_lshift
parser.dasm16
3360
0

parser.dasm16
3361
0
    ; pop b    
parser.dasm16
3362
1
14fd
2c01
    set a, [x]
parser.dasm16
3363
2
14fe
6201
14ff
0002
    set [a+2], pop
parser.dasm16
3364
0

parser.dasm16
3365
0
    ; int to tuple
parser.dasm16
3366
2
1500
5401
1501
ffff
    set a, [z-1]
parser.dasm16
3367
1
1502
2001
    set a, [a]
parser.dasm16
3368
2
1503
0e01
1504
0001
    set [a+1], x
parser.dasm16
3369
0

parser.dasm16
3370
0
    ; pop c    
parser.dasm16
3371
2
1505
7c20
1506
22a2
    jsr uint16_to_int
parser.dasm16
3372
2
1507
5401
1508
ffff
    set a, [z-1]
parser.dasm16
3373
1
1509
2001
    set a, [a]
parser.dasm16
3374
2
150a
0e01
150b
0002
    set [a+2], x
parser.dasm16
3375
0
    
parser.dasm16
3376
0
    ; pop x
parser.dasm16
3377
2
150c
7c20
150d
22a2
    jsr uint16_to_int
parser.dasm16
3378
2
150e
0ea1
150f
fffe
    set [z-2], x
parser.dasm16
3379
0
    
parser.dasm16
3380
1
1510
0f01
    set push, x
parser.dasm16
3381
2
1511
7f01
1512
02e3
    set push, INT_16
parser.dasm16
3382
2
1513
7c20
1514
243e
    jsr int_lshift
parser.dasm16
3383
0

parser.dasm16
3384
0
    ; pop y    
parser.dasm16
3385
1
1515
2c01
    set a, [x]
parser.dasm16
3386
2
1516
6201
1517
0002
    set [a+2], pop
parser.dasm16
3387
0

parser.dasm16
3388
0
    ; int to tuple
parser.dasm16
3389
2
1518
5401
1519
ffff
    set a, [z-1]
parser.dasm16
3390
1
151a
2001
    set a, [a]
parser.dasm16
3391
2
151b
0e01
151c
0003
    set [a+3], x
parser.dasm16
3392
0

parser.dasm16
3393
2
151d
5461
151e
ffff
    set x, [z-1]
parser.dasm16
3394
2
151f
7f81
1520
2026
    set pc, postamble
parser.dasm16
3395
0

parser.dasm16
3396
0
;----------------------------------------------------------------
parser.dasm16
3397
0
:built_in_scroll
parser.dasm16
3398
0
;----------------------------------------------------------------
parser.dasm16
3399
2
1521
7c20
1522
1542
    jsr built_in_params
parser.dasm16
3400
1
1523
8cd3
    ifn i, 2
parser.dasm16
3401
2
1524
7c20
1525
00c6
        jsr recover
parser.dasm16
3402
0

parser.dasm16
3403
2
1526
5461
1527
ffff
    set x, [z-1]
parser.dasm16
3404
3
1528
7e71
1529
0030
152a
0001
    ifc [x + HANDLE_TYPE], TYPE_GROUP_INTEGER
parser.dasm16
3405
2
152b
7c20
152c
00c6
        jsr recover
parser.dasm16
3406
0
        
parser.dasm16
3407
1
152d
0f01
    set push, x
parser.dasm16
3408
2
152e
7c20
152f
22bc
    jsr int_to_int16
parser.dasm16
3409
1
1530
0f01
    set push, x
parser.dasm16
3410
0

parser.dasm16
3411
2
1531
5461
1532
fffe
    set x, [z-2]
parser.dasm16
3412
3
1533
7e71
1534
0030
1535
0001
    ifc [x + HANDLE_TYPE], TYPE_GROUP_INTEGER
parser.dasm16
3413
2
1536
7c20
1537
00c6
        jsr recover
parser.dasm16
3414
0
        
parser.dasm16
3415
1
1538
0f01
    set push, x
parser.dasm16
3416
2
1539
7c20
153a
22bc
    jsr int_to_int16
parser.dasm16
3417
1
153b
0f01
    set push, x
parser.dasm16
3418
0

parser.dasm16
3419
2
153c
7c20
153d
2e38
    jsr screen__scroll
parser.dasm16
3420
0
    
parser.dasm16
3421
2
153e
7c61
153f
029d
    set x, VOID
parser.dasm16
3422
2
1540
7f81
1541
2026
    set pc, postamble
parser.dasm16
3423
0

parser.dasm16
3424
0
;----------------------------------------------------------------
parser.dasm16
3425
0
:built_in_params
parser.dasm16
3426
0
; util function used by built-in impls to parse arguments
parser.dasm16
3427
0
;----------------------------------------------------------------
parser.dasm16
3428
1
1542
84c1
    set i, 0    ; param counter
parser.dasm16
3429
0

parser.dasm16
3430
0
:built_in_params_loop
parser.dasm16
3431
2
1543
7c20
1544
1ba6
    jsr lexer_next    ; skip '(' or ','
parser.dasm16
3432
0

parser.dasm16
3433
1
1545
90d2
    ife i, 3
parser.dasm16
3434
2
1546
7f81
1547
155d
        set pc, built_in_params_end
parser.dasm16
3435
3
1548
7fd2
1549
0514
154a
025c
    ife [lexer_token], token_rparen
parser.dasm16
3436
2
154b
7f81
154c
155d
        set pc, built_in_params_end
parser.dasm16
3437
0

parser.dasm16
3438
2
154d
7f01
154e
0030
    set push, 0x0030
parser.dasm16
3439
2
154f
7c20
1550
0ab4
    jsr expression
parser.dasm16
3440
0

parser.dasm16
3441
1
1551
141e
    sti a, z
parser.dasm16
3442
1
1552
1803
    sub a, i
parser.dasm16
3443
1
1553
0d01
    set [a], x
parser.dasm16
3444
0

parser.dasm16
3445
1
1554
0f01
    set push, x
parser.dasm16
3446
2
1555
7c20
1556
1dfc
    jsr eval
parser.dasm16
3447
1
1557
0d01
    set [a], x
parser.dasm16
3448
0
    
parser.dasm16
3449
0

parser.dasm16
3450
3
1558
7fd2
1559
04a8
155a
025c
    ife [lexer_token], token_comma
parser.dasm16
3451
2
155b
7f81
155c
1543
        set pc, built_in_params_loop
parser.dasm16
3452
0

parser.dasm16
3453
0
:built_in_params_end
parser.dasm16
3454
2
155d
7f01
155e
0514
    set push, token_rparen
parser.dasm16
3455
2
155f
7c20
1560
1b9d
    jsr lexer_advance    ; skip ')'
parser.dasm16
3456
0

parser.dasm16
3457
1
1561
6381
    set pc, pop
parser.dasm16
3458
0

parser.dasm16
3459
0
;----------------------------------------------------------------
parser.dasm16
3460
0
:load_registers
parser.dasm16
3461
0
; fastcall
parser.dasm16
3462
0
;----------------------------------------------------------------
parser.dasm16
3463
2
1562
7801
1563
db7b
    set a, [REGISTER_A]
parser.dasm16
3464
2
1564
7821
1565
db7c
    set b, [REGISTER_B]
parser.dasm16
3465
2
1566
7841
1567
db7d
    set c, [REGISTER_C]
parser.dasm16
3466
2
1568
7861
1569
db7e
    set x, [REGISTER_X]
parser.dasm16
3467
2
156a
7881
156b
db7f
    set y, [REGISTER_Y]
parser.dasm16
3468
1
156c
6381
    set pc, pop
parser.dasm16
3469
0

parser.dasm16
3470
0
;----------------------------------------------------------------
parser.dasm16
3471
0
:save_registers
parser.dasm16
3472
0
; fastcall
parser.dasm16
3473
0
;----------------------------------------------------------------
parser.dasm16
3474
2
156d
03c1
156e
db7b
    set [REGISTER_A], a
parser.dasm16
3475
2
156f
07c1
1570
db7c
    set [REGISTER_B], b
parser.dasm16
3476
2
1571
0bc1
1572
db7d
    set [REGISTER_C], c
parser.dasm16
3477
2
1573
0fc1
1574
db7e
    set [REGISTER_X], x
parser.dasm16
3478
2
1575
13c1
1576
db7f
    set [REGISTER_Y], y
parser.dasm16
3479
1
1577
6381
    set pc, pop
parser.dasm16
3480
0

parser.dasm16
3481
0

parser.dasm16
3482
0

float2.dasm16
0
0
; THIRD GENERATION FLOAT LIBRARY FOR ADMIRAL
float2.dasm16
1
0

float2.dasm16
2
0
;----------------------------------------------------------------
float2.dasm16
3
0
; struct handle *float_negate(struct handle *f)
float2.dasm16
4
0
;----------------------------------------------------------------
float2.dasm16
5
0
:float__negate
float2.dasm16
6
1
1578
8b01
    set push, 1
float2.dasm16
7
1
1579
8701
    set push, 0
float2.dasm16
8
2
157a
7c20
157b
2039
    jsr preamble
float2.dasm16
9
0
    
float2.dasm16
10
0
:float__negate__abs_merge
float2.dasm16
11
1
157c
9701
    set push, SIZEOF_FLOAT
float2.dasm16
12
2
157d
7f01
157e
0040
    set push, TYPE_FLOAT
float2.dasm16
13
2
157f
7c20
1580
21d3
    jsr alloc
float2.dasm16
14
0

float2.dasm16
15
2
1581
54c1
1582
000a
    set i, [z+10]
float2.dasm16
16
1
1583
38c1
    set i, [i]
float2.dasm16
17
0

float2.dasm16
18
1
1584
2c01
    set a, [x]
float2.dasm16
19
1
1585
00e1
    set j, a
float2.dasm16
20
0

float2.dasm16
21
1
1586
39fe
    sti [j], [i]
float2.dasm16
22
1
1587
39fe
    sti [j], [i]
float2.dasm16
23
1
1588
39fe
    sti [j], [i]
float2.dasm16
24
1
1589
39fe
    sti [j], [i]
float2.dasm16
25
0

float2.dasm16
26
0
    ; negate
float2.dasm16
27
1
158a
8105
    mli [a + FLOAT_TYPE], -1
float2.dasm16
28
0

float2.dasm16
29
2
158b
7f81
158c
2026
    set pc, postamble
float2.dasm16
30
0

float2.dasm16
31
0
;----------------------------------------------------------------
float2.dasm16
32
0
; struct handle *float__abs(struct handle *f)
float2.dasm16
33
0
;----------------------------------------------------------------
float2.dasm16
34
0
:float__abs
float2.dasm16
35
1
158d
8b01
    set push, 1
float2.dasm16
36
1
158e
8701
    set push, 0
float2.dasm16
37
2
158f
7c20
1590
2039
    jsr preamble
float2.dasm16
38
0
    
float2.dasm16
39
0
    ; return if positive or nan
float2.dasm16
40
2
1591
5461
1592
000a
    set x, [z+10]
float2.dasm16
41
1
1593
2c81
    set y, [x]
float2.dasm16
42
1
1594
8597
    ifu [y + FLOAT_TYPE], 0
float2.dasm16
43
2
1595
7f81
1596
2026
        set pc, postamble
float2.dasm16
44
0

float2.dasm16
45
2
1597
7f81
1598
157c
    set pc, float__negate__abs_merge
float2.dasm16
46
0

float2.dasm16
47
0
;----------------------------------------------------------------
float2.dasm16
48
0
; struct handle *float__cmp__float_int(struct handle *left, struct handle *right)
float2.dasm16
49
0
;----------------------------------------------------------------
float2.dasm16
50
0
:float__cmp__float_int
float2.dasm16
51
1
1599
8f01
    set push, 2
float2.dasm16
52
1
159a
8b01
    set push, 1
float2.dasm16
53
2
159b
7c20
159c
2039
    jsr preamble
float2.dasm16
54
0

float2.dasm16
55
2
159d
5701
159e
000a
    set push, [z + 10]
float2.dasm16
56
2
159f
7c20
15a0
1757
    jsr float__from_int
float2.dasm16
57
2
15a1
0ea1
15a2
ffff
    set [z-1], x
float2.dasm16
58
0

float2.dasm16
59
2
15a3
5701
15a4
000b
    set push, [z + 11]
float2.dasm16
60
2
15a5
5701
15a6
ffff
    set push, [z - 1]
float2.dasm16
61
2
15a7
7c20
15a8
15bd
    jsr float__cmp
float2.dasm16
62
0

float2.dasm16
63
2
15a9
7f81
15aa
2026
    set pc, postamble
float2.dasm16
64
0

float2.dasm16
65
0
;----------------------------------------------------------------
float2.dasm16
66
0
; struct handle *float_cmp__int_float(struct handle *left, struct handle *right)
float2.dasm16
67
0
;----------------------------------------------------------------
float2.dasm16
68
0
:float__cmp__int_float
float2.dasm16
69
1
15ab
8f01
    set push, 2
float2.dasm16
70
1
15ac
8b01
    set push, 1
float2.dasm16
71
2
15ad
7c20
15ae
2039
    jsr preamble
float2.dasm16
72
0

float2.dasm16
73
2
15af
5701
15b0
000b
    set push, [z + 11]
float2.dasm16
74
2
15b1
7c20
15b2
1757
    jsr float__from_int
float2.dasm16
75
2
15b3
0ea1
15b4
ffff
    set [z-1], x
float2.dasm16
76
0

float2.dasm16
77
2
15b5
5701
15b6
ffff
    set push, [z - 1]
float2.dasm16
78
2
15b7
5701
15b8
000a
    set push, [z + 10]
float2.dasm16
79
2
15b9
7c20
15ba
15bd
    jsr float__cmp
float2.dasm16
80
0

float2.dasm16
81
2
15bb
7f81
15bc
2026
    set pc, postamble
float2.dasm16
82
0

float2.dasm16
83
0
;----------------------------------------------------------------
float2.dasm16
84
0
; struct handle *float__cmp(struct handle *left, struct handle *right)
float2.dasm16
85
0
;----------------------------------------------------------------
float2.dasm16
86
0
:float__cmp
float2.dasm16
87
1
15bd
1b01
    set push, i                 ; store registers
float2.dasm16
88
1
15be
1f01
    set push, j
float2.dasm16
89
0

float2.dasm16
90
0
	;---------------------------------------
float2.dasm16
91
0
    ; [sp + 4] left
float2.dasm16
92
0
    ; [sp + 3] right
float2.dasm16
93
0
    ; [sp + 2] rts
float2.dasm16
94
0
    ; [sp + 1] i
float2.dasm16
95
0
    ; [sp + 0] j
float2.dasm16
96
0
	;---------------------------------------
float2.dasm16
97
0

float2.dasm16
98
2
15bf
68c1
15c0
0004
	set i, [sp + 4]                ; float *left
float2.dasm16
99
1
15c1
38c1
	set i, [i]
float2.dasm16
100
2
15c2
68e1
15c3
0003
	set j, [sp + 3]                ; float *right
float2.dasm16
101
1
15c4
3ce1
	set j, [j]
float2.dasm16
102
0

float2.dasm16
103
0
	; compare types
float2.dasm16
104
1
15c5
8461
    set x, 0                       ; zero return value
float2.dasm16
105
0

float2.dasm16
106
1
15c6
3dd7
    ifu [i + FLOAT_TYPE], [j + FLOAT_TYPE]
float2.dasm16
107
1
15c7
8861
        set x, 1
float2.dasm16
108
0

float2.dasm16
109
1
15c8
3dd5
    ifa [i + FLOAT_TYPE], [j + FLOAT_TYPE]
float2.dasm16
110
1
15c9
8061
        set x, -1
float2.dasm16
111
0

float2.dasm16
112
1
15ca
8473
    ifn x, 0                       ; different types?
float2.dasm16
113
2
15cb
7f81
15cc
15d6
        set pc, float__cmp__finish 
float2.dasm16
114
0

float2.dasm16
115
0
	; left.type == right.type
float2.dasm16
116
0

float2.dasm16
117
2
15cd
7dd3
15ce
fffe
	ifn [i + FLOAT_TYPE], FLOAT_TYPE_PNUM       ; special values?
float2.dasm16
118
1
15cf
8dd3
    	ifn [i + FLOAT_TYPE], FLOAT_TYPE_NNUM
float2.dasm16
119
2
15d0
7f81
15d1
15d6
            set pc, float__cmp__finish 
float2.dasm16
120
0

float2.dasm16
121
0
	; compare two positive or two negative numbers
float2.dasm16
122
2
15d2
7c20
15d3
1a70
    jsr _float_cmp_abs
float2.dasm16
123
0

float2.dasm16
124
0
    ; negate result if arguments are negative
float2.dasm16
125
1
15d4
85d5
	ifa [i + FLOAT_TYPE], 0
float2.dasm16
126
1
15d5
8065
		mli x, -1
float2.dasm16
127
0

float2.dasm16
128
0
:float__cmp__finish
float2.dasm16
129
0
	;---------------------------------------
float2.dasm16
130
0
	; postamble
float2.dasm16
131
0
	;---------------------------------------
float2.dasm16
132
1
15d6
60e1
    set j, pop
float2.dasm16
133
1
15d7
60c1
    set i, pop
float2.dasm16
134
1
15d8
6321
	set [sp], pop				; cleanup right
float2.dasm16
135
1
15d9
6321
	set [sp], pop               ; cleanup left
float2.dasm16
136
1
15da
6381
	set pc, pop
float2.dasm16
137
0

float2.dasm16
138
0

float2.dasm16
139
0
;----------------------------------------------------------------
float2.dasm16
140
0
; struct handle *float__add(struct handle *f1, struct handle *f2)
float2.dasm16
141
0
;----------------------------------------------------------------
float2.dasm16
142
0
:float__add
float2.dasm16
143
1
15db
8f01
    set push, 2
float2.dasm16
144
1
15dc
8b01
    set push, 1
float2.dasm16
145
2
15dd
7c20
15de
2039
    jsr preamble
float2.dasm16
146
0

float2.dasm16
147
1
15df
9701
    set push, SIZEOF_FLOAT
float2.dasm16
148
2
15e0
7f01
15e1
0040
    set push, TYPE_FLOAT
float2.dasm16
149
2
15e2
7c20
15e3
21d3
    jsr alloc
float2.dasm16
150
2
15e4
0ea1
15e5
ffff
    set [z-1], x
float2.dasm16
151
0

float2.dasm16
152
2
15e6
54c1
15e7
000b
    set i, [z + 11]          ; float *left
float2.dasm16
153
1
15e8
38c1
    set i, [i]
float2.dasm16
154
2
15e9
54e1
15ea
000a
    set j, [z + 10]          ; float *right
float2.dasm16
155
1
15eb
3ce1
    set j, [j]
float2.dasm16
156
0

float2.dasm16
157
0
    ;---------------------------------------
float2.dasm16
158
0
    ; check special cases
float2.dasm16
159
0
    ;---------------------------------------
float2.dasm16
160
2
15ec
7c01
15ed
1a9f
    set a, float__add__special_values
float2.dasm16
161
2
15ee
7f81
15ef
1a8a
    set pc, _float__special_values
float2.dasm16
162
0

float2.dasm16
163
0
:float__add__num
float2.dasm16
164
0
    ;---------------------------------------
float2.dasm16
165
0
    ; i = clone(abs(left) >= abs(right) ? left: right)
float2.dasm16
166
0
    ; j = abs(left) < abs(right) ? left: right
float2.dasm16
167
0
    ;---------------------------------------
float2.dasm16
168
0

float2.dasm16
169
2
15f0
7c20
15f1
1a70
    jsr _float_cmp_abs
float2.dasm16
170
0

float2.dasm16
171
0
    ; i = max(left, right)
float2.dasm16
172
0
    ; j = min(left, right)
float2.dasm16
173
1
15f2
8073
    ifn x, -1
float2.dasm16
174
2
15f3
7f81
15f4
15f8
        set pc, float__add__align_exp
float2.dasm16
175
0

float2.dasm16
176
0
    ; variable swap
float2.dasm16
177
1
15f5
1ccc
    xor i, j
float2.dasm16
178
1
15f6
18ec
    xor j, i
float2.dasm16
179
1
15f7
1ccc
    xor i, j
float2.dasm16
180
0

float2.dasm16
181
0
:float__add__align_exp
float2.dasm16
182
2
15f8
5461
15f9
ffff
    set x, [z-1]
float2.dasm16
183
0

float2.dasm16
184
0
    ; calculate exponent diff
float2.dasm16
185
2
15fa
5841
15fb
0001
    set c, [i + FLOAT_EXP]
float2.dasm16
186
2
15fc
5c43
15fd
0001
    sub c, [j + FLOAT_EXP]
float2.dasm16
187
0
    
float2.dasm16
188
0
    ; quick exit if j is too small
float2.dasm16
189
2
15fe
7c54
15ff
001f
    ifg c, 31
float2.dasm16
190
2
1600
7f81
1601
1b27
        set pc, float__return_i
float2.dasm16
191
0

float2.dasm16
192
0
    ; shift mantissa for calculation
float2.dasm16
193
2
1602
5c21
1603
0003
    set b, [j + FLOAT_LOW]
float2.dasm16
194
1
1604
082d
    shr b, c
float2.dasm16
195
0

float2.dasm16
196
2
1605
5c01
1606
0002
    set a, [j + FLOAT_HIGH]
float2.dasm16
197
1
1607
080d
    shr a, c
float2.dasm16
198
0

float2.dasm16
199
0
    ; copy max(left, right) to result
float2.dasm16
200
1
1608
2c41
    set c, [x]
float2.dasm16
201
1
1609
3941
    set [c + FLOAT_TYPE], [i + FLOAT_TYPE]
float2.dasm16
202
3
160a
5a41
160b
0001
160c
0001
    set [c + FLOAT_EXP], [i + FLOAT_EXP]
float2.dasm16
203
3
160d
5a41
160e
0002
160f
0002
    set [c + FLOAT_HIGH], [i + FLOAT_HIGH]
float2.dasm16
204
3
1610
5a41
1611
0003
1612
0003
    set [c + FLOAT_LOW], [i + FLOAT_LOW]
float2.dasm16
205
0

float2.dasm16
206
0
    ; which method to use?
float2.dasm16
207
1
1613
3dd2
    ife [i + FLOAT_TYPE], [j + FLOAT_TYPE]     ; sgn(i) == sgn(j)
float2.dasm16
208
2
1614
7f81
1615
162f
        set pc, float__add__op_add
float2.dasm16
209
0

float2.dasm16
210
0
:float__add__op_sub
float2.dasm16
211
0
    ;bor b, ex
float2.dasm16
212
0
    
float2.dasm16
213
2
1616
0643
1617
0003
    sub [c + FLOAT_LOW], b
float2.dasm16
214
2
1618
025b
1619
0002
    sbx [c + FLOAT_HIGH], a
float2.dasm16
215
0

float2.dasm16
216
2
161a
8652
161b
0003
    ife [c + FLOAT_LOW], 0
float2.dasm16
217
2
161c
8652
161d
0002
        ife [c + FLOAT_HIGH], 0
float2.dasm16
218
2
161e
7f81
161f
1b1f
            set pc, float__return_pzero
float2.dasm16
219
0
    
float2.dasm16
220
0
    ; normalize result
float2.dasm16
221
2
1620
7c20
1621
1a43
    jsr float__nlz32
float2.dasm16
222
0
    
float2.dasm16
223
2
1622
024f
1623
0002
    shl [c + FLOAT_HIGH], a
float2.dasm16
224
2
1624
024f
1625
0003
    shl [c + FLOAT_LOW], a
float2.dasm16
225
2
1626
764b
1627
0002
    bor [c + FLOAT_HIGH], ex
float2.dasm16
226
0
    
float2.dasm16
227
2
1628
0243
1629
0001
    sub [c + FLOAT_EXP], a
float2.dasm16
228
1
162a
87b2
    ife ex, 0
float2.dasm16
229
2
162b
7f81
162c
2026
        set pc, postamble
float2.dasm16
230
0
        
float2.dasm16
231
2
162d
7f81
162e
1b1b
    set pc, float__return_zero
float2.dasm16
232
0

float2.dasm16
233
0
:float__add__op_add
float2.dasm16
234
2
162f
065a
1630
0003
    adx [c + FLOAT_LOW], b
float2.dasm16
235
2
1631
025a
1632
0002
    adx [c + FLOAT_HIGH], a
float2.dasm16
236
0

float2.dasm16
237
2
1633
8652
1634
0003
    ife [c + FLOAT_LOW], 0
float2.dasm16
238
2
1635
8652
1636
0002
        ife [c + FLOAT_HIGH], 0
float2.dasm16
239
1
1637
87b2
            ife ex, 0
float2.dasm16
240
2
1638
7f81
1639
1b1f
                set pc, float__return_pzero
float2.dasm16
241
0

float2.dasm16
242
1
163a
87b2
    ife ex, 0                           ; no overflow?
float2.dasm16
243
2
163b
7f81
163c
2026
        set pc, postamble
float2.dasm16
244
0

float2.dasm16
245
0
    ; normalize result
float2.dasm16
246
2
163d
8a4d
163e
0003
    shr [c + FLOAT_LOW], 1
float2.dasm16
247
2
163f
8a4d
1640
0002
    shr [c + FLOAT_HIGH], 1
float2.dasm16
248
2
1641
764b
1642
0003
    bor [c + FLOAT_LOW], ex
float2.dasm16
249
3
1643
7e4b
1644
8000
1645
0002
    bor [c + FLOAT_HIGH], 0x8000
float2.dasm16
250
0

float2.dasm16
251
2
1646
8a42
1647
0001
    add [c + FLOAT_EXP], 1
float2.dasm16
252
1
1648
87b2
    ife ex, 0
float2.dasm16
253
2
1649
7f81
164a
2026
        set pc, postamble
float2.dasm16
254
0

float2.dasm16
255
2
164b
7f81
164c
1b0f
    set pc, float__return_inf
float2.dasm16
256
0

float2.dasm16
257
0
;----------------------------------------------------------------
float2.dasm16
258
0
; struct handle *float__sub(struct handle *f1, struct handle *f2)
float2.dasm16
259
0
;----------------------------------------------------------------
float2.dasm16
260
0
:float__sub
float2.dasm16
261
1
164d
8f01
    set push, 2
float2.dasm16
262
1
164e
8b01
    set push, 1
float2.dasm16
263
2
164f
7c20
1650
2039
    jsr preamble
float2.dasm16
264
0

float2.dasm16
265
2
1651
5701
1652
000a
    set push, [z+10]
float2.dasm16
266
2
1653
7c20
1654
1578
    jsr float__negate
float2.dasm16
267
2
1655
0ea1
1656
ffff
    set [z-1], x
float2.dasm16
268
0

float2.dasm16
269
2
1657
5701
1658
000b
    set push, [z+11]
float2.dasm16
270
2
1659
5701
165a
ffff
    set push, [z-1]
float2.dasm16
271
2
165b
7c20
165c
15db
    jsr float__add
float2.dasm16
272
0

float2.dasm16
273
2
165d
7f81
165e
2026
    set pc, postamble
float2.dasm16
274
0

float2.dasm16
275
0
;----------------------------------------------------------------
float2.dasm16
276
0
; struct handle *float__mul(struct handle *f1, struct handle *f2)
float2.dasm16
277
0
;----------------------------------------------------------------
float2.dasm16
278
0
:float__mul
float2.dasm16
279
1
165f
8f01
    set push, 2
float2.dasm16
280
1
1660
8b01
    set push, 1
float2.dasm16
281
2
1661
7c20
1662
2039
    jsr preamble
float2.dasm16
282
0

float2.dasm16
283
2
1663
54c1
1664
000b
    set i, [z + 11]          ; float *left
float2.dasm16
284
1
1665
38c1
    set i, [i]
float2.dasm16
285
2
1666
54e1
1667
000a
    set j, [z + 10]          ; float *right
float2.dasm16
286
1
1668
3ce1
    set j, [j]
float2.dasm16
287
0

float2.dasm16
288
1
1669
9f63
    sub sp, 6
float2.dasm16
289
0

float2.dasm16
290
0
    ;---------------------------------------
float2.dasm16
291
0
    ; check special cases
float2.dasm16
292
0
    ;---------------------------------------
float2.dasm16
293
2
166a
7c01
166b
1ac3
    set a, float__mul__special_values
float2.dasm16
294
2
166c
7f81
166d
1a8a
    set pc, _float__special_values
float2.dasm16
295
0

float2.dasm16
296
0
:float__mul__nnum
float2.dasm16
297
1
166e
8f21
    set [sp + FLOAT_TYPE], FLOAT_TYPE_NNUM
float2.dasm16
298
2
166f
7f81
1670
1673
    set pc, float__mul__num
float2.dasm16
299
0

float2.dasm16
300
0
:float__mul__pnum
float2.dasm16
301
2
1671
7f21
1672
fffe
    set [sp + FLOAT_TYPE], FLOAT_TYPE_PNUM
float2.dasm16
302
0

float2.dasm16
303
0
:float__mul__num
float2.dasm16
304
0
    ;---------------------------------------
float2.dasm16
305
0
    ; calculate exponent
float2.dasm16
306
0
    ;---------------------------------------
float2.dasm16
307
0
    ; is all this really needed to detect overflow?
float2.dasm16
308
2
1673
5801
1674
0001
    set a, [i + FLOAT_EXP]
float2.dasm16
309
2
1675
7c03
1676
8000
    sub a, FLOAT_EXP_BIAS           ; remove bias
float2.dasm16
310
0

float2.dasm16
311
2
1677
5c21
1678
0001
    set b, [j + FLOAT_EXP]
float2.dasm16
312
2
1679
7c23
167a
8000
    sub b, FLOAT_EXP_BIAS           ; remove bias
float2.dasm16
313
0

float2.dasm16
314
1
167b
0041
    set c, a                        ; calculate sum to c
float2.dasm16
315
1
167c
0442
    add c, b
float2.dasm16
316
0
     
float2.dasm16
317
1
167d
080c
    xor a, c                        ; does arg1.exp and result.exp have different sign
float2.dasm16
318
1
167e
082c
    xor b, c                        ; does arg2.exp and result.exp have different sign
float2.dasm16
319
1
167f
040a
    and a, b                        ; both operands have different sign than sum
float2.dasm16
320
0

float2.dasm16
321
0
    ; value for overflow exit
float2.dasm16
322
2
1680
7c21
1681
1b0f
    set b, float__return_inf        ; assume overflow as default 
float2.dasm16
323
3
1682
7ed6
1683
8000
1684
0001
    ifl [i + FLOAT_EXP], FLOAT_EXP_BIAS ; ...unless exp<0 then assume underflow
float2.dasm16
324
2
1685
7c21
1686
1b1b
        set b, float__return_zero
float2.dasm16
325
0

float2.dasm16
326
2
1687
7c10
1688
8000
    ifb a, 0x8000                   ; finally test overflow
float2.dasm16
327
1
1689
0781
      set pc, b                     ; and act accordingly
float2.dasm16
328
0

float2.dasm16
329
2
168a
7c42
168b
8001
    add c, FLOAT_EXP_BIAS + 1       ; restore bias
float2.dasm16
330
2
168c
0b41
168d
0001
    set [sp + FLOAT_EXP], c         ; set exponent
float2.dasm16
331
0

float2.dasm16
332
0
    ;---------------------------------------
float2.dasm16
333
0
    ; calculate mantissa
float2.dasm16
334
0
    ;---------------------------------------
float2.dasm16
335
3
168e
5f41
168f
0003
1690
0005
    set [sp + FLOAT_LOW + 2], [j + FLOAT_LOW]
float2.dasm16
336
3
1691
5b44
1692
0003
1693
0005
    mul [sp + FLOAT_LOW + 2], [i + FLOAT_LOW]
float2.dasm16
337
0

float2.dasm16
338
2
1694
7741
1695
0004
    set [sp + FLOAT_LOW + 1], ex
float2.dasm16
339
0
    
float2.dasm16
340
2
1696
5801
1697
0002
    set a, [i + FLOAT_HIGH]
float2.dasm16
341
2
1698
5c04
1699
0003
    mul a, [j + FLOAT_LOW]
float2.dasm16
342
2
169a
7741
169b
0003
    set [sp + FLOAT_LOW], ex
float2.dasm16
343
2
169c
0342
169d
0004
    add [sp + FLOAT_LOW + 1], a
float2.dasm16
344
2
169e
7742
169f
0003
    add [sp + FLOAT_LOW], ex
float2.dasm16
345
0

float2.dasm16
346
2
16a0
5801
16a1
0003
    set a, [i + FLOAT_LOW]
float2.dasm16
347
2
16a2
5c04
16a3
0002
    mul a, [j + FLOAT_HIGH]
float2.dasm16
348
2
16a4
7742
16a5
0003
    add [sp + FLOAT_LOW], ex
float2.dasm16
349
2
16a6
7741
16a7
0002
    set [sp + FLOAT_HIGH], ex
float2.dasm16
350
2
16a8
0342
16a9
0004
    add [sp + FLOAT_LOW + 1], a
float2.dasm16
351
2
16aa
7742
16ab
0003
    add [sp + FLOAT_LOW], ex
float2.dasm16
352
2
16ac
7742
16ad
0002
    add [sp + FLOAT_HIGH], ex
float2.dasm16
353
0
    
float2.dasm16
354
2
16ae
5801
16af
0002
    set a, [i + FLOAT_HIGH]
float2.dasm16
355
2
16b0
5c04
16b1
0002
    mul a, [j + FLOAT_HIGH]
float2.dasm16
356
2
16b2
7742
16b3
0002
    add [sp + FLOAT_HIGH], ex
float2.dasm16
357
2
16b4
0342
16b5
0003
    add [sp + FLOAT_LOW], a
float2.dasm16
358
2
16b6
7742
16b7
0002
    add [sp + FLOAT_HIGH], ex
float2.dasm16
359
0

float2.dasm16
360
0
    ;---------------------------------------
float2.dasm16
361
0
    ; normalize result
float2.dasm16
362
0
    ;---------------------------------------
float2.dasm16
363
3
16b8
7f50
16b9
8000
16ba
0002
    ifb [sp + FLOAT_HIGH], 0x8000
float2.dasm16
364
2
16bb
7f81
16bc
16ca
        set pc, float__mul__no_normalize
float2.dasm16
365
0

float2.dasm16
366
2
16bd
8b4f
16be
0002
    shl [sp + FLOAT_HIGH], 1
float2.dasm16
367
2
16bf
8b4f
16c0
0003
    shl [sp + FLOAT_LOW], 1
float2.dasm16
368
2
16c1
774b
16c2
0002
    bor [sp + FLOAT_HIGH], ex
float2.dasm16
369
3
16c3
7f50
16c4
8000
16c5
0004
    ifb [sp + FLOAT_LOW + 1], 0x8000
float2.dasm16
370
2
16c6
8b4b
16c7
0003
        bor [sp + FLOAT_LOW], 0x0001
float2.dasm16
371
0

float2.dasm16
372
2
16c8
8b43
16c9
0001
    sub [sp + FLOAT_EXP], 1
float2.dasm16
373
0
    
float2.dasm16
374
0
:float__mul__no_normalize
float2.dasm16
375
1
16ca
9701
    set push, SIZEOF_FLOAT
float2.dasm16
376
2
16cb
7f01
16cc
0040
    set push, TYPE_FLOAT
float2.dasm16
377
2
16cd
7c20
16ce
21d3
    jsr alloc
float2.dasm16
378
0

float2.dasm16
379
1
16cf
6cc1
    set i, sp
float2.dasm16
380
2
16d0
7f81
16d1
1b27
    set pc, float__return_i
float2.dasm16
381
0

float2.dasm16
382
0
;----------------------------------------------------------------
float2.dasm16
383
0
; struct handle *float__div(struct handle *f1, struct handle *f2)
float2.dasm16
384
0
;----------------------------------------------------------------
float2.dasm16
385
0
:float__div
float2.dasm16
386
1
16d2
8f01
    set push, 2
float2.dasm16
387
1
16d3
9301
    set push, 3
float2.dasm16
388
2
16d4
7c20
16d5
2039
    jsr preamble
float2.dasm16
389
0

float2.dasm16
390
2
16d6
54c1
16d7
000b
    set i, [z + 11]          ; float *left
float2.dasm16
391
1
16d8
38c1
    set i, [i]
float2.dasm16
392
2
16d9
54e1
16da
000a
    set j, [z + 10]          ; float *right
float2.dasm16
393
1
16db
3ce1
    set j, [j]
float2.dasm16
394
0

float2.dasm16
395
1
16dc
1b01
    set push, i
float2.dasm16
396
2
16dd
7c20
16de
19a1
    jsr rintti
float2.dasm16
397
0

float2.dasm16
398
1
16df
1f01
    set push, j
float2.dasm16
399
2
16e0
7c20
16e1
19a1
    jsr rintti
float2.dasm16
400
0

float2.dasm16
401
0
    ; copy divident mantissa to stack
float2.dasm16
402
2
16e2
5b01
16e3
0003
    set push, [i + FLOAT_LOW]
float2.dasm16
403
2
16e4
5b01
16e5
0002
    set push, [i + FLOAT_HIGH]
float2.dasm16
404
0
    
float2.dasm16
405
0
    ; allocate space for quotient
float2.dasm16
406
1
16e6
9763
    sub sp, 4
float2.dasm16
407
0

float2.dasm16
408
0
    ; [sp + 5] divident.low
float2.dasm16
409
0
    ; [sp + 4] divident.high
float2.dasm16
410
0
    ; [sp + 3] quotient.low
float2.dasm16
411
0
    ; [sp + 2] quotient.high
float2.dasm16
412
0
    ; [sp + 1] quotient.exp
float2.dasm16
413
0
    ; [sp + 0] quotient.type
float2.dasm16
414
0

float2.dasm16
415
0
    ; check special cases
float2.dasm16
416
2
16e7
7c01
16e8
1ae7
    set a, float__div__special_values
float2.dasm16
417
2
16e9
7f81
16ea
1a8a
    set pc, _float__special_values
float2.dasm16
418
0

float2.dasm16
419
0
    ;---------------------------------------
float2.dasm16
420
0
:float__div__nnum
float2.dasm16
421
1
16eb
8f21
    set [sp + FLOAT_TYPE], FLOAT_TYPE_NNUM
float2.dasm16
422
2
16ec
7f81
16ed
16f0
    set pc, float__div__num
float2.dasm16
423
0

float2.dasm16
424
0
:float__div__pnum
float2.dasm16
425
2
16ee
7f21
16ef
fffe
    set [sp + FLOAT_TYPE], FLOAT_TYPE_PNUM
float2.dasm16
426
0

float2.dasm16
427
0
:float__div__num
float2.dasm16
428
0
    ;---------------------------------------
float2.dasm16
429
0
    ; calculate exponent
float2.dasm16
430
0
    ;---------------------------------------
float2.dasm16
431
0
    ; is all this really needed to detect overflow?
float2.dasm16
432
2
16f0
5801
16f1
0001
    set a, [i + FLOAT_EXP]          ; divident exponent
float2.dasm16
433
2
16f2
7c03
16f3
8000
    sub a, FLOAT_EXP_BIAS           ; remove bias
float2.dasm16
434
0

float2.dasm16
435
2
16f4
5c21
16f5
0001
    set b, [j + FLOAT_EXP]          ; divisor exponent
float2.dasm16
436
2
16f6
7c23
16f7
8000
    sub b, FLOAT_EXP_BIAS           ; remove bias
float2.dasm16
437
0

float2.dasm16
438
1
16f8
0041
    set c, a                        ; quotient.exp = divident.exp - divisor.exp
float2.dasm16
439
1
16f9
0443
    sub c, b
float2.dasm16
440
0
     
float2.dasm16
441
0
    ; signed arithmetic overflow test
float2.dasm16
442
0
    ; c = a + b -> "((a ^ c) & (b ^ c)) < 0"
float2.dasm16
443
1
16fa
080c
    xor a, c                        ; does arg1.exp and result.exp have different sign
float2.dasm16
444
1
16fb
082c
    xor b, c                        ; does arg2.exp and result.exp have different sign
float2.dasm16
445
1
16fc
040a
    and a, b                        ; both operands have different sign than sum
float2.dasm16
446
0

float2.dasm16
447
0
    ; value for overflow exit
float2.dasm16
448
2
16fd
7c21
16fe
1b0f
    set b, float__return_inf        ; assume overflow as default 
float2.dasm16
449
3
16ff
7ed6
1700
8000
1701
0001
    ifl [i + FLOAT_EXP], FLOAT_EXP_BIAS ; ...unless exp<0 then assume underflow
float2.dasm16
450
2
1702
7c21
1703
1b1b
        set b, float__return_zero
float2.dasm16
451
0

float2.dasm16
452
2
1704
7c10
1705
8000
    ifb a, 0x8000                   ; test overflow
float2.dasm16
453
1
1706
0781
      set pc, b                     ; ...and return
float2.dasm16
454
0

float2.dasm16
455
2
1707
7c42
1708
8000
    add c, FLOAT_EXP_BIAS           ; restore bias
float2.dasm16
456
2
1709
0b41
170a
0001
    set [sp + FLOAT_EXP], c         ; set exponent
float2.dasm16
457
0

float2.dasm16
458
0
    ; [sp + 5] divident.low
float2.dasm16
459
0
    ; [sp + 4] divident.high
float2.dasm16
460
0
    ; [sp + 0] quotient
float2.dasm16
461
0
    ; [j]      divisor
float2.dasm16
462
0
    ; a        current quotient word
float2.dasm16
463
0
    ; b        temp
float2.dasm16
464
0
    ; c        current quotient word number
float2.dasm16
465
0

float2.dasm16
466
1
170b
8801
    set a, 1 ; set sentinel
float2.dasm16
467
1
170c
8441
    set c, 0 ; current word number
float2.dasm16
468
0

float2.dasm16
469
0
:float__div__cmp
float2.dasm16
470
0
    ; see if divisor can be subtracted from divident
float2.dasm16
471
0
    ; b=1 can, b=0 cannot
float2.dasm16
472
1
170d
8821
    set b, 1
float2.dasm16
473
0

float2.dasm16
474
3
170e
5f52
170f
0002
1710
0004
    ife [sp + 4], [j + FLOAT_HIGH]
float2.dasm16
475
3
1711
5f56
1712
0003
1713
0005
        ifl [sp + 5], [j + FLOAT_LOW]
float2.dasm16
476
1
1714
8421
            set b, 0
float2.dasm16
477
0
    
float2.dasm16
478
3
1715
5f56
1716
0002
1717
0004
    ifl [sp + 4], [j + FLOAT_HIGH]
float2.dasm16
479
1
1718
8421
        set b, 0
float2.dasm16
480
0

float2.dasm16
481
0
:float__div__next_bit
float2.dasm16
482
0
    ; shift quotient
float2.dasm16
483
1
1719
880f
    shl a, 1
float2.dasm16
484
1
171a
040b
    bor a, b
float2.dasm16
485
0

float2.dasm16
486
2
171b
77f2
171c
0000
    ife 0, ex                       ; no sentinel out
float2.dasm16
487
2
171d
7f81
171e
1726
        set pc, float__div__no_word
float2.dasm16
488
0

float2.dasm16
489
1
171f
8453
    ifn c, 0                        ; all words completed?
float2.dasm16
490
2
1720
7f81
1721
173b
        set pc, float__div__normalize
float2.dasm16
491
0

float2.dasm16
492
1
1722
8841
    set c, 1
float2.dasm16
493
2
1723
0341
1724
0002
    set [sp + FLOAT_HIGH], a        ; store high word
float2.dasm16
494
1
1725
8801
    set a, 1                        ; restart sentinel
float2.dasm16
495
0

float2.dasm16
496
0
:float__div__no_word
float2.dasm16
497
1
1726
8432
    ife b, 0                        ; do subtract if possible
float2.dasm16
498
2
1727
7f81
1728
172f
        set pc, float__div__shift_divident
float2.dasm16
499
0

float2.dasm16
500
0
    ; subtract
float2.dasm16
501
3
1729
5f43
172a
0003
172b
0005
    sub [sp + 5], [j + FLOAT_LOW]
float2.dasm16
502
3
172c
5f5b
172d
0002
172e
0004
    sbx [sp + 4], [j + FLOAT_HIGH]
float2.dasm16
503
0

float2.dasm16
504
0
:float__div__shift_divident
float2.dasm16
505
2
172f
8b4f
1730
0004
    shl [sp + 4], 1
float2.dasm16
506
1
1731
7421
    set b, ex
float2.dasm16
507
2
1732
8b4f
1733
0005
    shl [sp + 5], 1
float2.dasm16
508
2
1734
774b
1735
0004
    bor [sp + 4], ex
float2.dasm16
509
0

float2.dasm16
510
1
1736
8832
    ife b, 1
float2.dasm16
511
2
1737
7f81
1738
1719
        set pc, float__div__next_bit
float2.dasm16
512
0

float2.dasm16
513
0
;   optional optimization
float2.dasm16
514
0
;   ifc [sp + 4], 0x8000
float2.dasm16
515
0
;       set pc, float__div__next_bit
float2.dasm16
516
0

float2.dasm16
517
2
1739
7f81
173a
170d
    set pc, float__div__cmp     
float2.dasm16
518
0

float2.dasm16
519
0
:float__div__normalize
float2.dasm16
520
2
173b
0341
173c
0003
    set [sp + FLOAT_LOW], a
float2.dasm16
521
0

float2.dasm16
522
1
173d
6c41
    set c, sp
float2.dasm16
523
2
173e
7c20
173f
1a43
    jsr float__nlz32
float2.dasm16
524
0
    
float2.dasm16
525
2
1740
024f
1741
0002
    shl [c + FLOAT_HIGH], a
float2.dasm16
526
2
1742
024f
1743
0003
    shl [c + FLOAT_LOW], a
float2.dasm16
527
2
1744
764b
1745
0002
    bor [c + FLOAT_HIGH], ex
float2.dasm16
528
0
    
float2.dasm16
529
2
1746
0243
1747
0001
    sub [c + FLOAT_EXP], a
float2.dasm16
530
0

float2.dasm16
531
1
1748
6c61
    set x, sp
float2.dasm16
532
1
1749
87b3
    ifn ex, 0
float2.dasm16
533
2
174a
7f81
174b
1b1b
        set pc, float__return_zero
float2.dasm16
534
0
        
float2.dasm16
535
1
174c
9701
    set push, SIZEOF_FLOAT
float2.dasm16
536
2
174d
7f01
174e
0040
    set push, TYPE_FLOAT
float2.dasm16
537
2
174f
7c20
1750
21d3
    jsr alloc
float2.dasm16
538
0

float2.dasm16
539
1
1751
6cc1
    set i, sp
float2.dasm16
540
0

float2.dasm16
541
1
1752
1b01
    set push, i
float2.dasm16
542
2
1753
7c20
1754
19a1
    jsr rintti
float2.dasm16
543
0

float2.dasm16
544
2
1755
7f81
1756
1b27
    set pc, float__return_i
float2.dasm16
545
0

float2.dasm16
546
0
;----------------------------------------------------------------
float2.dasm16
547
0
; struct handle *float__from_int(struct handle *int)
float2.dasm16
548
0
;----------------------------------------------------------------
float2.dasm16
549
0
:float__from_int
float2.dasm16
550
1
1757
8b01
    set push, 1
float2.dasm16
551
1
1758
8f01
    set push, 2
float2.dasm16
552
2
1759
7c20
175a
2039
    jsr preamble
float2.dasm16
553
0

float2.dasm16
554
0
    ;---------------------------------------
float2.dasm16
555
0
    ; shortcut if int is 0
float2.dasm16
556
0
    ;---------------------------------------
float2.dasm16
557
2
175b
5401
175c
000a
    set a, [z+10]
float2.dasm16
558
1
175d
2001
    set a, [a]
float2.dasm16
559
0

float2.dasm16
560
1
175e
8912
    ife [a], 1
float2.dasm16
561
2
175f
8612
1760
0001
        ife [a+1], 0
float2.dasm16
562
2
1761
7f81
1762
1b1f
            set pc, float__return_pzero
float2.dasm16
563
0

float2.dasm16
564
0
    ;---------------------------------------
float2.dasm16
565
0
    ; abs(int)
float2.dasm16
566
0
    ;---------------------------------------
float2.dasm16
567
2
1763
5701
1764
000a
    set push, [z+10]
float2.dasm16
568
2
1765
7c20
1766
24ab
    jsr int_abs
float2.dasm16
569
2
1767
0ea1
1768
fffe
    set [z-2], x
float2.dasm16
570
1
1769
0cc1
    set i, x
float2.dasm16
571
0

float2.dasm16
572
0
    ;---------------------------------------
float2.dasm16
573
0
    ; reserve space for new float
float2.dasm16
574
0
    ;---------------------------------------
float2.dasm16
575
1
176a
9701
    set push, SIZEOF_FLOAT
float2.dasm16
576
2
176b
7f01
176c
0040
    set push, TYPE_FLOAT
float2.dasm16
577
2
176d
7c20
176e
21d3
    jsr alloc
float2.dasm16
578
2
176f
0ea1
1770
ffff
    set [z-1], x
float2.dasm16
579
1
1771
0ce1
    set j, x
float2.dasm16
580
0

float2.dasm16
581
0
    ;---------------------------------------
float2.dasm16
582
0
    ; get value pointers
float2.dasm16
583
0
    ;---------------------------------------
float2.dasm16
584
1
1772
38c1
    set i, [i]
float2.dasm16
585
1
1773
3ce1
    set j, [j]
float2.dasm16
586
0

float2.dasm16
587
0
    ;---------------------------------------
float2.dasm16
588
0
    ; set sign
float2.dasm16
589
0
    ;---------------------------------------
float2.dasm16
590
2
1774
7de1
1775
fffe
    set [j + FLOAT_TYPE], FLOAT_TYPE_PNUM
float2.dasm16
591
3
1776
56b3
1777
fffe
1778
000a
    ifn [z+10], [z-2]
float2.dasm16
592
1
1779
8de1
        set [j + FLOAT_TYPE], FLOAT_TYPE_NNUM
float2.dasm16
593
0
        
float2.dasm16
594
0
    ;---------------------------------------
float2.dasm16
595
0
    ; calculate exp
float2.dasm16
596
0
    ;---------------------------------------
float2.dasm16
597
1
177a
3841
    set c, [i]          ; int size
float2.dasm16
598
0

float2.dasm16
599
0
    ; every word of int contributes 16 bits for exp
float2.dasm16
600
1
177b
944f
    shl c, 4            ; x16
float2.dasm16
601
2
177c
7c42
177d
7fff
    add c, 0x7fff
float2.dasm16
602
0

float2.dasm16
603
0
    ; get amount of bit shifting for normalization
float2.dasm16
604
2
177e
5821
177f
0001
    set b, [i+1]     ; msw
float2.dasm16
605
2
1780
7c20
1781
1a4e
    jsr float__nlz16
float2.dasm16
606
0

float2.dasm16
607
0
    ; calculate final exp
float2.dasm16
608
1
1782
0043
    sub c, a
float2.dasm16
609
2
1783
0ae1
1784
0001
    set [j + FLOAT_EXP], c
float2.dasm16
610
0

float2.dasm16
611
0
    ;---------------------------------------
float2.dasm16
612
0
    ; shift mantissa 22 cycles
float2.dasm16
613
0
    ;---------------------------------------
float2.dasm16
614
3
1785
5ae1
1786
0001
1787
0002
    set [j + FLOAT_HIGH], [i + INT_DATA]
float2.dasm16
615
2
1788
02ef
1789
0002
    shl [j + FLOAT_HIGH], a
float2.dasm16
616
0

float2.dasm16
617
2
178a
86e1
178b
0003
    set [j + FLOAT_LOW], 0
float2.dasm16
618
1
178c
89d4
    ifg [i], 1
float2.dasm16
619
3
178d
5ae1
178e
0002
178f
0003
        set [j + FLOAT_LOW], [i + INT_DATA + 1]
float2.dasm16
620
0

float2.dasm16
621
2
1790
02ef
1791
0003
    shl [j + FLOAT_LOW], a
float2.dasm16
622
2
1792
76eb
1793
0002
    bor [j + FLOAT_HIGH], ex
float2.dasm16
623
0

float2.dasm16
624
1
1794
8421
    set b, 0
float2.dasm16
625
1
1795
8dd4
    ifg [i], 2
float2.dasm16
626
2
1796
5821
1797
0003
        set b, [i + INT_DATA + 2]
float2.dasm16
627
0

float2.dasm16
628
1
1798
002f
    shl b, a
float2.dasm16
629
2
1799
76eb
179a
0003
    bor [j + FLOAT_LOW], ex
float2.dasm16
630
0

float2.dasm16
631
2
179b
5461
179c
ffff
    set x, [z-1]
float2.dasm16
632
2
179d
7f81
179e
2026
    set pc, postamble
float2.dasm16
633
0

float2.dasm16
634
0
;----------------------------------------------------------------
float2.dasm16
635
0
; struct handle *float__to_int(struct handle *f)
float2.dasm16
636
0
;----------------------------------------------------------------
float2.dasm16
637
0
:float__to_int
float2.dasm16
638
1
179f
8b01
    set push, 1
float2.dasm16
639
1
17a0
8b01
    set push, 1
float2.dasm16
640
2
17a1
7c20
17a2
2039
    jsr preamble
float2.dasm16
641
0

float2.dasm16
642
0
    ;---------------------------------------
float2.dasm16
643
0
    ; special cases
float2.dasm16
644
0
    ;---------------------------------------
float2.dasm16
645
2
17a3
5481
17a4
000a
    set y, [z+10]                ; struct handle *float
float2.dasm16
646
1
17a5
3081
    set y, [y]                    ; struct float *
float2.dasm16
647
0

float2.dasm16
648
2
17a6
7d92
17a7
8000
    ife [y + FLOAT_TYPE], FLOAT_TYPE_NAN
float2.dasm16
649
2
17a8
7c20
17a9
00c6
        jsr recover
float2.dasm16
650
0
        ; :ERROR_DEF: cannot convert NaN to integer
float2.dasm16
651
2
17aa
7d92
17ab
fffd
    ife [y + FLOAT_TYPE], FLOAT_TYPE_PINF
float2.dasm16
652
2
17ac
7c20
17ad
00c6
        jsr recover
float2.dasm16
653
0
        ; :ERROR_DEF: cannot convert Inf to integer
float2.dasm16
654
1
17ae
9192
    ife [y + FLOAT_TYPE], FLOAT_TYPE_NINF
float2.dasm16
655
2
17af
7c20
17b0
00c6
        jsr recover
float2.dasm16
656
0
        ; :ERROR_DEF: cannot convert -Inf to integer
float2.dasm16
657
0

float2.dasm16
658
2
17b1
7c61
17b2
02a3
    set x, INT_0
float2.dasm16
659
1
17b3
8192
    ife [y + FLOAT_TYPE], FLOAT_TYPE_PZERO
float2.dasm16
660
2
17b4
7f81
17b5
2026
        set pc, postamble
float2.dasm16
661
1
17b6
8992
    ife [y + FLOAT_TYPE], FLOAT_TYPE_NZERO
float2.dasm16
662
2
17b7
7f81
17b8
2026
        set pc, postamble        ; -0 is just 0
float2.dasm16
663
0

float2.dasm16
664
2
17b9
5001
17ba
0001
    set a, [y + FLOAT_EXP]       ; a = float.exp
float2.dasm16
665
2
17bb
03f4
17bc
8000
    ifg 0x8000, a                ; if float < 1
float2.dasm16
666
2
17bd
7f81
17be
2026
        set pc, postamble        ;   return 0
float2.dasm16
667
0

float2.dasm16
668
0
    ;---------------------------------------
float2.dasm16
669
0
    ; calculate space requirement for int
float2.dasm16
670
0
    ;---------------------------------------
float2.dasm16
671
2
17bf
7c03
17c0
8000
    sub a, 0x8000
float2.dasm16
672
1
17c1
940d
    shr a, 4                    ; div a by 16
float2.dasm16
673
1
17c2
8802
    add a, 1                    ; a = number of words required for int representation
float2.dasm16
674
0

float2.dasm16
675
0
    ;---------------------------------------
float2.dasm16
676
0
    ; allocate space for int
float2.dasm16
677
0
    ;---------------------------------------
float2.dasm16
678
1
17c3
0301
    set push, a
float2.dasm16
679
2
17c4
7f01
17c5
0020
    set push, TYPE_INT
float2.dasm16
680
2
17c6
7c20
17c7
2770
    jsr array_create
float2.dasm16
681
2
17c8
0ea1
17c9
ffff
    set [z-1], x
float2.dasm16
682
0

float2.dasm16
683
0
    ;---------------------------------------
float2.dasm16
684
0
    ; get value pointers
float2.dasm16
685
0
    ;---------------------------------------
float2.dasm16
686
2
17ca
54c1
17cb
000a
    set i, [z+10]
float2.dasm16
687
1
17cc
38c1
    set i, [i]
float2.dasm16
688
0

float2.dasm16
689
1
17cd
2ce1
    set j, [x]
float2.dasm16
690
0

float2.dasm16
691
0
    ;---------------------------------------
float2.dasm16
692
0
    ; calculate amount of bit shifting
float2.dasm16
693
0
    ;---------------------------------------
float2.dasm16
694
1
17ce
0021
    set b, a                    ; b = amount of bit shifting required
float2.dasm16
695
1
17cf
942f
    shl b, 4                    ; mul a, 16
float2.dasm16
696
2
17d0
7c22
17d1
7fff
    add b, 0x7fff
float2.dasm16
697
2
17d2
5823
17d3
0001
    sub b, [i + FLOAT_EXP]      ; shift amount
float2.dasm16
698
0

float2.dasm16
699
3
17d4
5ae1
17d5
0002
17d6
0001
    set [j + INT_DATA], [i + FLOAT_HIGH]
float2.dasm16
700
2
17d7
06ed
17d8
0001
    shr [j + INT_DATA], b
float2.dasm16
701
0

float2.dasm16
702
1
17d9
89f2
    ife [j], 1
float2.dasm16
703
2
17da
7f81
17db
17e4
        set pc, float__to_int__finish
float2.dasm16
704
0
 
float2.dasm16
705
1
17dc
7481
    set y, ex
float2.dasm16
706
3
17dd
5ae1
17de
0003
17df
0002
    set [j + INT_DATA + 1], [i + FLOAT_LOW]
float2.dasm16
707
2
17e0
06ed
17e1
0002
    shr [j + INT_DATA + 1], b
float2.dasm16
708
2
17e2
12eb
17e3
0002
    bor [j + INT_DATA + 1], y
float2.dasm16
709
0

float2.dasm16
710
0
:float__to_int__finish
float2.dasm16
711
1
17e4
85d7
    ifu [i], 0
float2.dasm16
712
2
17e5
7f81
17e6
2026
        set pc, postamble
float2.dasm16
713
0
        
float2.dasm16
714
1
17e7
0f01
    set push, x
float2.dasm16
715
2
17e8
7c20
17e9
24c3
    jsr int_negate
float2.dasm16
716
0
    
float2.dasm16
717
2
17ea
7f81
17eb
2026
    set pc, postamble
float2.dasm16
718
0

float2.dasm16
719
0
;----------------------------------------------------------------
float2.dasm16
720
0
; uint float__to_uint(struct handle *float)
float2.dasm16
721
0
;----------------------------------------------------------------
float2.dasm16
722
0
:float__to_uint
float2.dasm16
723
1
17ec
8b01
    set push, 1
float2.dasm16
724
1
17ed
8b01
    set push, 1
float2.dasm16
725
2
17ee
7c20
17ef
2039
    jsr preamble
float2.dasm16
726
0

float2.dasm16
727
2
17f0
5701
17f1
000a
    set push, [z+10]
float2.dasm16
728
2
17f2
7c20
17f3
179f
    jsr float__to_int
float2.dasm16
729
2
17f4
0ea1
17f5
ffff
    set [z-1], x
float2.dasm16
730
0
    
float2.dasm16
731
1
17f6
0f01
    set push, x
float2.dasm16
732
2
17f7
7c20
17f8
22bc
    jsr int_to_int16    ;int_to_uint
float2.dasm16
733
0
    
float2.dasm16
734
2
17f9
7f81
17fa
2026
    set pc, postamble
float2.dasm16
735
0

float2.dasm16
736
0
;----------------------------------------------------------------
float2.dasm16
737
0
; struct handle *float__from_uint(uint i)
float2.dasm16
738
0
;----------------------------------------------------------------
float2.dasm16
739
0
:float__from_uint
float2.dasm16
740
1
17fb
8b01
    set push, 1
float2.dasm16
741
1
17fc
8b01
    set push, 1
float2.dasm16
742
2
17fd
7c20
17fe
2039
    jsr preamble
float2.dasm16
743
0
    
float2.dasm16
744
2
17ff
5701
1800
000a
    set push, [z+10]
float2.dasm16
745
2
1801
7c20
1802
22a2
    jsr uint16_to_int    ;int_from_uint
float2.dasm16
746
2
1803
0ea1
1804
ffff
    set [z-1], x
float2.dasm16
747
0
    
float2.dasm16
748
2
1805
5701
1806
ffff
    set push, [z-1]
float2.dasm16
749
2
1807
7c20
1808
1757
    jsr float__from_int
float2.dasm16
750
0
    
float2.dasm16
751
2
1809
7f81
180a
2026
    set pc, postamble
float2.dasm16
752
0

float2.dasm16
753
0
;----------------------------------------------------------------
float2.dasm16
754
0
; struct handle *float__random(struct handle *min, struct handle *max)
float2.dasm16
755
0
;----------------------------------------------------------------
float2.dasm16
756
0
:float__random
float2.dasm16
757
1
180b
8f01
    set push, 2
float2.dasm16
758
1
180c
8f01
    set push, 2
float2.dasm16
759
2
180d
7c20
180e
2039
    jsr preamble
float2.dasm16
760
0
    
float2.dasm16
761
1
180f
9701
    set push, SIZEOF_FLOAT
float2.dasm16
762
2
1810
7f01
1811
0040
    set push, TYPE_FLOAT
float2.dasm16
763
2
1812
7c20
1813
21d3
    jsr alloc
float2.dasm16
764
2
1814
0ea1
1815
ffff
    set [z-1], x
float2.dasm16
765
0

float2.dasm16
766
1
1816
2cc1
    set i, [x]
float2.dasm16
767
2
1817
7dc1
1818
fffe
    set [i + FLOAT_TYPE], FLOAT_TYPE_PNUM
float2.dasm16
768
3
1819
7ec1
181a
8000
181b
0001
    set [i + FLOAT_EXP], 0x8000
float2.dasm16
769
0

float2.dasm16
770
2
181c
7c20
181d
23ed
    jsr int_rnd_lfsr
float2.dasm16
771
2
181e
7c6b
181f
8000
    bor x, 0x8000
float2.dasm16
772
2
1820
0ec1
1821
0002
    set [i + FLOAT_HIGH], x
float2.dasm16
773
0

float2.dasm16
774
2
1822
7c20
1823
23ed
    jsr int_rnd_lfsr
float2.dasm16
775
2
1824
0ec1
1825
0003
    set [i + FLOAT_LOW], x
float2.dasm16
776
0

float2.dasm16
777
0
    ; transpose 1.0-2.0 to 0.0-1.0    
float2.dasm16
778
2
1826
5701
1827
ffff
    set push, [z-1]
float2.dasm16
779
2
1828
7f01
1829
0313
    set push, FLOAT_1
float2.dasm16
780
2
182a
7c20
182b
164d
    jsr float__sub
float2.dasm16
781
2
182c
0ea1
182d
ffff
    set [z-1], x
float2.dasm16
782
0

float2.dasm16
783
0
    ; scaling factor
float2.dasm16
784
2
182e
5701
182f
000a
    set push, [z+10]
float2.dasm16
785
2
1830
5701
1831
000b
    set push, [z+11]
float2.dasm16
786
2
1832
7c20
1833
164d
    jsr float__sub
float2.dasm16
787
2
1834
0ea1
1835
fffe
    set [z-2], x
float2.dasm16
788
0

float2.dasm16
789
0
    ; scale
float2.dasm16
790
2
1836
5701
1837
ffff
    set push, [z-1]
float2.dasm16
791
2
1838
5701
1839
fffe
    set push, [z-2]
float2.dasm16
792
2
183a
7c20
183b
165f
    jsr float__mul
float2.dasm16
793
2
183c
0ea1
183d
ffff
    set [z-1], x
float2.dasm16
794
0

float2.dasm16
795
0
    ; transpose
float2.dasm16
796
2
183e
5701
183f
ffff
    set push, [z-1]
float2.dasm16
797
2
1840
5701
1841
000b
    set push, [z+11]
float2.dasm16
798
2
1842
7c20
1843
15db
    jsr float__add
float2.dasm16
799
0

float2.dasm16
800
2
1844
7f81
1845
2026
    set pc, postamble
float2.dasm16
801
0

float2.dasm16
802
0
;----------------------------------------------------------------
float2.dasm16
803
0
; uint float__pow(struct handle *float, struct handle *int)
float2.dasm16
804
0
;----------------------------------------------------------------
float2.dasm16
805
0
:float__pow
float2.dasm16
806
1
1846
8f01
    set push, 2
float2.dasm16
807
1
1847
8f01
    set push, 2
float2.dasm16
808
2
1848
7c20
1849
2039
    jsr preamble
float2.dasm16
809
0

float2.dasm16
810
1
184a
8801
    set a, TRUE        ; positive
float2.dasm16
811
0

float2.dasm16
812
2
184b
5701
184c
000a
    set push, [z+10]
float2.dasm16
813
2
184d
7c20
184e
22bc
    jsr int_to_int16
float2.dasm16
814
1
184f
0c41
    set c, x
float2.dasm16
815
0

float2.dasm16
816
2
1850
7c61
1851
0313
    set x, FLOAT_1
float2.dasm16
817
1
1852
8452
    ife c, 0
float2.dasm16
818
2
1853
7f81
1854
2026
        set pc, postamble
float2.dasm16
819
0

float2.dasm16
820
2
1855
7c51
1856
8000
    ifc c, 0x8000
float2.dasm16
821
2
1857
7f81
1858
185c
        set pc, float__pow__calc
float2.dasm16
822
0

float2.dasm16
823
1
1859
804c
    xor c, 0xffff
float2.dasm16
824
1
185a
8842
    add c, 1
float2.dasm16
825
1
185b
8401
    set a, FALSE
float2.dasm16
826
0

float2.dasm16
827
0
:float__pow__calc
float2.dasm16
828
3
185c
56a1
185d
000b
185e
ffff
    set [z-1], [z+11]             ; p
float2.dasm16
829
3
185f
7ea1
1860
0313
1861
fffe
    set [z-2], FLOAT_1            ; r
float2.dasm16
830
0
    
float2.dasm16
831
0
:float__pow__loop
float2.dasm16
832
1
1862
8452
    ife c, 0
float2.dasm16
833
2
1863
7f81
1864
187b
        set pc, float__pow__break
float2.dasm16
834
0

float2.dasm16
835
1
1865
8851
    ifc c, 1
float2.dasm16
836
2
1866
7f81
1867
1870
        set pc, float__pow__skip
float2.dasm16
837
0
        
float2.dasm16
838
2
1868
5701
1869
fffe
    set push, [z-2]
float2.dasm16
839
2
186a
5701
186b
ffff
    set push, [z-1]
float2.dasm16
840
2
186c
7c20
186d
165f
    jsr float__mul
float2.dasm16
841
2
186e
0ea1
186f
fffe
    set [z-2], x
float2.dasm16
842
0
    
float2.dasm16
843
0
:float__pow__skip
float2.dasm16
844
2
1870
5701
1871
ffff
    set push, [z-1]
float2.dasm16
845
2
1872
5701
1873
ffff
    set push, [z-1]
float2.dasm16
846
2
1874
7c20
1875
165f
    jsr float__mul
float2.dasm16
847
2
1876
0ea1
1877
ffff
    set [z-1], x
float2.dasm16
848
0

float2.dasm16
849
1
1878
884d
    shr c, 1                ; c / 2
float2.dasm16
850
2
1879
7f81
187a
1862
    set pc, float__pow__loop
float2.dasm16
851
0

float2.dasm16
852
0
:float__pow__break
float2.dasm16
853
2
187b
5461
187c
fffe
    set x, [z-2]
float2.dasm16
854
0

float2.dasm16
855
1
187d
8812
    ife a, TRUE
float2.dasm16
856
2
187e
7f81
187f
2026
        set pc, postamble    
float2.dasm16
857
0

float2.dasm16
858
2
1880
7f01
1881
0313
    set push, FLOAT_1
float2.dasm16
859
1
1882
0f01
    set push, x
float2.dasm16
860
2
1883
7c20
1884
16d2
    jsr float__div
float2.dasm16
861
0

float2.dasm16
862
2
1885
7f81
1886
2026
    set pc, postamble    
float2.dasm16
863
0

float2.dasm16
864
0
;----------------------------------------------------------------
float2.dasm16
865
0
; struct handle *float__from_str(struct handle *str)
float2.dasm16
866
0
;----------------------------------------------------------------
float2.dasm16
867
0
#define FP_STATE_START            1
float2.dasm16
868
0
#define FP_STATE_SIGN            2
float2.dasm16
869
0
#define FP_STATE_DIGIT_WHOLE    4
float2.dasm16
870
0
#define FP_STATE_DECIMAL_POINT    8
float2.dasm16
871
0
#define FP_STATE_DIGIT_DECIMAL    16
float2.dasm16
872
0
#define FP_STATE_E                32
float2.dasm16
873
0
#define FP_STATE_EXPONENT_SIGN    64
float2.dasm16
874
0
#define FP_STATE_EXPONENT_DIGIT    128
float2.dasm16
875
0

float2.dasm16
876
0
#define FPV_EXPONENT_NEGATIVE    -2
float2.dasm16
877
0
#define FPV_EXPONENT            -3
float2.dasm16
878
0
#define FPV_EXPONENT_MODIFIER    -4
float2.dasm16
879
0
#define FPV_STATE                -5
float2.dasm16
880
0

float2.dasm16
881
0
:float__from_str
float2.dasm16
882
1
1887
8b01
    set push, 1            ; sizeof(args)
float2.dasm16
883
1
1888
8b01
    set push, 1            ; sizeof(refs)
float2.dasm16
884
2
1889
7c20
188a
2039
    jsr preamble
float2.dasm16
885
0

float2.dasm16
886
2
188b
5401
188c
000a
    set a, [z+10]        ; struct handle *str
float2.dasm16
887
0

float2.dasm16
888
0
    ;---------------------------------------
float2.dasm16
889
0
    ; handle nan and infinities
float2.dasm16
890
0
    ;---------------------------------------
float2.dasm16
891
1
188d
2021
    set b, [a]            ; struct string *
float2.dasm16
892
1
188e
2441
    set c, [b]            ; str.len
float2.dasm16
893
0
    
float2.dasm16
894
1
188f
8c54
    ifg c, 2
float2.dasm16
895
3
1890
7e32
1891
0069
1892
0001
        ife [b+1], 'i'
float2.dasm16
896
3
1893
7e32
1894
006e
1895
0002
            ife [b+2], 'n'
float2.dasm16
897
3
1896
7e32
1897
0066
1898
0003
                ife [b+3], 'f'
float2.dasm16
898
2
1899
7f81
189a
1b13
                    set pc, float__return_pinf
float2.dasm16
899
0

float2.dasm16
900
1
189b
8c54
    ifg c, 2
float2.dasm16
901
3
189c
7e32
189d
006e
189e
0001
        ife [b+1], 'n'
float2.dasm16
902
3
189f
7e32
18a0
0061
18a1
0002
            ife [b+2], 'a'
float2.dasm16
903
3
18a2
7e32
18a3
006e
18a4
0003
                ife [b+3], 'n'
float2.dasm16
904
2
18a5
7f81
18a6
1b0b
                    set pc, float__return_nan
float2.dasm16
905
0

float2.dasm16
906
1
18a7
9054
    ifg c, 3
float2.dasm16
907
3
18a8
7e32
18a9
002d
18aa
0001
        ife [b+1], '-'
float2.dasm16
908
3
18ab
7e32
18ac
0069
18ad
0002
            ife [b+2], 'i'
float2.dasm16
909
3
18ae
7e32
18af
006e
18b0
0003
                ife [b+3], 'n'
float2.dasm16
910
3
18b1
7e32
18b2
0066
18b3
0004
                    ife [b+4], 'f'
float2.dasm16
911
2
18b4
7f81
18b5
1b17
                        set pc, float__return_ninf                
float2.dasm16
912
0

float2.dasm16
913
1
18b6
9054
    ifg c, 3
float2.dasm16
914
3
18b7
7e32
18b8
002b
18b9
0001
        ife [b+1], '+'
float2.dasm16
915
3
18ba
7e32
18bb
0069
18bc
0002
            ife [b+2], 'i'
float2.dasm16
916
3
18bd
7e32
18be
006e
18bf
0003
                ife [b+3], 'n'
float2.dasm16
917
3
18c0
7e32
18c1
0066
18c2
0004
                    ife [b+4], 'f'
float2.dasm16
918
2
18c3
7f81
18c4
1b13
                        set pc, float__return_pinf
float2.dasm16
919
0

float2.dasm16
920
0
    ;---------------------------------------
float2.dasm16
921
0
    ; handle numbers
float2.dasm16
922
0
    ;---------------------------------------
float2.dasm16
923
3
18c5
7ea1
18c6
030d
18c7
ffff
    set [z-1], FLOAT_0
float2.dasm16
924
0

float2.dasm16
925
1
18c8
8701
    set push, FALSE                ; FPV_EXPONENT_NEGATIVE
float2.dasm16
926
1
18c9
8701
    set push, 0                    ; FPV_EXPONENT
float2.dasm16
927
1
18ca
8701
    set push, 0                    ; FPV_EXPONENT_MODIFIER
float2.dasm16
928
1
18cb
8b01
    set push, FP_STATE_START    ; FPV_STATE
float2.dasm16
929
0

float2.dasm16
930
1
18cc
8421
    set b, 0                    ; index in str
float2.dasm16
931
0

float2.dasm16
932
0
:ffs_loop
float2.dasm16
933
2
18cd
7c20
18ce
277f
    jsr array__get
float2.dasm16
934
1
18cf
8822
    add b, 1
float2.dasm16
935
1
18d0
0c41
    set c, x
float2.dasm16
936
0

float2.dasm16
937
2
18d1
7c52
18d2
002b
    ife c, '+'
float2.dasm16
938
2
18d3
7f81
18d4
194b
        set pc, ffs_plus
float2.dasm16
939
2
18d5
7c52
18d6
002d
    ife c, '-'
float2.dasm16
940
2
18d7
7f81
18d8
192f
        set pc, ffs_minus
float2.dasm16
941
2
18d9
7c52
18da
0065
    ife c, 'e'
float2.dasm16
942
2
18db
7f81
18dc
195f
        set pc, ffs_exponent
float2.dasm16
943
2
18dd
7c52
18de
0045
    ife c, 'E'
float2.dasm16
944
2
18df
7f81
18e0
195f
        set pc, ffs_exponent
float2.dasm16
945
2
18e1
7c52
18e2
002e
    ife c, '.'
float2.dasm16
946
2
18e3
7f81
18e4
1957
        set pc, ffs_decimal_point
float2.dasm16
947
0

float2.dasm16
948
2
18e5
7c54
18e6
0039
    ifg c, '9'                        ; not a number?
float2.dasm16
949
2
18e7
7f81
18e8
1968
        set pc, ffs_end
float2.dasm16
950
2
18e9
7c56
18ea
0030
    ifl c, '0'                        ; not a number?
float2.dasm16
951
2
18eb
7f81
18ec
1968
        set pc, ffs_end
float2.dasm16
952
0

float2.dasm16
953
2
18ed
7c43
18ee
0030
    sub c, '0'                        ; convert char to int
float2.dasm16
954
0

float2.dasm16
955
3
18ef
7eb0
18f0
0060
18f1
fffb
    ifb [z + FPV_STATE], FP_STATE_E + FP_STATE_EXPONENT_SIGN
float2.dasm16
956
2
18f2
7f81
18f3
1918
        set pc, ffs_exponent_number
float2.dasm16
957
2
18f4
e6b0
18f5
fffb
    ifb [z + FPV_STATE], FP_STATE_DIGIT_DECIMAL + FP_STATE_DECIMAL_POINT    ; if in fraction part
float2.dasm16
958
2
18f6
7f81
18f7
18fe
        set pc, ffs_fraction
float2.dasm16
959
2
18f8
a2b0
18f9
fffb
    ifb [z + FPV_STATE], FP_STATE_START + FP_STATE_SIGN + FP_STATE_DIGIT_WHOLE    ; if in whole number part
float2.dasm16
960
2
18fa
7f81
18fb
1904
        set pc, ffs_whole_number
float2.dasm16
961
0

float2.dasm16
962
2
18fc
7f81
18fd
1968
    set pc, ffs_end                ; wrong state for a number
float2.dasm16
963
0

float2.dasm16
964
0
:ffs_fraction
float2.dasm16
965
0
    ; parse digit to fraction
float2.dasm16
966
2
18fe
c6a1
18ff
fffb
    set [z + FPV_STATE], FP_STATE_DIGIT_DECIMAL                        ; set state
float2.dasm16
967
0
    
float2.dasm16
968
0
;    ife [z + FPV_NUM_SIGNIFICANTS], 5        ; ignore non-significant decimals 
float2.dasm16
969
0
;        set pc, ffs_loop
float2.dasm16
970
0
    
float2.dasm16
971
2
1900
8aa3
1901
fffc
    sub [z + FPV_EXPONENT_MODIFIER], 1
float2.dasm16
972
2
1902
7f81
1903
1906
    set pc, ffs_add_significant
float2.dasm16
973
0

float2.dasm16
974
0
:ffs_whole_number
float2.dasm16
975
2
1904
96a1
1905
fffb
    set [z + FPV_STATE], FP_STATE_DIGIT_WHOLE                            ; set state
float2.dasm16
976
0

float2.dasm16
977
0
    ; ignore leading zeros
float2.dasm16
978
0
;    ife c, 0                                    ; curchar = '0'
float2.dasm16
979
0
;        ife [z + FPV_NUM_SIGNIFICANTS], 0
float2.dasm16
980
0
;            set pc, ffs_loop
float2.dasm16
981
0

float2.dasm16
982
0
;    ife [z + FPV_NUM_SIGNIFICANTS], 5
float2.dasm16
983
0
;        set pc, ffs_significant_full
float2.dasm16
984
0

float2.dasm16
985
0
:ffs_add_significant
float2.dasm16
986
2
1906
5701
1907
ffff
    set push, [z-1]
float2.dasm16
987
2
1908
7f01
1909
0349
    set push, FLOAT_10
float2.dasm16
988
2
190a
7c20
190b
165f
    jsr float__mul
float2.dasm16
989
2
190c
0ea1
190d
ffff
    set [z-1], x
float2.dasm16
990
0

float2.dasm16
991
2
190e
5701
190f
ffff
    set push, [z-1]
float2.dasm16
992
2
1910
4b01
1911
0303
    set push, [FLOAT_TABLE + c]
float2.dasm16
993
2
1912
7c20
1913
15db
    jsr float__add
float2.dasm16
994
2
1914
0ea1
1915
ffff
    set [z-1], x
float2.dasm16
995
0

float2.dasm16
996
2
1916
7f81
1917
18cd
    set pc, ffs_loop
float2.dasm16
997
0

float2.dasm16
998
0
:ffs_exponent_number
float2.dasm16
999
3
1918
7ea1
1919
0080
191a
fffb
    set [z + FPV_STATE], FP_STATE_EXPONENT_DIGIT    ; set state
float2.dasm16
1000
0

float2.dasm16
1001
2
191b
aea4
191c
fffd
    mul [z + FPV_EXPONENT], 10
float2.dasm16
1002
1
191d
87b3
    ifn ex, 0
float2.dasm16
1003
2
191e
7f81
191f
1927
        set pc, ffs_overflow
float2.dasm16
1004
0
        
float2.dasm16
1005
2
1920
0aa2
1921
fffd
    add [z + FPV_EXPONENT], c
float2.dasm16
1006
1
1922
87b3
    ifn ex, 0
float2.dasm16
1007
2
1923
7f81
1924
1927
        set pc, ffs_overflow
float2.dasm16
1008
0

float2.dasm16
1009
2
1925
7f81
1926
18cd
    set pc, ffs_loop
float2.dasm16
1010
0

float2.dasm16
1011
0
:ffs_overflow
float2.dasm16
1012
2
1927
5461
1928
ffff
    set x, [z-1]
float2.dasm16
1013
2
1929
8ab2
192a
fffe
    ife [z + FPV_EXPONENT_NEGATIVE], TRUE
float2.dasm16
1014
2
192b
7f81
192c
1b1b
        set pc, float__return_zero
float2.dasm16
1015
2
192d
7f81
192e
1b0f
    set pc, float__return_inf
float2.dasm16
1016
0

float2.dasm16
1017
0
:ffs_minus
float2.dasm16
1018
2
192f
8ab0
1930
fffb
    ifb [z + FPV_STATE], FP_STATE_START
float2.dasm16
1019
2
1931
7f81
1932
193a
        set pc, ffs_mantissa_minus
float2.dasm16
1020
3
1933
7eb0
1934
0020
1935
fffb
    ifb [z + FPV_STATE], FP_STATE_E
float2.dasm16
1021
2
1936
7f81
1937
1944
        set pc, ffs_exponent_minus
float2.dasm16
1022
2
1938
7f81
1939
1968
    set pc, ffs_end
float2.dasm16
1023
0
:ffs_mantissa_minus
float2.dasm16
1024
0
    ; handle leading minus
float2.dasm16
1025
2
193a
8ea1
193b
fffb
    set [z + FPV_STATE], FP_STATE_SIGN
float2.dasm16
1026
0
    
float2.dasm16
1027
2
193c
5701
193d
ffff
    set push, [z-1]
float2.dasm16
1028
2
193e
7c20
193f
1578
    jsr float__negate
float2.dasm16
1029
2
1940
0ea1
1941
ffff
    set [z-1], x
float2.dasm16
1030
0

float2.dasm16
1031
2
1942
7f81
1943
18cd
    set pc, ffs_loop
float2.dasm16
1032
0
:ffs_exponent_minus
float2.dasm16
1033
3
1944
7ea1
1945
0040
1946
fffb
    set [z + FPV_STATE], FP_STATE_EXPONENT_SIGN
float2.dasm16
1034
2
1947
8aa1
1948
fffe
    set [z + FPV_EXPONENT_NEGATIVE], TRUE
float2.dasm16
1035
2
1949
7f81
194a
18cd
    set pc, ffs_loop
float2.dasm16
1036
0
    
float2.dasm16
1037
0
:ffs_plus
float2.dasm16
1038
2
194b
8ab0
194c
fffb
    ifb [z + FPV_STATE], FP_STATE_START
float2.dasm16
1039
2
194d
8ea1
194e
fffb
        set [z + FPV_STATE], FP_STATE_SIGN
float2.dasm16
1040
3
194f
7eb0
1950
0020
1951
fffb
    ifb [z + FPV_STATE], FP_STATE_E
float2.dasm16
1041
3
1952
7ea1
1953
0040
1954
fffb
        set [z + FPV_STATE], FP_STATE_EXPONENT_SIGN
float2.dasm16
1042
2
1955
7f81
1956
1968
    set pc, ffs_end
float2.dasm16
1043
0
    
float2.dasm16
1044
0
:ffs_decimal_point
float2.dasm16
1045
2
1957
a2b1
1958
fffb
    ifc [z + FPV_STATE], FP_STATE_START + FP_STATE_SIGN + FP_STATE_DIGIT_WHOLE
float2.dasm16
1046
2
1959
7f81
195a
1968
        set pc, ffs_end
float2.dasm16
1047
0

float2.dasm16
1048
2
195b
a6a1
195c
fffb
    set [z + FPV_STATE], FP_STATE_DECIMAL_POINT
float2.dasm16
1049
2
195d
7f81
195e
18cd
    set pc, ffs_loop
float2.dasm16
1050
0
    
float2.dasm16
1051
0
:ffs_exponent
float2.dasm16
1052
2
195f
e2b1
1960
fffb
    ifc [z + FPV_STATE], FP_STATE_START + FP_STATE_SIGN + FP_STATE_DIGIT_WHOLE + FP_STATE_DIGIT_DECIMAL
float2.dasm16
1053
2
1961
7f81
1962
1968
        set pc, ffs_end
float2.dasm16
1054
3
1963
7ea1
1964
0020
1965
fffb
    set [z + FPV_STATE], FP_STATE_E
float2.dasm16
1055
2
1966
7f81
1967
18cd
    set pc, ffs_loop
float2.dasm16
1056
0

float2.dasm16
1057
0
:ffs_end
float2.dasm16
1058
3
1968
7eb0
1969
0063
196a
fffb
    ifb [z + FPV_STATE], FP_STATE_START + FP_STATE_SIGN + FP_STATE_E + FP_STATE_EXPONENT_SIGN
float2.dasm16
1059
2
196b
7c20
196c
00c6
        jsr recover
float2.dasm16
1060
0
        ; :ERROR_DEF: invalid number format
float2.dasm16
1061
0

float2.dasm16
1062
1
196d
87a1
    set ex, 0
float2.dasm16
1063
2
196e
86b2
196f
fffe
    ife [z + FPV_EXPONENT_NEGATIVE], FALSE
float2.dasm16
1064
3
1970
7ea2
1971
8000
1972
fffd
        add [z + FPV_EXPONENT], 0x8000
float2.dasm16
1065
0

float2.dasm16
1066
1
1973
87b3
    ifn ex, 0
float2.dasm16
1067
2
1974
7f81
1975
1927
        set pc, ffs_overflow
float2.dasm16
1068
0

float2.dasm16
1069
3
1976
56a2
1977
fffc
1978
fffd
    add [z + FPV_EXPONENT], [z + FPV_EXPONENT_MODIFIER]
float2.dasm16
1070
3
1979
7eb0
197a
8000
197b
fffc
    ifb [z + FPV_EXPONENT_MODIFIER], 0x8000
float2.dasm16
1071
1
197c
87b2
        ife ex, 0
float2.dasm16
1072
2
197d
7f81
197e
1927
            set pc, ffs_overflow
float2.dasm16
1073
3
197f
7eb1
1980
8000
1981
fffc
    ifc [z + FPV_EXPONENT_MODIFIER], 0x8000
float2.dasm16
1074
1
1982
87b3
        ifn ex, 0
float2.dasm16
1075
2
1983
7f81
1984
1927
            set pc, ffs_overflow
float2.dasm16
1076
0
    
float2.dasm16
1077
2
1985
5461
1986
ffff
    set x, [z-1]
float2.dasm16
1078
0

float2.dasm16
1079
2
1987
7c01
1988
165f
    set a, float__mul
float2.dasm16
1080
1
1989
8021
    set b, -1
float2.dasm16
1081
3
198a
7eb4
198b
8000
198c
fffd
    ifg [z + FPV_EXPONENT], 0x8000
float2.dasm16
1082
2
198d
7f81
198e
1992
        set pc, ffs_scale_loop
float2.dasm16
1083
0
        
float2.dasm16
1084
2
198f
7c01
1990
16d2
    set a, float__div
float2.dasm16
1085
1
1991
8821
    set b, 1
float2.dasm16
1086
0

float2.dasm16
1087
0
:ffs_scale_loop
float2.dasm16
1088
3
1992
7eb2
1993
8000
1994
fffd
    ife [z + FPV_EXPONENT], 0x8000
float2.dasm16
1089
2
1995
7f81
1996
2026
        set pc, postamble
float2.dasm16
1090
0

float2.dasm16
1091
1
1997
0f01
    set push, x
float2.dasm16
1092
2
1998
7f01
1999
0349
    set push, FLOAT_10
float2.dasm16
1093
1
199a
0020
    jsr a
float2.dasm16
1094
2
199b
0ea1
199c
ffff
    set [z-1], x
float2.dasm16
1095
0

float2.dasm16
1096
2
199d
06a2
199e
fffd
    add [z + FPV_EXPONENT], b
float2.dasm16
1097
2
199f
7f81
19a0
1992
    set pc, ffs_scale_loop
float2.dasm16
1098
0

float2.dasm16
1099
0
:rintti
float2.dasm16
1100
1
19a1
0f01
    set push, x
float2.dasm16
1101
2
19a2
6861
19a3
0002
    set x, [sp+2]
float2.dasm16
1102
1
19a4
2f01
    set push, [x]
float2.dasm16
1103
2
19a5
7c20
19a6
0215
    jsr debug
float2.dasm16
1104
2
19a7
4f01
19a8
0001
    set push, [x+1]
float2.dasm16
1105
2
19a9
7c20
19aa
0215
    jsr debug
float2.dasm16
1106
2
19ab
4f01
19ac
0002
    set push, [x+2]
float2.dasm16
1107
2
19ad
7c20
19ae
0215
    jsr debug
float2.dasm16
1108
2
19af
4f01
19b0
0003
    set push, [x+3]
float2.dasm16
1109
2
19b1
7c20
19b2
0215
    jsr debug
float2.dasm16
1110
1
19b3
6061
    set x, pop
float2.dasm16
1111
1
19b4
6321
    set [sp], pop
float2.dasm16
1112
1
19b5
6381
    set pc, pop
float2.dasm16
1113
0

float2.dasm16
1114
0
;----------------------------------------------------------------
float2.dasm16
1115
0
; struct handle *float__to_str(struct handle *f)
float2.dasm16
1116
0
;----------------------------------------------------------------
float2.dasm16
1117
0
:float__to_str
float2.dasm16
1118
1
19b6
8b01
    set push, 1            ; number of arguments
float2.dasm16
1119
1
19b7
8f01
    set push, 2            ; amount of local variable space
float2.dasm16
1120
2
19b8
7c20
19b9
2039
    jsr preamble
float2.dasm16
1121
0

float2.dasm16
1122
2
19ba
54c1
19bb
000a
    set i, [z+10]
float2.dasm16
1123
1
19bc
38c1
    set i, [i]
float2.dasm16
1124
0

float2.dasm16
1125
1
19bd
8461
    set x, 0
float2.dasm16
1126
2
19be
7dd2
19bf
8000
    ife [i + FLOAT_TYPE], FLOAT_TYPE_NAN
float2.dasm16
1127
2
19c0
7c61
19c1
0369
        set x, STR_NAN
float2.dasm16
1128
2
19c2
7dd2
19c3
fffd
    ife [i + FLOAT_TYPE], FLOAT_TYPE_PINF
float2.dasm16
1129
2
19c4
7c61
19c5
034f
        set x, STR_PINF
float2.dasm16
1130
1
19c6
91d2
    ife [i + FLOAT_TYPE], FLOAT_TYPE_NINF
float2.dasm16
1131
2
19c7
7c61
19c8
0355
        set x, STR_NINF
float2.dasm16
1132
1
19c9
89d2
    ife [i + FLOAT_TYPE], FLOAT_TYPE_NZERO
float2.dasm16
1133
2
19ca
7c61
19cb
0362
        set x, STR_NZERO
float2.dasm16
1134
1
19cc
81d2
    ife [i + FLOAT_TYPE], FLOAT_TYPE_PZERO
float2.dasm16
1135
2
19cd
7c61
19ce
035c
        set x, STR_PZERO
float2.dasm16
1136
1
19cf
8473
    ifn x, 0
float2.dasm16
1137
2
19d0
7f81
19d1
2026
        set pc, postamble
float2.dasm16
1138
0

float2.dasm16
1139
1
19d2
bb01
    set push, 13
float2.dasm16
1140
1
19d3
a701
    set push, TYPE_STR
float2.dasm16
1141
2
19d4
7c20
19d5
21d3
    jsr alloc
float2.dasm16
1142
2
19d6
0ea1
19d7
ffff
    set [z-1], x
float2.dasm16
1143
0

float2.dasm16
1144
2
19d8
5701
19d9
000a
    set push, [z+10]
float2.dasm16
1145
2
19da
7c20
19db
158d
    jsr float__abs
float2.dasm16
1146
2
19dc
0ea1
19dd
fffe
    set [z-2], x
float2.dasm16
1147
0

float2.dasm16
1148
1
19de
8801
    set a, 1        ; a: magnitude
float2.dasm16
1149
1
19df
8421
    set b, 0        ; b: significants
float2.dasm16
1150
0
    
float2.dasm16
1151
3
19e0
56b2
19e1
fffe
19e2
000a
    ife [z+10], [z-2]
float2.dasm16
1152
2
19e3
7f81
19e4
19eb
        set pc, fts_scale_down
float2.dasm16
1153
0

float2.dasm16
1154
2
19e5
5701
19e6
ffff
    set push, [z-1]
float2.dasm16
1155
2
19e7
7f01
19e8
002d
    set push, '-'
float2.dasm16
1156
2
19e9
7c20
19ea
27d8
    jsr array__append
float2.dasm16
1157
0
    
float2.dasm16
1158
0
:fts_scale_down
float2.dasm16
1159
2
19eb
5701
19ec
fffe
    set push, [z-2]
float2.dasm16
1160
2
19ed
7f01
19ee
0349
    set push, FLOAT_10
float2.dasm16
1161
2
19ef
7c20
19f0
15bd
    jsr float__cmp
float2.dasm16
1162
0

float2.dasm16
1163
1
19f1
8072
    ife x, -1
float2.dasm16
1164
2
19f2
7f81
19f3
19ff
        set pc, fts_print
float2.dasm16
1165
0

float2.dasm16
1166
2
19f4
5701
19f5
fffe
    set push, [z-2]
float2.dasm16
1167
2
19f6
7f01
19f7
0349
    set push, FLOAT_10
float2.dasm16
1168
2
19f8
7c20
19f9
16d2
    jsr float__div
float2.dasm16
1169
2
19fa
0ea1
19fb
fffe
    set [z-2], x
float2.dasm16
1170
0
    
float2.dasm16
1171
1
19fc
8802
    add a, 1
float2.dasm16
1172
2
19fd
7f81
19fe
19eb
    set pc, fts_scale_down
float2.dasm16
1173
0

float2.dasm16
1174
0
:fts_print
float2.dasm16
1175
2
19ff
5701
1a00
fffe
    set push, [z-2]
float2.dasm16
1176
2
1a01
7c20
1a02
17ec
    jsr float__to_uint
float2.dasm16
1177
0

float2.dasm16
1178
1
1a03
0c41
    set c, x
float2.dasm16
1179
2
1a04
7c62
1a05
0030
    add x, '0'            ; change number to character
float2.dasm16
1180
0

float2.dasm16
1181
2
1a06
5701
1a07
ffff
    set push, [z-1]        ; add character to string
float2.dasm16
1182
1
1a08
0f01
    set push, x
float2.dasm16
1183
2
1a09
7c20
1a0a
27d8
    jsr array__append
float2.dasm16
1184
0

float2.dasm16
1185
2
1a0b
5701
1a0c
fffe
    set push, [z-2]
float2.dasm16
1186
2
1a0d
4b01
1a0e
0303
    set push, [FLOAT_TABLE + c]
float2.dasm16
1187
2
1a0f
7c20
1a10
164d
    jsr float__sub
float2.dasm16
1188
2
1a11
0ea1
1a12
fffe
    set [z-2], x
float2.dasm16
1189
0

float2.dasm16
1190
0
;    ife [MASK+i], MASK_ZERO
float2.dasm16
1191
0
;        set pc, ftoa_fill_with_zero
float2.dasm16
1192
0

float2.dasm16
1193
1
1a13
044b
    bor c, b
float2.dasm16
1194
1
1a14
8452
    ife c, 0
float2.dasm16
1195
2
1a15
7f81
1a16
1a1b
        set pc, fts_scale_up
float2.dasm16
1196
0

float2.dasm16
1197
1
1a17
8822
    add b, 1
float2.dasm16
1198
1
1a18
a832
    ife b, 9
float2.dasm16
1199
2
1a19
7f81
1a1a
1a2f
        set pc, fts_fill_with_zero
float2.dasm16
1200
0

float2.dasm16
1201
0
:fts_scale_up
float2.dasm16
1202
2
1a1b
5701
1a1c
fffe
    set push, [z-2]
float2.dasm16
1203
2
1a1d
7f01
1a1e
0349
    set push, FLOAT_10
float2.dasm16
1204
2
1a1f
7c20
1a20
165f
    jsr float__mul
float2.dasm16
1205
2
1a21
0ea1
1a22
fffe
    set [z-2], x
float2.dasm16
1206
0
    
float2.dasm16
1207
1
1a23
8803
    sub a, 1
float2.dasm16
1208
1
1a24
8413
    ifn a, 0
float2.dasm16
1209
2
1a25
7f81
1a26
19ff
        set pc, fts_print
float2.dasm16
1210
0

float2.dasm16
1211
2
1a27
5701
1a28
ffff
    set push, [z-1]        ; add character to string
float2.dasm16
1212
2
1a29
7f01
1a2a
002e
    set push, '.'
float2.dasm16
1213
2
1a2b
7c20
1a2c
27d8
    jsr array__append
float2.dasm16
1214
0
    
float2.dasm16
1215
2
1a2d
7f81
1a2e
19ff
    set pc, fts_print
float2.dasm16
1216
0

float2.dasm16
1217
0
:fts_fill_with_zero
float2.dasm16
1218
1
1a2f
8803
    sub a, 1
float2.dasm16
1219
1
1a30
8412
    ife a, 0
float2.dasm16
1220
2
1a31
7f81
1a32
1a3f
        set pc, fts_finish
float2.dasm16
1221
2
1a33
7c10
1a34
8000
    ifb a, 0x8000
float2.dasm16
1222
2
1a35
7f81
1a36
1a3f
        set pc, fts_finish
float2.dasm16
1223
0
        
float2.dasm16
1224
2
1a37
5701
1a38
ffff
    set push, [z-1]        ; add character to string
float2.dasm16
1225
2
1a39
7f01
1a3a
0030
    set push, '0'
float2.dasm16
1226
2
1a3b
7c20
1a3c
27d8
    jsr array__append
float2.dasm16
1227
0
    
float2.dasm16
1228
2
1a3d
7f81
1a3e
1a2f
    set pc, fts_fill_with_zero
float2.dasm16
1229
0

float2.dasm16
1230
0
:fts_finish
float2.dasm16
1231
2
1a3f
5461
1a40
ffff
    set x, [z-1]
float2.dasm16
1232
2
1a41
7f81
1a42
2026
    set pc, postamble
float2.dasm16
1233
0

float2.dasm16
1234
0
;----------------------------------------------------------------
float2.dasm16
1235
0
:float__nlz32
float2.dasm16
1236
0
; fastcall
float2.dasm16
1237
0
;  c: float *f
float2.dasm16
1238
0
; return
float2.dasm16
1239
0
;  a: number of leading zeroes
float2.dasm16
1240
0
;  b: garbage
float2.dasm16
1241
0
; cycles: 43
float2.dasm16
1242
0
;----------------------------------------------------------------
float2.dasm16
1243
1
1a43
8401
    set a, 0
float2.dasm16
1244
2
1a44
4821
1a45
0002
    set b, [c + FLOAT_HIGH]
float2.dasm16
1245
1
1a46
8433
    ifn b, 0
float2.dasm16
1246
2
1a47
7f81
1a48
1a54
        set pc, _float__nlz16
float2.dasm16
1247
0

float2.dasm16
1248
1
1a49
c401
    set a, 16
float2.dasm16
1249
2
1a4a
4821
1a4b
0003
    set b, [c + FLOAT_LOW]
float2.dasm16
1250
2
1a4c
7f81
1a4d
1a54
    set pc, _float__nlz16
float2.dasm16
1251
0

float2.dasm16
1252
0
;----------------------------------------------------------------
float2.dasm16
1253
0
:float__nlz16
float2.dasm16
1254
0
; fastcall
float2.dasm16
1255
0
;  b: input word
float2.dasm16
1256
0
; return
float2.dasm16
1257
0
;  a: number of leading zeroes
float2.dasm16
1258
0
;  b: garbage
float2.dasm16
1259
0
; cycles: 43
float2.dasm16
1260
0
;----------------------------------------------------------------
float2.dasm16
1261
1
1a4e
8401
    set a, 0
float2.dasm16
1262
1
1a4f
8433
    ifn b, 0
float2.dasm16
1263
2
1a50
7f81
1a51
1a54
        set pc, _float__nlz16
float2.dasm16
1264
1
1a52
c401
    set a, 16
float2.dasm16
1265
1
1a53
6381
    set pc, pop
float2.dasm16
1266
0

float2.dasm16
1267
0
:_float__nlz16
float2.dasm16
1268
2
1a54
7c30
1a55
ff00
    ifb b, 0xff00
float2.dasm16
1269
2
1a56
7f81
1a57
1a5a
        set pc, float__nlz8
float2.dasm16
1270
0

float2.dasm16
1271
1
1a58
a402
    add a, 8
float2.dasm16
1272
1
1a59
a42f
    shl b, 8
float2.dasm16
1273
0
    
float2.dasm16
1274
0
:float__nlz8
float2.dasm16
1275
2
1a5a
7c30
1a5b
f000
    ifb b, 0xf000
float2.dasm16
1276
2
1a5c
7f81
1a5d
1a60
        set pc, float__nlz4
float2.dasm16
1277
0

float2.dasm16
1278
1
1a5e
9402
    add a, 4
float2.dasm16
1279
1
1a5f
942f
    shl b, 4
float2.dasm16
1280
0

float2.dasm16
1281
0
:float__nlz4
float2.dasm16
1282
2
1a60
7c30
1a61
c000
    ifb b, 0xc000
float2.dasm16
1283
2
1a62
7f81
1a63
1a66
        set pc, float__nlz2
float2.dasm16
1284
0

float2.dasm16
1285
1
1a64
8c02
    add a, 2
float2.dasm16
1286
1
1a65
8c2f
    shl b, 2
float2.dasm16
1287
0

float2.dasm16
1288
0
:float__nlz2
float2.dasm16
1289
2
1a66
7c30
1a67
8000
    ifb b, 0x8000
float2.dasm16
1290
1
1a68
6381
        set pc, pop
float2.dasm16
1291
0

float2.dasm16
1292
1
1a69
8802
    add a, 1
float2.dasm16
1293
0

float2.dasm16
1294
2
1a6a
7c30
1a6b
4000
    ifb b, 0x4000
float2.dasm16
1295
1
1a6c
6381
        set pc, pop
float2.dasm16
1296
0
    
float2.dasm16
1297
2
1a6d
7c01
1a6e
0020
    set a, 32
float2.dasm16
1298
1
1a6f
6381
    set pc, pop
float2.dasm16
1299
0

float2.dasm16
1300
0
;----------------------------------------------------------------
float2.dasm16
1301
0
:_float_cmp_abs
float2.dasm16
1302
0
; fastcall
float2.dasm16
1303
0
;  i: *left  [size, type, exp, high, low]
float2.dasm16
1304
0
;  j: *right [size, type, exp, high, low]
float2.dasm16
1305
0
; return
float2.dasm16
1306
0
;  x: 
float2.dasm16
1307
0
;    1 if abs(left) > abs(right)
float2.dasm16
1308
0
;    0 if abs(left) == abs(right)
float2.dasm16
1309
0
;   -1 if abs(left) < abs(right)
float2.dasm16
1310
0
; cycles: 26
float2.dasm16
1311
0
;----------------------------------------------------------------
float2.dasm16
1312
1
1a70
8461
    set x, 0
float2.dasm16
1313
0

float2.dasm16
1314
0
    ; compare low
float2.dasm16
1315
3
1a71
5ed4
1a72
0003
1a73
0003
	ifg [i + FLOAT_LOW], [j + FLOAT_LOW]
float2.dasm16
1316
1
1a74
8861
        set x, 1
float2.dasm16
1317
3
1a75
5ed6
1a76
0003
1a77
0003
	ifl [i + FLOAT_LOW], [j + FLOAT_LOW]
float2.dasm16
1318
1
1a78
8061
        set x, -1
float2.dasm16
1319
0

float2.dasm16
1320
0
    ; compare high
float2.dasm16
1321
3
1a79
5ed4
1a7a
0002
1a7b
0002
	ifg [i + FLOAT_HIGH], [j + FLOAT_HIGH]
float2.dasm16
1322
1
1a7c
8861
        set x, 1
float2.dasm16
1323
3
1a7d
5ed6
1a7e
0002
1a7f
0002
	ifl [i + FLOAT_HIGH], [j + FLOAT_HIGH]
float2.dasm16
1324
1
1a80
8061
        set x, -1
float2.dasm16
1325
0

float2.dasm16
1326
0
    ; compare exp
float2.dasm16
1327
3
1a81
5ed4
1a82
0001
1a83
0001
	ifg [i + FLOAT_EXP], [j + FLOAT_EXP]
float2.dasm16
1328
1
1a84
8861
        set x, 1
float2.dasm16
1329
3
1a85
5ed6
1a86
0001
1a87
0001
	ifl [i + FLOAT_EXP], [j + FLOAT_EXP]
float2.dasm16
1330
1
1a88
8061
        set x, -1
float2.dasm16
1331
0

float2.dasm16
1332
1
1a89
6381
    set pc, pop
float2.dasm16
1333
0

float2.dasm16
1334
0
;----------------------------------------------------------------
float2.dasm16
1335
0
:_float__special_values
float2.dasm16
1336
0
; fastcall
float2.dasm16
1337
0
;   a        pointer to special value table
float2.dasm16
1338
0
;   i        float *f1
float2.dasm16
1339
0
;   j        float *f2
float2.dasm16
1340
0
; cycles: 27
float2.dasm16
1341
0
; clobbers: b
float2.dasm16
1342
0
;----------------------------------------------------------------
float2.dasm16
1343
2
1a8a
7dd2
1a8b
8000
    ife [i + FLOAT_TYPE], FLOAT_TYPE_NAN
float2.dasm16
1344
2
1a8c
7f81
1a8d
1b0b
        set pc, float__return_nan
float2.dasm16
1345
2
1a8e
7df2
1a8f
8000
    ife [j + FLOAT_TYPE], FLOAT_TYPE_NAN
float2.dasm16
1346
2
1a90
7f81
1a91
1b0b
        set pc, float__return_nan
float2.dasm16
1347
0

float2.dasm16
1348
1
1a92
3c21
    set b, [j + FLOAT_TYPE]
float2.dasm16
1349
1
1a93
9c25
    mli b, 6
float2.dasm16
1350
0

float2.dasm16
1351
1
1a94
d822
    add b, 21
float2.dasm16
1352
1
1a95
85f5
    ifa [j + FLOAT_TYPE], 0
float2.dasm16
1353
1
1a96
9c23
        sub b, 6
float2.dasm16
1354
0
    
float2.dasm16
1355
1
1a97
3822
    add b, [i + FLOAT_TYPE]
float2.dasm16
1356
1
1a98
85d5
    ifa [i + FLOAT_TYPE], 0
float2.dasm16
1357
1
1a99
8823
        sub b, 1
float2.dasm16
1358
0

float2.dasm16
1359
1
1a9a
0022
    add b, a
float2.dasm16
1360
2
1a9b
7d32
1a9c
00c6
    ife [b], recover
float2.dasm16
1361
1
1a9d
2420
        jsr [b]
float2.dasm16
1362
0
        ; :ERROR_DEF: division by zero
float2.dasm16
1363
1
1a9e
2781
    set pc, [b]
float2.dasm16
1364
0

float2.dasm16
1365
0
:float__add__special_values
float2.dasm16
1366
0
    ;   inf,                num,                0.0,                 -0.0,                -num,              -inf
float2.dasm16
1367
6
1a9f
1b13
1aa0
1b13
1aa1
1b13
1aa2
1b13
1aa3
1b13
1aa4
1b0b
    dat float__return_pinf, float__return_pinf, float__return_pinf,  float__return_pinf,  float__return_pinf, float__return_nan  ; inf
float2.dasm16
1368
6
1aa5
1b13
1aa6
15f0
1aa7
1b2e
1aa8
1b2e
1aa9
15f0
1aaa
1b17
    dat float__return_pinf, float__add__num,    float__return_j,     float__return_j,     float__add__num,    float__return_ninf ; num
float2.dasm16
1369
6
1aab
1b13
1aac
1b27
1aad
1b1f
1aae
1b1f
1aaf
1b27
1ab0
1b17
    dat float__return_pinf, float__return_i,    float__return_pzero, float__return_pzero, float__return_i,    float__return_ninf ; 0.0
float2.dasm16
1370
6
1ab1
1b13
1ab2
1b27
1ab3
1b1f
1ab4
1b23
1ab5
1b27
1ab6
1b17
    dat float__return_pinf, float__return_i,    float__return_pzero, float__return_nzero, float__return_i,    float__return_ninf ; -0.0
float2.dasm16
1371
6
1ab7
1b13
1ab8
15f0
1ab9
1b2e
1aba
1b2e
1abb
15f0
1abc
1b17
    dat float__return_pinf, float__add__num,    float__return_j,     float__return_j,     float__add__num,    float__return_ninf ; -num
float2.dasm16
1372
6
1abd
1b0b
1abe
1b17
1abf
1b17
1ac0
1b17
1ac1
1b17
1ac2
1b17
    dat float__return_nan,  float__return_ninf, float__return_ninf,  float__return_ninf,  float__return_ninf, float__return_ninf ; -inf
float2.dasm16
1373
0

float2.dasm16
1374
0
:float__mul__special_values
float2.dasm16
1375
0
    ;   inf,                num,                 0.0,                 -0.0,                -num,                -inf
float2.dasm16
1376
6
1ac3
1b13
1ac4
1b13
1ac5
1b0b
1ac6
1b0b
1ac7
1b17
1ac8
1b17
    dat float__return_pinf, float__return_pinf,  float__return_nan,   float__return_nan,   float__return_ninf,  float__return_ninf ; inf
float2.dasm16
1377
6
1ac9
1b13
1aca
1671
1acb
1b1f
1acc
1b23
1acd
166e
1ace
1b17
    dat float__return_pinf, float__mul__pnum,    float__return_pzero, float__return_nzero, float__mul__nnum,    float__return_ninf ; num
float2.dasm16
1378
6
1acf
1b0b
1ad0
1b1f
1ad1
1b1f
1ad2
1b23
1ad3
1b23
1ad4
1b0b
    dat float__return_nan,  float__return_pzero, float__return_pzero, float__return_nzero, float__return_nzero, float__return_nan  ; 0.0
float2.dasm16
1379
6
1ad5
1b0b
1ad6
1b23
1ad7
1b23
1ad8
1b1f
1ad9
1b1f
1ada
1b0b
    dat float__return_nan,  float__return_nzero, float__return_nzero, float__return_pzero, float__return_pzero, float__return_nan  ; -0.0
float2.dasm16
1380
6
1adb
1b17
1adc
166e
1add
1b23
1ade
1b1f
1adf
1671
1ae0
1b13
    dat float__return_ninf, float__mul__nnum,    float__return_nzero, float__return_pzero, float__mul__pnum,    float__return_pinf ; -num
float2.dasm16
1381
6
1ae1
1b17
1ae2
1b17
1ae3
1b0b
1ae4
1b0b
1ae5
1b13
1ae6
1b13
    dat float__return_ninf, float__return_ninf,  float__return_nan,   float__return_nan,   float__return_pinf,  float__return_pinf ; -inf
float2.dasm16
1382
0

float2.dasm16
1383
0
:float__div__special_values
float2.dasm16
1384
0
    ;   inf,                num,                 0.0,                 -0.0,                -num,                -inf
float2.dasm16
1385
6
1ae7
1b0b
1ae8
1b1f
1ae9
1b1f
1aea
1b23
1aeb
1b23
1aec
1b0b
    dat float__return_nan,  float__return_pzero, float__return_pzero, float__return_nzero, float__return_nzero, float__return_nan  ; inf
float2.dasm16
1386
6
1aed
1b13
1aee
16ee
1aef
1b1f
1af0
1b23
1af1
16eb
1af2
1b17
    dat float__return_pinf, float__div__pnum,    float__return_pzero, float__return_nzero, float__div__nnum,    float__return_ninf ; num
float2.dasm16
1387
6
1af3
00c6
1af4
00c6
1af5
00c6
1af6
00c6
1af7
00c6
1af8
00c6
    dat recover,            recover,             recover,             recover,             recover,             recover            ; 0.0
float2.dasm16
1388
6
1af9
00c6
1afa
00c6
1afb
00c6
1afc
00c6
1afd
00c6
1afe
00c6
    dat recover,            recover,             recover,             recover,             recover,             recover            ; -0.0
float2.dasm16
1389
6
1aff
1b17
1b00
16eb
1b01
1b23
1b02
1b1f
1b03
16ee
1b04
1b13
    dat float__return_ninf, float__div__nnum,    float__return_nzero, float__return_pzero, float__div__pnum,    float__return_pinf ; -num
float2.dasm16
1390
6
1b05
1b0b
1b06
1b23
1b07
1b23
1b08
1b1f
1b09
1b1f
1b0a
1b0b
    dat float__return_nan,  float__return_nzero, float__return_nzero, float__return_pzero, float__return_pzero, float__return_nan  ; -inf
float2.dasm16
1391
0

float2.dasm16
1392
0
;----------------------------------------------------------------
float2.dasm16
1393
0
:float__return_nan
float2.dasm16
1394
2
1b0b
7c61
1b0c
02eb
    set x, FLOAT_NAN
float2.dasm16
1395
2
1b0d
7f81
1b0e
2026
    set pc, postamble
float2.dasm16
1396
0
;----------------------------------------------------------------
float2.dasm16
1397
0
:float__return_inf
float2.dasm16
1398
1
1b0f
2c01
    set a, [x]
float2.dasm16
1399
1
1b10
8515
    ifa [a], 0
float2.dasm16
1400
2
1b11
7f81
1b12
1b17
        set pc, float__return_ninf
float2.dasm16
1401
0
;----------------------------------------------------------------
float2.dasm16
1402
0
:float__return_pinf
float2.dasm16
1403
2
1b13
7c61
1b14
02f1
    set x, FLOAT_PINF
float2.dasm16
1404
2
1b15
7f81
1b16
2026
    set pc, postamble
float2.dasm16
1405
0
;----------------------------------------------------------------
float2.dasm16
1406
0
:float__return_ninf
float2.dasm16
1407
2
1b17
7c61
1b18
02f7
    set x, FLOAT_NINF
float2.dasm16
1408
2
1b19
7f81
1b1a
2026
    set pc, postamble
float2.dasm16
1409
0
;----------------------------------------------------------------
float2.dasm16
1410
0
:float__return_zero
float2.dasm16
1411
1
1b1b
2c01
    set a, [x]
float2.dasm16
1412
1
1b1c
8515
    ifa [a], 0
float2.dasm16
1413
2
1b1d
7f81
1b1e
1b23
        set pc, float__return_nzero
float2.dasm16
1414
0
;----------------------------------------------------------------
float2.dasm16
1415
0
:float__return_pzero
float2.dasm16
1416
2
1b1f
7c61
1b20
030d
    set x, FLOAT_PZERO
float2.dasm16
1417
2
1b21
7f81
1b22
2026
    set pc, postamble
float2.dasm16
1418
0
;----------------------------------------------------------------
float2.dasm16
1419
0
:float__return_nzero
float2.dasm16
1420
2
1b23
7c61
1b24
02fd
    set x, FLOAT_NZERO
float2.dasm16
1421
2
1b25
7f81
1b26
2026
    set pc, postamble
float2.dasm16
1422
0
;----------------------------------------------------------------
float2.dasm16
1423
0
:float__return_i
float2.dasm16
1424
1
1b27
2ce1
    set j, [x]
float2.dasm16
1425
0

float2.dasm16
1426
1
1b28
39fe
    sti [j], [i]
float2.dasm16
1427
1
1b29
39fe
    sti [j], [i]
float2.dasm16
1428
1
1b2a
39fe
    sti [j], [i]
float2.dasm16
1429
1
1b2b
39fe
    sti [j], [i]
float2.dasm16
1430
0

float2.dasm16
1431
2
1b2c
7f81
1b2d
2026
    set pc, postamble
float2.dasm16
1432
0
;----------------------------------------------------------------
float2.dasm16
1433
0
:float__return_j
float2.dasm16
1434
1
1b2e
2cc1
    set i, [x]
float2.dasm16
1435
0

float2.dasm16
1436
1
1b2f
3dde
    sti [i], [j]
float2.dasm16
1437
1
1b30
3dde
    sti [i], [j]
float2.dasm16
1438
1
1b31
3dde
    sti [i], [j]
float2.dasm16
1439
1
1b32
3dde
    sti [i], [j]
float2.dasm16
1440
0

float2.dasm16
1441
2
1b33
7f81
1b34
2026
    set pc, postamble
float2.dasm16
1442
0
;----------------------------------------------------------------
float2.dasm16
1443
0

float2.dasm16
1444
0

float2.dasm16
1445
0

float2.dasm16
1446
0

float2.dasm16
1447
0

float2.dasm16
1448
0

float2.dasm16
1449
0

float2.dasm16
1450
0

float2.dasm16
1451
0

float2.dasm16
1452
0

float2.dasm16
1453
0

lexer2.dasm16
0
0
:lexer_init
lexer2.dasm16
1
2
1b35
0fc1
1b36
0259
    set [lexer_string], x
lexer2.dasm16
2
2
1b37
87c1
1b38
025c
    set [lexer_token], 0
lexer2.dasm16
3
2
1b39
87c1
1b3a
025d
    set [lexer_start], 0
lexer2.dasm16
4
2
1b3b
87c1
1b3c
025e
    set [lexer_end], 0
lexer2.dasm16
5
2
1b3d
87c1
1b3e
025a
    set [lexer_target_indent], 0
lexer2.dasm16
6
2
1b3f
87c1
1b40
025b
    set [lexer_current_indent], 0
lexer2.dasm16
7
0

lexer2.dasm16
8
2
1b41
7c20
1b42
1ba6
    jsr lexer_next
lexer2.dasm16
9
0

lexer2.dasm16
10
1
1b43
6381
    set pc, pop
lexer2.dasm16
11
0

lexer2.dasm16
12
0
:lexer_store
lexer2.dasm16
13
1
1b44
6061
    set x, pop
lexer2.dasm16
14
2
1b45
7b01
1b46
0259
    set push, [lexer_string]
lexer2.dasm16
15
2
1b47
7b01
1b48
025c
    set push, [lexer_token]
lexer2.dasm16
16
2
1b49
7b01
1b4a
025d
    set push, [lexer_start]
lexer2.dasm16
17
2
1b4b
7b01
1b4c
025e
    set push, [lexer_end]
lexer2.dasm16
18
2
1b4d
7b01
1b4e
025a
    set push, [lexer_target_indent]
lexer2.dasm16
19
2
1b4f
7b01
1b50
025b
    set push, [lexer_current_indent]
lexer2.dasm16
20
1
1b51
0f81
    set pc, x
lexer2.dasm16
21
0

lexer2.dasm16
22
0
:lexer_restore
lexer2.dasm16
23
1
1b52
6061
    set x, pop
lexer2.dasm16
24
2
1b53
67c1
1b54
025b
    set [lexer_current_indent], [SP]
lexer2.dasm16
25
3
1b55
6bc1
1b56
0001
1b57
025a
    set [lexer_target_indent], [SP+1]
lexer2.dasm16
26
3
1b58
6bc1
1b59
0002
1b5a
025e
    set [lexer_end], [SP+2]
lexer2.dasm16
27
3
1b5b
6bc1
1b5c
0003
1b5d
025d
    set [lexer_start], [SP+3]
lexer2.dasm16
28
3
1b5e
6bc1
1b5f
0004
1b60
025c
    set [lexer_token], [SP+4]
lexer2.dasm16
29
3
1b61
6bc1
1b62
0005
1b63
0259
    set [lexer_string], [SP+5]
lexer2.dasm16
30
1
1b64
0f81
    set pc, x
lexer2.dasm16
31
0

lexer2.dasm16
32
0
:lexer_get_token_as_string
lexer2.dasm16
33
2
1b65
7b01
1b66
0259
    set push, [lexer_string]
lexer2.dasm16
34
2
1b67
7b01
1b68
025d
    set push, [lexer_start]
lexer2.dasm16
35
2
1b69
7b01
1b6a
025e
    set push, [lexer_end]
lexer2.dasm16
36
2
1b6b
7c20
1b6c
280e
    jsr array_split
lexer2.dasm16
37
3
1b6d
7fd2
1b6e
042c
1b6f
025c
    ife [lexer_token], token_name
lexer2.dasm16
38
3
1b70
7e61
1b71
0800
1b72
0001
        set [x + HANDLE_TYPE], TYPE_NAME
lexer2.dasm16
39
1
1b73
6381
    set pc, pop
lexer2.dasm16
40
0

lexer2.dasm16
41
0
;----------------------------------------------------------------
lexer2.dasm16
42
0
; struct handle *lexer__get_line()
lexer2.dasm16
43
0
;----------------------------------------------------------------
lexer2.dasm16
44
0
:lexer__get_line
lexer2.dasm16
45
1
1b74
0301
    set push, a
lexer2.dasm16
46
1
1b75
0701
    set push, b
lexer2.dasm16
47
0
    
lexer2.dasm16
48
2
1b76
7801
1b77
0259
    set a, [lexer_string]
lexer2.dasm16
49
1
1b78
0301
    set push, a
lexer2.dasm16
50
0
    
lexer2.dasm16
51
2
1b79
7821
1b7a
025d
    set b, [lexer_start]    
lexer2.dasm16
52
2
1b7b
7c20
1b7c
1b91
    jsr lexer__goto_sol
lexer2.dasm16
53
1
1b7d
0701
    set push, b
lexer2.dasm16
54
0

lexer2.dasm16
55
2
1b7e
7c20
1b7f
1b86
    jsr lexer__goto_eol
lexer2.dasm16
56
1
1b80
0701
    set push, b
lexer2.dasm16
57
2
1b81
7c20
1b82
280e
    jsr array_split
lexer2.dasm16
58
0

lexer2.dasm16
59
1
1b83
6021
    set b, pop
lexer2.dasm16
60
1
1b84
6001
    set a, pop
lexer2.dasm16
61
0

lexer2.dasm16
62
1
1b85
6381
    set pc, pop
lexer2.dasm16
63
0

lexer2.dasm16
64
0
;----------------------------------------------------------------
lexer2.dasm16
65
0
:lexer__goto_eol
lexer2.dasm16
66
0
;----------------------------------------------------------------
lexer2.dasm16
67
2
1b86
7c20
1b87
277f
    jsr array__get
lexer2.dasm16
68
0
    
lexer2.dasm16
69
1
1b88
8472
    ife x, 0
lexer2.dasm16
70
1
1b89
6381
        set pc, pop
lexer2.dasm16
71
0
    
lexer2.dasm16
72
3
1b8a
7e72
1b8b
1bcc
1b8c
0721
    ife [x + lexer_table], lexer_char_newline
lexer2.dasm16
73
1
1b8d
6381
        set pc, pop
lexer2.dasm16
74
0

lexer2.dasm16
75
1
1b8e
8822
    add b, 1
lexer2.dasm16
76
2
1b8f
7f81
1b90
1b86
    set pc, lexer__goto_eol
lexer2.dasm16
77
0

lexer2.dasm16
78
0
;----------------------------------------------------------------
lexer2.dasm16
79
0
:lexer__goto_sol
lexer2.dasm16
80
0
;----------------------------------------------------------------
lexer2.dasm16
81
1
1b91
8432
    ife b, 0
lexer2.dasm16
82
1
1b92
6381
        set pc, pop
lexer2.dasm16
83
0
        
lexer2.dasm16
84
1
1b93
8823
    sub b, 1
lexer2.dasm16
85
2
1b94
7c20
1b95
277f
    jsr array__get
lexer2.dasm16
86
0
    
lexer2.dasm16
87
3
1b96
7e73
1b97
1bcc
1b98
0721
    ifn [x + lexer_table], lexer_char_newline
lexer2.dasm16
88
2
1b99
7f81
1b9a
1b91
        set pc, lexer__goto_sol
lexer2.dasm16
89
0

lexer2.dasm16
90
1
1b9b
8822
    add b, 1
lexer2.dasm16
91
1
1b9c
6381
    set pc, pop
lexer2.dasm16
92
0

lexer2.dasm16
93
0
;----------------------------------------------------------------
lexer2.dasm16
94
0
; void lexer_advance(struct handle *expected_token)
lexer2.dasm16
95
0
;----------------------------------------------------------------
lexer2.dasm16
96
0
:lexer_advance
lexer2.dasm16
97
1
1b9d
6061
    set x, pop
lexer2.dasm16
98
2
1b9e
63d3
1b9f
025c
    ifn [lexer_token], pop
lexer2.dasm16
99
2
1ba0
7c20
1ba1
00c6
        jsr recover
lexer2.dasm16
100
0
    
lexer2.dasm16
101
1
1ba2
0f01
    set push, x
lexer2.dasm16
102
2
1ba3
7c20
1ba4
1ba6
    jsr lexer_next
lexer2.dasm16
103
0

lexer2.dasm16
104
1
1ba5
6381
    set pc, pop
lexer2.dasm16
105
0

lexer2.dasm16
106
0
;----------------------------------------------------------------
lexer2.dasm16
107
0
; void lexer_next()
lexer2.dasm16
108
0
;----------------------------------------------------------------
lexer2.dasm16
109
0
:lexer_next
lexer2.dasm16
110
1
1ba6
0301
    set push, a
lexer2.dasm16
111
1
1ba7
0701
    set push, b
lexer2.dasm16
112
1
1ba8
0b01
    set push, c
lexer2.dasm16
113
0

lexer2.dasm16
114
3
1ba9
7bd4
1baa
025a
1bab
025b
    ifg [lexer_current_indent], [lexer_target_indent]
lexer2.dasm16
115
2
1bac
7f81
1bad
1bf3
        set pc, lexer_dedent
lexer2.dasm16
116
3
1bae
7bd6
1baf
025a
1bb0
025b
    ifl [lexer_current_indent], [lexer_target_indent]
lexer2.dasm16
117
2
1bb1
7f81
1bb2
1bec
        set pc, lexer_indent
lexer2.dasm16
118
0
        
lexer2.dasm16
119
2
1bb3
7801
1bb4
0259
    set a, [lexer_string]        ; struct handle *
lexer2.dasm16
120
2
1bb5
7821
1bb6
025e
    set b, [lexer_end]
lexer2.dasm16
121
0
    
lexer2.dasm16
122
3
1bb7
7fd2
1bb8
0430
1bb9
025c
    ife [lexer_token], token_str
lexer2.dasm16
123
1
1bba
8822
        add b, 1
lexer2.dasm16
124
0

lexer2.dasm16
125
2
1bbb
7c20
1bbc
1db1
    jsr lexer_skip_white
lexer2.dasm16
126
0

lexer2.dasm16
127
2
1bbd
07c1
1bbe
025d
    set [lexer_start], b    ; token start index
lexer2.dasm16
128
0

lexer2.dasm16
129
2
1bbf
7c74
1bc0
007f
    ifg x, 127
lexer2.dasm16
130
2
1bc1
7c20
1bc2
00c6
        jsr recover
lexer2.dasm16
131
0

lexer2.dasm16
132
2
1bc3
4f81
1bc4
0721
    set pc, [x + lexer_table]
lexer2.dasm16
133
0

lexer2.dasm16
134
0
:lexer_finish_advance
lexer2.dasm16
135
1
1bc5
8822
    add b, 1
lexer2.dasm16
136
0

lexer2.dasm16
137
0
:lexer_finish
lexer2.dasm16
138
2
1bc6
07c1
1bc7
025e
    set [lexer_end], b
lexer2.dasm16
139
0

lexer2.dasm16
140
0
:lexer__exit
lexer2.dasm16
141
1
1bc8
6041
    set c, pop
lexer2.dasm16
142
1
1bc9
6021
    set b, pop
lexer2.dasm16
143
1
1bca
6001
    set a, pop
lexer2.dasm16
144
0
    
lexer2.dasm16
145
1
1bcb
6381
    set pc, pop
lexer2.dasm16
146
0

lexer2.dasm16
147
0
;----------------------------------------------------------------
lexer2.dasm16
148
0
:lexer_char_newline
lexer2.dasm16
149
0
;----------------------------------------------------------------
lexer2.dasm16
150
3
1bcc
7fc1
1bcd
0414
1bce
025c
    set [lexer_token], token_newline
lexer2.dasm16
151
0

lexer2.dasm16
152
0
:lexer_char_newline_restart
lexer2.dasm16
153
1
1bcf
8822
    add b, 1
lexer2.dasm16
154
1
1bd0
8441
    set c, 0    ; current indent
lexer2.dasm16
155
0
    
lexer2.dasm16
156
0
:lexer_char_newline_loop
lexer2.dasm16
157
2
1bd1
7c20
1bd2
277f
    jsr array__get
lexer2.dasm16
158
2
1bd3
7c73
1bd4
0020
    ifn x, ' '
lexer2.dasm16
159
2
1bd5
7f81
1bd6
1bdb
        set pc, lexer_char_newline_break
lexer2.dasm16
160
0

lexer2.dasm16
161
1
1bd7
8842
    add c, 1        ; inc indent
lexer2.dasm16
162
1
1bd8
8822
    add b, 1        ; advance position
lexer2.dasm16
163
2
1bd9
7f81
1bda
1bd1
    set pc, lexer_char_newline_loop
lexer2.dasm16
164
0

lexer2.dasm16
165
0
:lexer_char_newline_break
lexer2.dasm16
166
3
1bdb
7e72
1bdc
1db9
1bdd
0721
    ife [lexer_table + x], lexer_char_comment
lexer2.dasm16
167
2
1bde
7c20
1bdf
1b86
        jsr lexer__goto_eol
lexer2.dasm16
168
0

lexer2.dasm16
169
3
1be0
7e72
1be1
1bcc
1be2
0721
    ife [lexer_table + x], lexer_char_newline
lexer2.dasm16
170
2
1be3
7f81
1be4
1bcf
        set pc, lexer_char_newline_restart
lexer2.dasm16
171
0

lexer2.dasm16
172
1
1be5
8472
    ife x, 0
lexer2.dasm16
173
0
;        set pc, lexer_char_eof
lexer2.dasm16
174
2
1be6
7f81
1be7
1bc6
        set pc, lexer_finish
lexer2.dasm16
175
0

lexer2.dasm16
176
2
1be8
0bc1
1be9
025a
    set [lexer_target_indent], c
lexer2.dasm16
177
0

lexer2.dasm16
178
2
1bea
7f81
1beb
1bc6
    set pc, lexer_finish
lexer2.dasm16
179
0

lexer2.dasm16
180
0
;----------------------------------------------------------------
lexer2.dasm16
181
0
:lexer_indent
lexer2.dasm16
182
0
;----------------------------------------------------------------
lexer2.dasm16
183
3
1bec
7fc1
1bed
0418
1bee
025c
    set [lexer_token], token_indent
lexer2.dasm16
184
2
1bef
8bc2
1bf0
025b
    add [lexer_current_indent], 1
lexer2.dasm16
185
2
1bf1
7f81
1bf2
1bc8
    set pc, lexer__exit
lexer2.dasm16
186
0
;----------------------------------------------------------------
lexer2.dasm16
187
0
:lexer_dedent
lexer2.dasm16
188
0
;----------------------------------------------------------------
lexer2.dasm16
189
3
1bf3
7fc1
1bf4
041c
1bf5
025c
    set [lexer_token], token_dedent
lexer2.dasm16
190
2
1bf6
8bc3
1bf7
025b
    sub [lexer_current_indent], 1
lexer2.dasm16
191
2
1bf8
7f81
1bf9
1bc8
    set pc, lexer__exit
lexer2.dasm16
192
0

lexer2.dasm16
193
0
;----------------------------------------------------------------
lexer2.dasm16
194
0
:lexer_char_dot
lexer2.dasm16
195
0
;----------------------------------------------------------------
lexer2.dasm16
196
1
1bfa
8822
    add b, 1
lexer2.dasm16
197
2
1bfb
7c20
1bfc
277f
    jsr array__get
lexer2.dasm16
198
0

lexer2.dasm16
199
3
1bfd
7e72
1bfe
1ce3
1bff
0721
    ife [x + lexer_table], lexer_char_digit
lexer2.dasm16
200
2
1c00
7f81
1c01
1d5f
        set pc, lexer_float
lexer2.dasm16
201
0

lexer2.dasm16
202
3
1c02
7fc1
1c03
0520
1c04
025c
    set [lexer_token], token_reference
lexer2.dasm16
203
2
1c05
7f81
1c06
1bc6
    set pc, lexer_finish
lexer2.dasm16
204
0

lexer2.dasm16
205
0
;----------------------------------------------------------------
lexer2.dasm16
206
0
:lexer_char_tilde
lexer2.dasm16
207
0
;----------------------------------------------------------------
lexer2.dasm16
208
3
1c07
7fc1
1c08
0440
1c09
025c
    set [lexer_token], token_tilde
lexer2.dasm16
209
2
1c0a
7f81
1c0b
1bc5
    set pc, lexer_finish_advance
lexer2.dasm16
210
0

lexer2.dasm16
211
0
;----------------------------------------------------------------
lexer2.dasm16
212
0
:lexer_char_colon
lexer2.dasm16
213
0
;----------------------------------------------------------------
lexer2.dasm16
214
3
1c0c
7fc1
1c0d
04ac
1c0e
025c
    set [lexer_token], token_colon
lexer2.dasm16
215
2
1c0f
7f81
1c10
1bc5
    set pc, lexer_finish_advance
lexer2.dasm16
216
0

lexer2.dasm16
217
0
;----------------------------------------------------------------
lexer2.dasm16
218
0
:lexer_char_comma
lexer2.dasm16
219
0
;----------------------------------------------------------------
lexer2.dasm16
220
3
1c11
7fc1
1c12
04a8
1c13
025c
    set [lexer_token], token_comma
lexer2.dasm16
221
2
1c14
7f81
1c15
1bc5
    set pc, lexer_finish_advance
lexer2.dasm16
222
0

lexer2.dasm16
223
0
;----------------------------------------------------------------
lexer2.dasm16
224
0
:lexer_char_lparen
lexer2.dasm16
225
0
;----------------------------------------------------------------
lexer2.dasm16
226
3
1c16
7fc1
1c17
0510
1c18
025c
    set [lexer_token], token_lparen
lexer2.dasm16
227
2
1c19
7f81
1c1a
1bc5
    set pc, lexer_finish_advance
lexer2.dasm16
228
0

lexer2.dasm16
229
0
;----------------------------------------------------------------
lexer2.dasm16
230
0
:lexer_char_rparen
lexer2.dasm16
231
0
;----------------------------------------------------------------
lexer2.dasm16
232
3
1c1b
7fc1
1c1c
0514
1c1d
025c
    set [lexer_token], token_rparen
lexer2.dasm16
233
2
1c1e
7f81
1c1f
1bc5
    set pc, lexer_finish_advance
lexer2.dasm16
234
0

lexer2.dasm16
235
0
;----------------------------------------------------------------
lexer2.dasm16
236
0
:lexer_char_lcurly
lexer2.dasm16
237
0
;----------------------------------------------------------------
lexer2.dasm16
238
3
1c20
7fc1
1c21
0518
1c22
025c
    set [lexer_token], token_lcurly
lexer2.dasm16
239
2
1c23
7f81
1c24
1bc5
    set pc, lexer_finish_advance
lexer2.dasm16
240
0

lexer2.dasm16
241
0
;----------------------------------------------------------------
lexer2.dasm16
242
0
:lexer_char_rcurly
lexer2.dasm16
243
0
;----------------------------------------------------------------
lexer2.dasm16
244
3
1c25
7fc1
1c26
051c
1c27
025c
    set [lexer_token], token_rcurly
lexer2.dasm16
245
2
1c28
7f81
1c29
1bc5
    set pc, lexer_finish_advance
lexer2.dasm16
246
0

lexer2.dasm16
247
0
;----------------------------------------------------------------
lexer2.dasm16
248
0
:lexer_char_lbrack
lexer2.dasm16
249
0
;----------------------------------------------------------------
lexer2.dasm16
250
3
1c2a
7fc1
1c2b
0508
1c2c
025c
    set [lexer_token], token_lbrack
lexer2.dasm16
251
2
1c2d
7f81
1c2e
1bc5
    set pc, lexer_finish_advance
lexer2.dasm16
252
0

lexer2.dasm16
253
0
;----------------------------------------------------------------
lexer2.dasm16
254
0
:lexer_char_rbrack
lexer2.dasm16
255
0
;----------------------------------------------------------------
lexer2.dasm16
256
3
1c2f
7fc1
1c30
050c
1c31
025c
    set [lexer_token], token_rbrack
lexer2.dasm16
257
2
1c32
7f81
1c33
1bc5
    set pc, lexer_finish_advance
lexer2.dasm16
258
0

lexer2.dasm16
259
0
;----------------------------------------------------------------
lexer2.dasm16
260
0
:lexer_char_plus
lexer2.dasm16
261
0
;----------------------------------------------------------------
lexer2.dasm16
262
3
1c34
7fc1
1c35
04f0
1c36
025c
    set [lexer_token], token_plus
lexer2.dasm16
263
2
1c37
7c41
1c38
0480
    set c, token_augass_plus
lexer2.dasm16
264
2
1c39
7f81
1c3a
1cd1
    set pc, check_augass
lexer2.dasm16
265
0

lexer2.dasm16
266
0
;----------------------------------------------------------------
lexer2.dasm16
267
0
:lexer_char_minus
lexer2.dasm16
268
0
;----------------------------------------------------------------
lexer2.dasm16
269
3
1c3b
7fc1
1c3c
04f4
1c3d
025c
    set [lexer_token], token_minus
lexer2.dasm16
270
2
1c3e
7c41
1c3f
0484
    set c, token_augass_minus
lexer2.dasm16
271
2
1c40
7f81
1c41
1cd1
    set pc, check_augass
lexer2.dasm16
272
0

lexer2.dasm16
273
0
;----------------------------------------------------------------
lexer2.dasm16
274
0
:lexer_char_star
lexer2.dasm16
275
0
;----------------------------------------------------------------
lexer2.dasm16
276
1
1c42
8822
    add b, 1
lexer2.dasm16
277
2
1c43
7c20
1c44
277f
    jsr array__get
lexer2.dasm16
278
2
1c45
7c72
1c46
003d
    ife x, '='
lexer2.dasm16
279
2
1c47
7f81
1c48
1c52
        set pc, lexer_char_star_assign
lexer2.dasm16
280
2
1c49
7c72
1c4a
002a
    ife x, '*'
lexer2.dasm16
281
2
1c4b
7f81
1c4c
1c57
        set pc, lexer_char_star_star
lexer2.dasm16
282
0

lexer2.dasm16
283
3
1c4d
7fc1
1c4e
04f8
1c4f
025c
    set [lexer_token], token_star
lexer2.dasm16
284
2
1c50
7f81
1c51
1bc6
    set pc, lexer_finish
lexer2.dasm16
285
0
:lexer_char_star_assign
lexer2.dasm16
286
3
1c52
7fc1
1c53
0488
1c54
025c
    set [lexer_token], token_augass_star
lexer2.dasm16
287
2
1c55
7f81
1c56
1bc5
    set pc, lexer_finish_advance
lexer2.dasm16
288
0
:lexer_char_star_star
lexer2.dasm16
289
3
1c57
7fc1
1c58
0504
1c59
025c
    set [lexer_token], token_power
lexer2.dasm16
290
2
1c5a
7f81
1c5b
1bc5
    set pc, lexer_finish_advance
lexer2.dasm16
291
0
    
lexer2.dasm16
292
0
;----------------------------------------------------------------
lexer2.dasm16
293
0
:lexer_char_caret
lexer2.dasm16
294
0
;----------------------------------------------------------------
lexer2.dasm16
295
3
1c5c
7fc1
1c5d
04e0
1c5e
025c
    set [lexer_token], token_bitwise_xor
lexer2.dasm16
296
2
1c5f
7c41
1c60
0498
    set c, token_augass_xor
lexer2.dasm16
297
2
1c61
7f81
1c62
1cd1
    set pc, check_augass
lexer2.dasm16
298
0

lexer2.dasm16
299
0
;----------------------------------------------------------------
lexer2.dasm16
300
0
:lexer_char_vbar
lexer2.dasm16
301
0
;----------------------------------------------------------------
lexer2.dasm16
302
3
1c63
7fc1
1c64
04dc
1c65
025c
    set [lexer_token], token_bitwise_or
lexer2.dasm16
303
2
1c66
7c41
1c67
0494
    set c, token_augass_or
lexer2.dasm16
304
2
1c68
7f81
1c69
1cd1
    set pc, check_augass
lexer2.dasm16
305
0

lexer2.dasm16
306
0
;----------------------------------------------------------------
lexer2.dasm16
307
0
:lexer_char_ambersand
lexer2.dasm16
308
0
;----------------------------------------------------------------
lexer2.dasm16
309
3
1c6a
7fc1
1c6b
04e4
1c6c
025c
    set [lexer_token], token_bitwise_and
lexer2.dasm16
310
2
1c6d
7c41
1c6e
049c
    set c, token_augass_and
lexer2.dasm16
311
2
1c6f
7f81
1c70
1cd1
    set pc, check_augass
lexer2.dasm16
312
0

lexer2.dasm16
313
0
;----------------------------------------------------------------
lexer2.dasm16
314
0
:lexer_char_slash
lexer2.dasm16
315
0
;----------------------------------------------------------------
lexer2.dasm16
316
3
1c71
7fc1
1c72
04fc
1c73
025c
    set [lexer_token], token_slash
lexer2.dasm16
317
2
1c74
7c41
1c75
048c
    set c, token_augass_slash
lexer2.dasm16
318
2
1c76
7f81
1c77
1cd1
    set pc, check_augass
lexer2.dasm16
319
0

lexer2.dasm16
320
0
;----------------------------------------------------------------
lexer2.dasm16
321
0
:lexer_char_percent
lexer2.dasm16
322
0
;----------------------------------------------------------------
lexer2.dasm16
323
3
1c78
7fc1
1c79
0500
1c7a
025c
    set [lexer_token], token_percent
lexer2.dasm16
324
2
1c7b
7c41
1c7c
0490
    set c, token_augass_percent
lexer2.dasm16
325
2
1c7d
7f81
1c7e
1cd1
    set pc, check_augass
lexer2.dasm16
326
0

lexer2.dasm16
327
0
;----------------------------------------------------------------
lexer2.dasm16
328
0
:lexer_char_equal
lexer2.dasm16
329
0
;----------------------------------------------------------------
lexer2.dasm16
330
3
1c7f
7fc1
1c80
047c
1c81
025c
    set [lexer_token], token_assign
lexer2.dasm16
331
2
1c82
7c41
1c83
04c4
    set c, token_equal
lexer2.dasm16
332
2
1c84
7f81
1c85
1cd1
    set pc, check_augass
lexer2.dasm16
333
0

lexer2.dasm16
334
0
;----------------------------------------------------------------
lexer2.dasm16
335
0
:lexer_char_less
lexer2.dasm16
336
0
; '<' token_less
lexer2.dasm16
337
0
; '<=' token_less_or_equal
lexer2.dasm16
338
0
; '<<' token_lshift
lexer2.dasm16
339
0
; '<<=' token_augass_lshift
lexer2.dasm16
340
0
;----------------------------------------------------------------
lexer2.dasm16
341
3
1c86
7fc1
1c87
04c8
1c88
025c
    set [lexer_token], token_less
lexer2.dasm16
342
0

lexer2.dasm16
343
1
1c89
8822
    add b, 1
lexer2.dasm16
344
2
1c8a
7c20
1c8b
277f
    jsr array__get
lexer2.dasm16
345
2
1c8c
7c72
1c8d
003c
    ife x, '<'
lexer2.dasm16
346
2
1c8e
7f81
1c8f
1c99
        set pc, lexer_char_less_less    
lexer2.dasm16
347
2
1c90
7c73
1c91
003d
    ifn x, '='
lexer2.dasm16
348
2
1c92
7f81
1c93
1bc6
        set pc, lexer_finish
lexer2.dasm16
349
0

lexer2.dasm16
350
3
1c94
7fc1
1c95
04cc
1c96
025c
    set [lexer_token], token_less_or_equal
lexer2.dasm16
351
2
1c97
7f81
1c98
1bc5
    set pc, lexer_finish_advance
lexer2.dasm16
352
0

lexer2.dasm16
353
0
:lexer_char_less_less
lexer2.dasm16
354
3
1c99
7fc1
1c9a
04e8
1c9b
025c
    set [lexer_token], token_lshift
lexer2.dasm16
355
0
    
lexer2.dasm16
356
1
1c9c
8822
    add b, 1
lexer2.dasm16
357
2
1c9d
7c20
1c9e
277f
    jsr array__get
lexer2.dasm16
358
2
1c9f
7c73
1ca0
003d
    ifn x, '='
lexer2.dasm16
359
2
1ca1
7f81
1ca2
1bc6
        set pc, lexer_finish
lexer2.dasm16
360
0
    
lexer2.dasm16
361
3
1ca3
7fc1
1ca4
04a0
1ca5
025c
    set [lexer_token], token_augass_lshift
lexer2.dasm16
362
2
1ca6
7f81
1ca7
1bc5
    set pc, lexer_finish_advance
lexer2.dasm16
363
0

lexer2.dasm16
364
0
;----------------------------------------------------------------
lexer2.dasm16
365
0
:lexer_char_greater
lexer2.dasm16
366
0
; '>' token_greater
lexer2.dasm16
367
0
; '>=' token_greater_or_equal
lexer2.dasm16
368
0
; '>>' token_rshift
lexer2.dasm16
369
0
; '>>=' token_augass_rshift
lexer2.dasm16
370
0
;----------------------------------------------------------------
lexer2.dasm16
371
3
1ca8
7fc1
1ca9
04d0
1caa
025c
    set [lexer_token], token_greater
lexer2.dasm16
372
0

lexer2.dasm16
373
1
1cab
8822
    add b, 1
lexer2.dasm16
374
2
1cac
7c20
1cad
277f
    jsr array__get
lexer2.dasm16
375
2
1cae
7c72
1caf
003e
    ife x, '>'
lexer2.dasm16
376
2
1cb0
7f81
1cb1
1cbb
        set pc, lexer_char_greater_greater    
lexer2.dasm16
377
2
1cb2
7c73
1cb3
003d
    ifn x, '='
lexer2.dasm16
378
2
1cb4
7f81
1cb5
1bc6
        set pc, lexer_finish
lexer2.dasm16
379
0

lexer2.dasm16
380
3
1cb6
7fc1
1cb7
04d4
1cb8
025c
    set [lexer_token], token_greater_or_equal
lexer2.dasm16
381
2
1cb9
7f81
1cba
1bc5
    set pc, lexer_finish_advance
lexer2.dasm16
382
0

lexer2.dasm16
383
0
:lexer_char_greater_greater
lexer2.dasm16
384
3
1cbb
7fc1
1cbc
04ec
1cbd
025c
    set [lexer_token], token_rshift
lexer2.dasm16
385
0
    
lexer2.dasm16
386
1
1cbe
8822
    add b, 1
lexer2.dasm16
387
2
1cbf
7c20
1cc0
277f
    jsr array__get
lexer2.dasm16
388
2
1cc1
7c73
1cc2
003d
    ifn x, '='
lexer2.dasm16
389
2
1cc3
7f81
1cc4
1bc6
        set pc, lexer_finish
lexer2.dasm16
390
0
    
lexer2.dasm16
391
3
1cc5
7fc1
1cc6
04a4
1cc7
025c
    set [lexer_token], token_augass_rshift
lexer2.dasm16
392
2
1cc8
7f81
1cc9
1bc5
    set pc, lexer_finish_advance
lexer2.dasm16
393
0

lexer2.dasm16
394
0
;----------------------------------------------------------------
lexer2.dasm16
395
0
:lexer_char_exclamation
lexer2.dasm16
396
0
;----------------------------------------------------------------
lexer2.dasm16
397
3
1cca
7fc1
1ccb
04bc
1ccc
025c
    set [lexer_token], token_not
lexer2.dasm16
398
2
1ccd
7c41
1cce
04d8
    set c, token_not_equal
lexer2.dasm16
399
2
1ccf
7f81
1cd0
1cd1
    set pc, check_augass
lexer2.dasm16
400
0

lexer2.dasm16
401
0
;----------------------------------------------------------------
lexer2.dasm16
402
0
:check_augass
lexer2.dasm16
403
0
;----------------------------------------------------------------
lexer2.dasm16
404
1
1cd1
8822
    add b, 1
lexer2.dasm16
405
2
1cd2
7c20
1cd3
277f
    jsr array__get
lexer2.dasm16
406
2
1cd4
7c73
1cd5
003d
    ifn x, '='
lexer2.dasm16
407
2
1cd6
7f81
1cd7
1bc6
        set pc, lexer_finish
lexer2.dasm16
408
0

lexer2.dasm16
409
2
1cd8
0bc1
1cd9
025c
    set [lexer_token], c
lexer2.dasm16
410
2
1cda
7f81
1cdb
1bc5
    set pc, lexer_finish_advance
lexer2.dasm16
411
0

lexer2.dasm16
412
0
;----------------------------------------------------------------
lexer2.dasm16
413
0
:lexer_char_eof
lexer2.dasm16
414
0
;----------------------------------------------------------------
lexer2.dasm16
415
3
1cdc
7fc1
1cdd
0410
1cde
025c
    set [lexer_token], token_eof
lexer2.dasm16
416
2
1cdf
87c1
1ce0
025a
    set [lexer_target_indent], 0
lexer2.dasm16
417
2
1ce1
7f81
1ce2
1bc6
    set pc, lexer_finish
lexer2.dasm16
418
0

lexer2.dasm16
419
0
;----------------------------------------------------------------
lexer2.dasm16
420
0
:lexer_char_digit
lexer2.dasm16
421
0
;----------------------------------------------------------------
lexer2.dasm16
422
2
1ce3
7c73
1ce4
0030
    ifn x, '0'
lexer2.dasm16
423
2
1ce5
7f81
1ce6
1cf7
        set pc, lexer_char_digit_start
lexer2.dasm16
424
0

lexer2.dasm16
425
1
1ce7
8822
    add b, 1
lexer2.dasm16
426
2
1ce8
7c20
1ce9
277f
    jsr array__get
lexer2.dasm16
427
0
    
lexer2.dasm16
428
2
1cea
7c72
1ceb
0078
    ife x, 'x'
lexer2.dasm16
429
2
1cec
7f81
1ced
1d0b
        set pc, lexer_char_hex
lexer2.dasm16
430
0

lexer2.dasm16
431
2
1cee
7c72
1cef
0058
    ife x, 'X'
lexer2.dasm16
432
2
1cf0
7f81
1cf1
1d0b
        set pc, lexer_char_hex
lexer2.dasm16
433
0

lexer2.dasm16
434
2
1cf2
7f81
1cf3
1cf7
    set pc, lexer_char_digit_start
lexer2.dasm16
435
0

lexer2.dasm16
436
0
:lexer_char_digit_loop
lexer2.dasm16
437
1
1cf4
8822
    add b, 1
lexer2.dasm16
438
2
1cf5
7c20
1cf6
277f
    jsr array__get
lexer2.dasm16
439
0

lexer2.dasm16
440
0
:lexer_char_digit_start
lexer2.dasm16
441
2
1cf7
7c72
1cf8
002e
    ife x, '.'        ; discard int and go for float
lexer2.dasm16
442
2
1cf9
7f81
1cfa
1d5f
        set pc, lexer_float
lexer2.dasm16
443
2
1cfb
7c72
1cfc
0065
    ife x, 'e'        ; discard int and go for float
lexer2.dasm16
444
2
1cfd
7f81
1cfe
1d5f
        set pc, lexer_float
lexer2.dasm16
445
0

lexer2.dasm16
446
3
1cff
7e72
1d00
1ce3
1d01
0721
    ife [x + lexer_table], lexer_char_digit
lexer2.dasm16
447
2
1d02
7f81
1d03
1cf4
        set pc, lexer_char_digit_loop
lexer2.dasm16
448
0

lexer2.dasm16
449
2
1d04
07c1
1d05
025e
    set [lexer_end], b            ; lexer.data1
lexer2.dasm16
450
0

lexer2.dasm16
451
3
1d06
7fc1
1d07
0420
1d08
025c
    set [lexer_token], token_int
lexer2.dasm16
452
2
1d09
7f81
1d0a
1bc6
    set pc, lexer_finish
lexer2.dasm16
453
0

lexer2.dasm16
454
0
;----------------------------------------------------------------
lexer2.dasm16
455
0
:lexer_char_hex
lexer2.dasm16
456
0
;----------------------------------------------------------------
lexer2.dasm16
457
1
1d0b
8822
    add b, 1
lexer2.dasm16
458
2
1d0c
7c20
1d0d
277f
    jsr array__get
lexer2.dasm16
459
0

lexer2.dasm16
460
3
1d0e
7e72
1d0f
1ce3
1d10
0721
    ife [x + lexer_table], lexer_char_digit
lexer2.dasm16
461
2
1d11
7f81
1d12
1d0b
        set pc, lexer_char_hex
lexer2.dasm16
462
0

lexer2.dasm16
463
2
1d13
7c74
1d14
0060
    ifg x, 'a'-1
lexer2.dasm16
464
2
1d15
7c76
1d16
0067
        ifl x, 'f'+1
lexer2.dasm16
465
2
1d17
7f81
1d18
1d0b
            set pc, lexer_char_hex
lexer2.dasm16
466
0

lexer2.dasm16
467
2
1d19
7c74
1d1a
0040
    ifg x, 'A'-1
lexer2.dasm16
468
2
1d1b
7c76
1d1c
0047
        ifl x, 'F'+1
lexer2.dasm16
469
2
1d1d
7f81
1d1e
1d0b
            set pc, lexer_char_hex
lexer2.dasm16
470
0

lexer2.dasm16
471
2
1d1f
07c1
1d20
025e
    set [lexer_end], b            ; lexer.data1
lexer2.dasm16
472
0

lexer2.dasm16
473
3
1d21
7fc1
1d22
0424
1d23
025c
    set [lexer_token], token_hex
lexer2.dasm16
474
2
1d24
7f81
1d25
1bc6
    set pc, lexer_finish
lexer2.dasm16
475
0

lexer2.dasm16
476
0
;----------------------------------------------------------------
lexer2.dasm16
477
0
:lexer_char_letter
lexer2.dasm16
478
0
;----------------------------------------------------------------
lexer2.dasm16
479
0
:lexer_name_loop
lexer2.dasm16
480
1
1d26
8822
    add b, 1
lexer2.dasm16
481
2
1d27
7c20
1d28
277f
    jsr array__get
lexer2.dasm16
482
0

lexer2.dasm16
483
3
1d29
7e72
1d2a
1d26
1d2b
0721
    ife [x + lexer_table], lexer_char_letter
lexer2.dasm16
484
2
1d2c
7f81
1d2d
1d26
        set pc, lexer_name_loop
lexer2.dasm16
485
3
1d2e
7e72
1d2f
1ce3
1d30
0721
    ife [x + lexer_table], lexer_char_digit
lexer2.dasm16
486
2
1d31
7f81
1d32
1d26
        set pc, lexer_name_loop
lexer2.dasm16
487
0

lexer2.dasm16
488
2
1d33
07c1
1d34
025e
    set [lexer_end], b
lexer2.dasm16
489
0
    
lexer2.dasm16
490
1
1d35
2001
    set a, [a]
lexer2.dasm16
491
2
1d36
7802
1d37
025d
    add a, [lexer_start]
lexer2.dasm16
492
2
1d38
7823
1d39
025d
    sub b, [lexer_start]
lexer2.dasm16
493
1
1d3a
8802
    add a, 1
lexer2.dasm16
494
0

lexer2.dasm16
495
1
1d3b
1b01
    set push, i
lexer2.dasm16
496
1
1d3c
1f01
    set push, j
lexer2.dasm16
497
0

lexer2.dasm16
498
2
1d3d
7c61
1d3e
0694
    set x, built_in_stmts
lexer2.dasm16
499
2
1d3f
7c20
1d40
2168
    jsr built_in_matcher
lexer2.dasm16
500
0
    
lexer2.dasm16
501
1
1d41
60e1
    set j, pop
lexer2.dasm16
502
1
1d42
60c1
    set i, pop
lexer2.dasm16
503
0
    
lexer2.dasm16
504
2
1d43
0bc1
1d44
025c
    set [lexer_token], c
lexer2.dasm16
505
0
    
lexer2.dasm16
506
2
1d45
7f81
1d46
1bc8
    set pc, lexer__exit
lexer2.dasm16
507
0

lexer2.dasm16
508
0
;----------------------------------------------------------------
lexer2.dasm16
509
0
:lexer_char_quotationmark
lexer2.dasm16
510
0
;----------------------------------------------------------------
lexer2.dasm16
511
1
1d47
0c81
    set y, x
lexer2.dasm16
512
2
1d48
8bc2
1d49
025d
    add [lexer_start], 1     ; skip "
lexer2.dasm16
513
0

lexer2.dasm16
514
0
:lexer_literal_string_loop
lexer2.dasm16
515
1
1d4a
8822
    add b, 1
lexer2.dasm16
516
2
1d4b
7c20
1d4c
277f
    jsr array__get
lexer2.dasm16
517
0

lexer2.dasm16
518
1
1d4d
8472
    ife x, 0
lexer2.dasm16
519
2
1d4e
7c20
1d4f
00c6
        jsr recover
lexer2.dasm16
520
3
1d50
7e72
1d51
1bcc
1d52
0721
    ife [x + lexer_table], lexer_char_newline
lexer2.dasm16
521
2
1d53
7c20
1d54
00c6
        jsr recover
lexer2.dasm16
522
0

lexer2.dasm16
523
1
1d55
1073
    ifn x, y
lexer2.dasm16
524
2
1d56
7f81
1d57
1d4a
        set pc, lexer_literal_string_loop
lexer2.dasm16
525
0

lexer2.dasm16
526
2
1d58
07c1
1d59
025e
    set [lexer_end], b
lexer2.dasm16
527
0

lexer2.dasm16
528
3
1d5a
7fc1
1d5b
0430
1d5c
025c
    set [lexer_token], token_str
lexer2.dasm16
529
2
1d5d
7f81
1d5e
1bc6
    set pc, lexer_finish
lexer2.dasm16
530
0

lexer2.dasm16
531
0
;----------------------------------------------------------------
lexer2.dasm16
532
0
:lexer_float
lexer2.dasm16
533
0
; d*.d*
lexer2.dasm16
534
0
;----------------------------------------------------------------
lexer2.dasm16
535
2
1d5f
7821
1d60
025d
    set b, [lexer_start]            ; restore start position
lexer2.dasm16
536
1
1d61
8841
    set c, FP_STATE_START
lexer2.dasm16
537
0

lexer2.dasm16
538
0
:lexer_float_loop
lexer2.dasm16
539
2
1d62
7c20
1d63
277f
    jsr array__get
lexer2.dasm16
540
1
1d64
8822
    add b, 1
lexer2.dasm16
541
0

lexer2.dasm16
542
2
1d65
7c72
1d66
002b
    ife x, '+'
lexer2.dasm16
543
2
1d67
7f81
1d68
1d90
        set pc, lexer_float_plus
lexer2.dasm16
544
2
1d69
7c72
1d6a
002d
    ife x, '-'
lexer2.dasm16
545
2
1d6b
7f81
1d6c
1d90
        set pc, lexer_float_minus
lexer2.dasm16
546
2
1d6d
7c72
1d6e
0065
    ife x, 'e'
lexer2.dasm16
547
2
1d6f
7f81
1d70
1d9e
        set pc, lexer_float_exponent
lexer2.dasm16
548
2
1d71
7c72
1d72
002e
    ife x, '.'
lexer2.dasm16
549
2
1d73
7f81
1d74
1d98
        set pc, lexer_float_decimal_point
lexer2.dasm16
550
0

lexer2.dasm16
551
3
1d75
7e73
1d76
1ce3
1d77
0721
    ifn [x + lexer_table], lexer_char_digit
lexer2.dasm16
552
2
1d78
7f81
1d79
1da5
        set pc, lexer_float_finish
lexer2.dasm16
553
0

lexer2.dasm16
554
2
1d7a
7c50
1d7b
0060
    ifb c, FP_STATE_E + FP_STATE_EXPONENT_SIGN
lexer2.dasm16
555
2
1d7c
7f81
1d7d
1d8c
        set pc, lexer_float_exponent_number
lexer2.dasm16
556
1
1d7e
e450
    ifb c, FP_STATE_DIGIT_DECIMAL + FP_STATE_DECIMAL_POINT        ; if in fraction part
lexer2.dasm16
557
2
1d7f
7f81
1d80
1d86
        set pc, lexer_float_decimal_number
lexer2.dasm16
558
1
1d81
a050
    ifb c, FP_STATE_START + FP_STATE_SIGN + FP_STATE_DIGIT_WHOLE    ; if in whole number part
lexer2.dasm16
559
2
1d82
7f81
1d83
1d89
        set pc, lexer_float_integral_number
lexer2.dasm16
560
0

lexer2.dasm16
561
2
1d84
7f81
1d85
1da5
    set pc, lexer_float_finish        ; wrong state for a number
lexer2.dasm16
562
0

lexer2.dasm16
563
0
:lexer_float_decimal_number
lexer2.dasm16
564
0
    ; parse digit to fraction
lexer2.dasm16
565
1
1d86
c441
    set c, FP_STATE_DIGIT_DECIMAL                        ; set state
lexer2.dasm16
566
2
1d87
7f81
1d88
1d62
    set pc, lexer_float_loop
lexer2.dasm16
567
0

lexer2.dasm16
568
0
:lexer_float_integral_number
lexer2.dasm16
569
1
1d89
9441
    set c, FP_STATE_DIGIT_WHOLE                            ; set state
lexer2.dasm16
570
2
1d8a
7f81
1d8b
1d62
    set pc, lexer_float_loop
lexer2.dasm16
571
0

lexer2.dasm16
572
0
:lexer_float_exponent_number
lexer2.dasm16
573
2
1d8c
7c41
1d8d
0080
    set c, FP_STATE_EXPONENT_DIGIT    ; set state
lexer2.dasm16
574
2
1d8e
7f81
1d8f
1d62
    set pc, lexer_float_loop
lexer2.dasm16
575
0

lexer2.dasm16
576
0
:lexer_float_plus
lexer2.dasm16
577
0
:lexer_float_minus
lexer2.dasm16
578
2
1d90
7c53
1d91
0020
    ifn c, FP_STATE_E
lexer2.dasm16
579
2
1d92
7f81
1d93
1da5
        set pc, lexer_float_finish
lexer2.dasm16
580
2
1d94
7c41
1d95
0040
    set c, FP_STATE_EXPONENT_SIGN
lexer2.dasm16
581
2
1d96
7f81
1d97
1d62
    set pc, lexer_float_loop
lexer2.dasm16
582
0
    
lexer2.dasm16
583
0
:lexer_float_decimal_point
lexer2.dasm16
584
1
1d98
a051
    ifc c, FP_STATE_START + FP_STATE_SIGN + FP_STATE_DIGIT_WHOLE
lexer2.dasm16
585
2
1d99
7f81
1d9a
1da5
        set pc, lexer_float_finish
lexer2.dasm16
586
0

lexer2.dasm16
587
1
1d9b
a441
    set c, FP_STATE_DECIMAL_POINT
lexer2.dasm16
588
2
1d9c
7f81
1d9d
1d62
    set pc, lexer_float_loop
lexer2.dasm16
589
0
    
lexer2.dasm16
590
0
:lexer_float_exponent
lexer2.dasm16
591
1
1d9e
e051
    ifc c, FP_STATE_START + FP_STATE_SIGN + FP_STATE_DIGIT_WHOLE + FP_STATE_DIGIT_DECIMAL
lexer2.dasm16
592
2
1d9f
7f81
1da0
1da5
        set pc, lexer_float_finish
lexer2.dasm16
593
0

lexer2.dasm16
594
2
1da1
7c41
1da2
0020
    set c, FP_STATE_E
lexer2.dasm16
595
2
1da3
7f81
1da4
1d62
    set pc, lexer_float_loop
lexer2.dasm16
596
0

lexer2.dasm16
597
0
:lexer_float_finish
lexer2.dasm16
598
2
1da5
7c50
1da6
0063
    ifb c, FP_STATE_START + FP_STATE_SIGN + FP_STATE_E + FP_STATE_EXPONENT_SIGN
lexer2.dasm16
599
2
1da7
7c20
1da8
00c6
        jsr recover
lexer2.dasm16
600
0

lexer2.dasm16
601
1
1da9
8823
    sub b, 1
lexer2.dasm16
602
2
1daa
07c1
1dab
025e
    set [lexer_end], b            ; lexer.data1    
lexer2.dasm16
603
3
1dac
7fc1
1dad
0428
1dae
025c
    set [lexer_token], token_float
lexer2.dasm16
604
0

lexer2.dasm16
605
2
1daf
7f81
1db0
1bc8
    set pc, lexer__exit
lexer2.dasm16
606
0

lexer2.dasm16
607
0
;----------------------------------------------------------------
lexer2.dasm16
608
0
:lexer_skip_white
lexer2.dasm16
609
0
; a: struct handle *
lexer2.dasm16
610
0
; b: index
lexer2.dasm16
611
0
;----------------------------------------------------------------
lexer2.dasm16
612
2
1db1
7c20
1db2
277f
    jsr array__get
lexer2.dasm16
613
2
1db3
7c73
1db4
0020
    ifn x, ' '
lexer2.dasm16
614
1
1db5
6381
        set pc, pop
lexer2.dasm16
615
1
1db6
8822
    add b, 1
lexer2.dasm16
616
2
1db7
7f81
1db8
1db1
    set pc, lexer_skip_white
lexer2.dasm16
617
0

lexer2.dasm16
618
0
;----------------------------------------------------------------
lexer2.dasm16
619
0
:lexer_char_comment
lexer2.dasm16
620
0
;----------------------------------------------------------------
lexer2.dasm16
621
1
1db9
8822
    add b, 1
lexer2.dasm16
622
2
1dba
7c20
1dbb
1b86
    jsr lexer__goto_eol
lexer2.dasm16
623
2
1dbc
7f81
1dbd
1bcc
    set pc, lexer_char_newline
lexer2.dasm16
624
0

lexer2.dasm16
625
0
:lexer_char_whitespace
lexer2.dasm16
626
2
1dbe
7c20
1dbf
00c6
    jsr recover
lexer2.dasm16
627
0

stdlib.dasm16
0
0
;----------------------------------------------------------------
stdlib.dasm16
1
0
; uint val_cmp(struct handle *left, struct handle *right)
stdlib.dasm16
2
0
;----------------------------------------------------------------
stdlib.dasm16
3
0
; [sp + 4] struct handle *left
stdlib.dasm16
4
0
; [sp + 3] struct handle *right
stdlib.dasm16
5
0
; [sp + 2] RTS
stdlib.dasm16
6
0
; [sp + 1] a
stdlib.dasm16
7
0
; [sp + 0] b
stdlib.dasm16
8
0
:val_cmp
stdlib.dasm16
9
1
1dc0
0301
    set push, a
stdlib.dasm16
10
1
1dc1
0701
    set push, b
stdlib.dasm16
11
0

stdlib.dasm16
12
2
1dc2
6801
1dc3
0004
    set a, [sp + 4]
stdlib.dasm16
13
2
1dc4
6821
1dc5
0003
    set b, [sp + 3]
stdlib.dasm16
14
0

stdlib.dasm16
15
0
    ; same object?
stdlib.dasm16
16
1
1dc6
0c63
    sub x, x
stdlib.dasm16
17
1
1dc7
0412
    ife a, b
stdlib.dasm16
18
2
1dc8
7f81
1dc9
1df7
        set pc, cmp__finish
stdlib.dasm16
19
0

stdlib.dasm16
20
1
1dca
0301
    set push, a
stdlib.dasm16
21
1
1dcb
0701
    set push, b
stdlib.dasm16
22
2
1dcc
7f01
1dcd
1df7
    set push, cmp__finish
stdlib.dasm16
23
0

stdlib.dasm16
24
1
1dce
8802
    add a, 1
stdlib.dasm16
25
1
1dcf
8822
    add b, 1
stdlib.dasm16
26
0

stdlib.dasm16
27
0
    ; (int,int),(int,bool),(bool,int),(bool,bool)
stdlib.dasm16
28
2
1dd0
7d10
1dd1
0030
    ifb [a], TYPE_BOOL + TYPE_INT
stdlib.dasm16
29
2
1dd2
7d30
1dd3
0030
        ifb [b], TYPE_BOOL + TYPE_INT
stdlib.dasm16
30
2
1dd4
7f81
1dd5
24f4
            set pc, int_cmp
stdlib.dasm16
31
0

stdlib.dasm16
32
0
    ; (float,float)
stdlib.dasm16
33
2
1dd6
7d10
1dd7
0040
    ifb [a], TYPE_FLOAT
stdlib.dasm16
34
2
1dd8
7d30
1dd9
0040
        ifb [b], TYPE_FLOAT
stdlib.dasm16
35
2
1dda
7f81
1ddb
15bd
            set pc, float__cmp
stdlib.dasm16
36
0
    ; (int,float),(bool,float)
stdlib.dasm16
37
2
1ddc
7d10
1ddd
0030
    ifb [a], TYPE_BOOL + TYPE_INT
stdlib.dasm16
38
2
1dde
7d30
1ddf
0040
        ifb [b], TYPE_FLOAT
stdlib.dasm16
39
2
1de0
7f81
1de1
15ab
            set pc, float__cmp__int_float
stdlib.dasm16
40
0
    ; (float,int),(float,bool),
stdlib.dasm16
41
2
1de2
7d10
1de3
0040
    ifb [a], TYPE_FLOAT
stdlib.dasm16
42
2
1de4
7d30
1de5
0030
        ifb [b], TYPE_BOOL + TYPE_INT
stdlib.dasm16
43
2
1de6
7f81
1de7
1599
            set pc, float__cmp__float_int
stdlib.dasm16
44
0

stdlib.dasm16
45
0
    ; (str,str),(ident,ident)
stdlib.dasm16
46
2
1de8
7d10
1de9
0808
    ifb [a], TYPE_STR + TYPE_NAME
stdlib.dasm16
47
1
1dea
2132
        ife [b], [a]
stdlib.dasm16
48
2
1deb
7f81
1dec
2994
            set pc, str_cmp
stdlib.dasm16
49
0

stdlib.dasm16
50
0
    ; (tuple,tuple),(list,list),(dict,dict)
stdlib.dasm16
51
1
1ded
a110
    ifb [a], TYPE_LIST + TYPE_TUPLE + TYPE_DICT
stdlib.dasm16
52
1
1dee
2132
        ife [b], [a]
stdlib.dasm16
53
2
1def
7f81
1df0
2946
            set pc, list_cmp
stdlib.dasm16
54
0

stdlib.dasm16
55
0
    ; compare types
stdlib.dasm16
56
1
1df1
8461
    set x, 0
stdlib.dasm16
57
1
1df2
2514
    ifg [a], [b]
stdlib.dasm16
58
1
1df3
8861
        set x, 1
stdlib.dasm16
59
1
1df4
2516
    ifl [a], [b]
stdlib.dasm16
60
1
1df5
8061
        set x, -1
stdlib.dasm16
61
1
1df6
9362
    add sp, 3
stdlib.dasm16
62
0

stdlib.dasm16
63
0
:cmp__finish
stdlib.dasm16
64
1
1df7
6021
    set b, pop
stdlib.dasm16
65
1
1df8
6001
    set a, pop
stdlib.dasm16
66
0

stdlib.dasm16
67
1
1df9
6321
    set [sp], pop
stdlib.dasm16
68
1
1dfa
6321
    set [sp], pop
stdlib.dasm16
69
0

stdlib.dasm16
70
1
1dfb
6381
    set pc, pop
stdlib.dasm16
71
0

stdlib.dasm16
72
0
;----------------------------------------------------------------
stdlib.dasm16
73
0
; struct handle *eval(struct handle *orig)
stdlib.dasm16
74
0
;----------------------------------------------------------------
stdlib.dasm16
75
0
:eval
stdlib.dasm16
76
1
1dfc
8b01
    set push, 1
stdlib.dasm16
77
1
1dfd
8b01
    set push, 1
stdlib.dasm16
78
2
1dfe
7c20
1dff
2039
    jsr preamble
stdlib.dasm16
79
0
    
stdlib.dasm16
80
2
1e00
5461
1e01
000a
    set x, [z+10]
stdlib.dasm16
81
0

stdlib.dasm16
82
3
1e02
7e70
1e03
0100
1e04
0001
    ifb [x + HANDLE_TYPE], TYPE_TUPLE_COMMA
stdlib.dasm16
83
2
1e05
9661
1e06
0001
        set [x + HANDLE_TYPE], TYPE_TUPLE
stdlib.dasm16
84
0

stdlib.dasm16
85
2
1e07
4c01
1e08
0001
    set a, [x + HANDLE_TYPE]
stdlib.dasm16
86
0

stdlib.dasm16
87
2
1e09
7c12
1e0a
0800
    ife a, TYPE_NAME
stdlib.dasm16
88
2
1e0b
7f81
1e0c
1e1a
        set pc, eval_name
stdlib.dasm16
89
1
1e0d
9412
    ife a, TYPE_TUPLE
stdlib.dasm16
90
2
1e0e
7f81
1e0f
1e24
        set pc, eval_tuple
stdlib.dasm16
91
2
1e10
7c12
1e11
0400
    ife a, TYPE_REFERENCE
stdlib.dasm16
92
2
1e12
7f81
1e13
1e39
        set pc, eval_reference
stdlib.dasm16
93
2
1e14
7c12
1e15
0200
    ife a, TYPE_SUBSCRIPTION
stdlib.dasm16
94
2
1e16
7f81
1e17
1e45
        set pc, eval_subscription
stdlib.dasm16
95
0

stdlib.dasm16
96
2
1e18
7f81
1e19
2026
    set pc, postamble
stdlib.dasm16
97
0

stdlib.dasm16
98
0
:eval_name
stdlib.dasm16
99
2
1e1a
7b01
1e1b
0236
    set push, [current_scope]        ; struct handle *dict
stdlib.dasm16
100
1
1e1c
0f01
    set push, x                        ; struct handle *name
stdlib.dasm16
101
2
1e1d
7c20
1e1e
005c
    jsr scope_get
stdlib.dasm16
102
0

stdlib.dasm16
103
1
1e1f
8472
    ife x, 0
stdlib.dasm16
104
2
1e20
7c20
1e21
00c6
        jsr recover
stdlib.dasm16
105
0

stdlib.dasm16
106
2
1e22
7f81
1e23
2026
    set pc, postamble
stdlib.dasm16
107
0

stdlib.dasm16
108
0
:eval_tuple
stdlib.dasm16
109
1
1e24
0c01
    set a, x
stdlib.dasm16
110
1
1e25
84c1
    set i, 0
stdlib.dasm16
111
1
1e26
2041
    set c, [a]
stdlib.dasm16
112
1
1e27
2841
    set c, [c]
stdlib.dasm16
113
0
    
stdlib.dasm16
114
0
:eval_tuple_loop
stdlib.dasm16
115
1
1e28
08d2
    ife i, c
stdlib.dasm16
116
2
1e29
7f81
1e2a
1e35
        set pc, eval_tuple_break
stdlib.dasm16
117
0

stdlib.dasm16
118
1
1e2b
2021
    set b, [a]
stdlib.dasm16
119
1
1e2c
1822
    add b, i
stdlib.dasm16
120
0
    
stdlib.dasm16
121
2
1e2d
4701
1e2e
0001
    set push, [b+1]
stdlib.dasm16
122
2
1e2f
7c20
1e30
1dfc
    jsr eval
stdlib.dasm16
123
0

stdlib.dasm16
124
2
1e31
0e21
1e32
0001
    set [b+1], x
stdlib.dasm16
125
0

stdlib.dasm16
126
2
1e33
7f9e
1e34
1e28
    sti pc, eval_tuple_loop
stdlib.dasm16
127
0

stdlib.dasm16
128
0
:eval_tuple_break
stdlib.dasm16
129
2
1e35
5461
1e36
000a
    set x, [z+10]
stdlib.dasm16
130
2
1e37
7f81
1e38
2026
    set pc, postamble
stdlib.dasm16
131
0

stdlib.dasm16
132
0
:eval_reference
stdlib.dasm16
133
1
1e39
2c61
    set x, [x]
stdlib.dasm16
134
0

stdlib.dasm16
135
2
1e3a
4f01
1e3b
0001
    set push, [x + REFERENCE_LEFT]        ; struct handle *dict or *list
stdlib.dasm16
136
2
1e3c
4f01
1e3d
0002
    set push, [x + REFERENCE_RIGHT]        ; struct handle *key or index
stdlib.dasm16
137
2
1e3e
7c20
1e3f
005c
    jsr scope_get
stdlib.dasm16
138
0
    
stdlib.dasm16
139
1
1e40
8472
    ife x, 0
stdlib.dasm16
140
2
1e41
7c20
1e42
00c6
        jsr recover
stdlib.dasm16
141
0

stdlib.dasm16
142
2
1e43
7f81
1e44
2026
    set pc, postamble
stdlib.dasm16
143
0

stdlib.dasm16
144
0
:eval_subscription
stdlib.dasm16
145
1
1e45
2c01
    set a, [x]                ; struct subscription *
stdlib.dasm16
146
2
1e46
4021
1e47
0001
    set b, [a + SUBSCRIPTION_LIST]
stdlib.dasm16
147
2
1e48
4041
1e49
0002
    set c, [a + SUBSCRIPTION_INDEX]
stdlib.dasm16
148
0

stdlib.dasm16
149
2
1e4a
8a32
1e4b
0001
    ife [b + HANDLE_TYPE], TYPE_DICT
stdlib.dasm16
150
2
1e4c
7f81
1e4d
1e5c
        set pc, eval_subscription_dict
stdlib.dasm16
151
2
1e4e
8e32
1e4f
0001
    ife [b + HANDLE_TYPE], TYPE_LIST
stdlib.dasm16
152
2
1e50
7f81
1e51
1e65
        set pc, eval_subscription_array
stdlib.dasm16
153
2
1e52
9632
1e53
0001
    ife [b + HANDLE_TYPE], TYPE_TUPLE
stdlib.dasm16
154
2
1e54
7f81
1e55
1e65
        set pc, eval_subscription_array
stdlib.dasm16
155
2
1e56
a632
1e57
0001
    ife [b + HANDLE_TYPE], TYPE_STR
stdlib.dasm16
156
2
1e58
7f81
1e59
1e86
        set pc, eval_subscription_str
stdlib.dasm16
157
0

stdlib.dasm16
158
2
1e5a
7c20
1e5b
00c6
    jsr recover
stdlib.dasm16
159
0

stdlib.dasm16
160
0
:eval_subscription_dict
stdlib.dasm16
161
1
1e5c
0701
    set push, b
stdlib.dasm16
162
1
1e5d
0b01
    set push, c
stdlib.dasm16
163
2
1e5e
7c20
1e5f
005c
    jsr scope_get
stdlib.dasm16
164
0

stdlib.dasm16
165
1
1e60
8472
    ife x, 0
stdlib.dasm16
166
2
1e61
7c20
1e62
00c6
        jsr recover
stdlib.dasm16
167
0

stdlib.dasm16
168
2
1e63
7f81
1e64
2026
    set pc, postamble
stdlib.dasm16
169
0

stdlib.dasm16
170
0
:eval_subscription_array
stdlib.dasm16
171
3
1e65
7e52
1e66
0020
1e67
0001
    ife [c + HANDLE_TYPE], TYPE_INT
stdlib.dasm16
172
2
1e68
7f81
1e69
1e70
        set pc, eval_subscription_array_index
stdlib.dasm16
173
2
1e6a
9652
1e6b
0001
    ife [c + HANDLE_TYPE], TYPE_TUPLE
stdlib.dasm16
174
2
1e6c
7f81
1e6d
1e76
        set pc, eval_subscription_array_slice
stdlib.dasm16
175
2
1e6e
7c20
1e6f
00c6
    jsr recover
stdlib.dasm16
176
0

stdlib.dasm16
177
0
:eval_subscription_array_index
stdlib.dasm16
178
1
1e70
0701
    set push, b
stdlib.dasm16
179
1
1e71
0b01
    set push, c
stdlib.dasm16
180
2
1e72
7c20
1e73
2913
    jsr list_get
stdlib.dasm16
181
0

stdlib.dasm16
182
2
1e74
7f81
1e75
2026
    set pc, postamble
stdlib.dasm16
183
0

stdlib.dasm16
184
0
:eval_subscription_str_slice
stdlib.dasm16
185
0
:eval_subscription_array_slice
stdlib.dasm16
186
1
1e76
2801
    set a, [c]            ; struct slice *
stdlib.dasm16
187
1
1e77
0701
    set push, b
stdlib.dasm16
188
0

stdlib.dasm16
189
2
1e78
4301
1e79
0001
    set push, [a+1]        ; start
stdlib.dasm16
190
2
1e7a
7c20
1e7b
22bc
    jsr int_to_int16
stdlib.dasm16
191
1
1e7c
0f01
    set push, x
stdlib.dasm16
192
0

stdlib.dasm16
193
2
1e7d
4301
1e7e
0002
    set push, [a+2]
stdlib.dasm16
194
2
1e7f
7c20
1e80
22bc
    jsr int_to_int16
stdlib.dasm16
195
1
1e81
0f01
    set push, x
stdlib.dasm16
196
0

stdlib.dasm16
197
2
1e82
7c20
1e83
280e
    jsr array_split    
stdlib.dasm16
198
2
1e84
7f81
1e85
2026
    set pc, postamble
stdlib.dasm16
199
0

stdlib.dasm16
200
0
:eval_subscription_str
stdlib.dasm16
201
3
1e86
7e52
1e87
0020
1e88
0001
    ife [c + HANDLE_TYPE], TYPE_INT
stdlib.dasm16
202
2
1e89
7f81
1e8a
1e91
        set pc, eval_subscription_str_index
stdlib.dasm16
203
2
1e8b
9652
1e8c
0001
    ife [c + HANDLE_TYPE], TYPE_TUPLE
stdlib.dasm16
204
2
1e8d
7f81
1e8e
1e76
        set pc, eval_subscription_str_slice
stdlib.dasm16
205
2
1e8f
7c20
1e90
00c6
    jsr recover
stdlib.dasm16
206
0

stdlib.dasm16
207
0
:eval_subscription_str_index
stdlib.dasm16
208
1
1e91
0701
    set push, b
stdlib.dasm16
209
0

stdlib.dasm16
210
1
1e92
0b01
    set push, c        ; struct handle *int
stdlib.dasm16
211
2
1e93
7c20
1e94
22bc
    jsr int_to_int16
stdlib.dasm16
212
0

stdlib.dasm16
213
0
    ; start index
stdlib.dasm16
214
1
1e95
2481
    set y, [b]
stdlib.dasm16
215
2
1e96
7c70
1e97
8000
    ifb x, 0x8000
stdlib.dasm16
216
1
1e98
3062
        add x, [y]
stdlib.dasm16
217
0
        
stdlib.dasm16
218
1
1e99
3075
    ifa x, [y]
stdlib.dasm16
219
2
1e9a
7c20
1e9b
00c6
        jsr recover
stdlib.dasm16
220
1
1e9c
3072
    ife x, [y]
stdlib.dasm16
221
2
1e9d
7c20
1e9e
00c6
        jsr recover
stdlib.dasm16
222
1
1e9f
8477
    ifu x, 0
stdlib.dasm16
223
2
1ea0
7c20
1ea1
00c6
        jsr recover
stdlib.dasm16
224
0
        
stdlib.dasm16
225
1
1ea2
0f01
    set push, x        ; start
stdlib.dasm16
226
0

stdlib.dasm16
227
1
1ea3
8862
    add x, 1        ; end
stdlib.dasm16
228
1
1ea4
0f01
    set push, x
stdlib.dasm16
229
2
1ea5
7c20
1ea6
280e
    jsr array_split    
stdlib.dasm16
230
0

stdlib.dasm16
231
2
1ea7
7f81
1ea8
2026
    set pc, postamble
stdlib.dasm16
232
0

stdlib.dasm16
233
0
;----------------------------------------------------------------
stdlib.dasm16
234
0
; struct handle *boolean(struct handle *orig)
stdlib.dasm16
235
0
;----------------------------------------------------------------
stdlib.dasm16
236
0
:boolean
stdlib.dasm16
237
1
1ea9
8b01
    set push, 1
stdlib.dasm16
238
1
1eaa
8701
    set push, 0
stdlib.dasm16
239
2
1eab
7c20
1eac
2039
    jsr preamble
stdlib.dasm16
240
0
    
stdlib.dasm16
241
2
1ead
5401
1eae
000a
    set a, [z+10]
stdlib.dasm16
242
1
1eaf
2021
    set b, [a]
stdlib.dasm16
243
0

stdlib.dasm16
244
2
1eb0
7c12
1eb1
029b
    ife a, NONE
stdlib.dasm16
245
2
1eb2
7f81
1eb3
1ed3
        set pc, boolean_false
stdlib.dasm16
246
0
        
stdlib.dasm16
247
2
1eb4
4061
1eb5
0001
    set x, [a + HANDLE_TYPE]
stdlib.dasm16
248
0

stdlib.dasm16
249
2
1eb6
7c70
1eb7
0030
    ifb x, TYPE_INT + TYPE_BOOL
stdlib.dasm16
250
1
1eb8
8932
        ife [b], 1
stdlib.dasm16
251
2
1eb9
8632
1eba
0001
            ife [b+1], 0
stdlib.dasm16
252
2
1ebb
7f81
1ebc
1ed3
                set pc, boolean_false
stdlib.dasm16
253
0

stdlib.dasm16
254
2
1ebd
7c70
1ebe
0040
    ifb x, TYPE_FLOAT
stdlib.dasm16
255
1
1ebf
8132
        ife [b + FLOAT_TYPE], FLOAT_TYPE_PZERO
stdlib.dasm16
256
2
1ec0
7f81
1ec1
1ed3
            set pc, boolean_false
stdlib.dasm16
257
0

stdlib.dasm16
258
2
1ec2
7c70
1ec3
0040
    ifb x, TYPE_FLOAT
stdlib.dasm16
259
1
1ec4
8932
        ife [b + FLOAT_TYPE], FLOAT_TYPE_NZERO
stdlib.dasm16
260
2
1ec5
7f81
1ec6
1ed3
            set pc, boolean_false
stdlib.dasm16
261
0

stdlib.dasm16
262
2
1ec7
7c71
1ec8
0070
    ifc x, TYPE_INT + TYPE_BOOL + TYPE_FLOAT
stdlib.dasm16
263
1
1ec9
8532
        ife [b], 0
stdlib.dasm16
264
2
1eca
7f81
1ecb
1ed3
            set pc, boolean_false
stdlib.dasm16
265
0

stdlib.dasm16
266
1
1ecc
a472
    ife x, TYPE_STR
stdlib.dasm16
267
2
1ecd
7f81
1ece
1ed7
        set pc, boolean_str
stdlib.dasm16
268
0
        
stdlib.dasm16
269
0
:boolean_true
stdlib.dasm16
270
2
1ecf
7c61
1ed0
02e9
    set x, BOOL_TRUE
stdlib.dasm16
271
2
1ed1
7f81
1ed2
2026
    set pc, postamble
stdlib.dasm16
272
0

stdlib.dasm16
273
0
:boolean_false
stdlib.dasm16
274
2
1ed3
7c61
1ed4
02e7
    set x, BOOL_FALSE
stdlib.dasm16
275
2
1ed5
7f81
1ed6
2026
    set pc, postamble
stdlib.dasm16
276
0

stdlib.dasm16
277
0

stdlib.dasm16
278
0
:boolean_str
stdlib.dasm16
279
1
1ed7
0301
    set push, a
stdlib.dasm16
280
2
1ed8
7f01
1ed9
03f5
    set push, STR_FALSE
stdlib.dasm16
281
2
1eda
7c20
1edb
29a6
    jsr str_cmp_ignore_case
stdlib.dasm16
282
1
1edc
8472
    ife x, 0
stdlib.dasm16
283
2
1edd
7f81
1ede
1ed3
        set pc, boolean_false
stdlib.dasm16
284
2
1edf
7f81
1ee0
1ecf
    set pc, boolean_true
stdlib.dasm16
285
0

stdlib.dasm16
286
0
;----------------------------------------------------------------
stdlib.dasm16
287
0
; struct handle *sort(struct handle *iterable, struct handle *reverse)
stdlib.dasm16
288
0
;----------------------------------------------------------------
stdlib.dasm16
289
0
:sort
stdlib.dasm16
290
1
1ee1
8f01
    set push, 2
stdlib.dasm16
291
1
1ee2
8b01
    set push, 1
stdlib.dasm16
292
2
1ee3
7c20
1ee4
2039
    jsr preamble
stdlib.dasm16
293
0
    
stdlib.dasm16
294
2
1ee5
5401
1ee6
000b
    set a, [z+11]
stdlib.dasm16
295
2
1ee7
5421
1ee8
000a
    set b, [z+10]
stdlib.dasm16
296
0

stdlib.dasm16
297
2
1ee9
a612
1eea
0001
    ife [a + HANDLE_TYPE], TYPE_STR
stdlib.dasm16
298
2
1eeb
7f81
1eec
1ef3
        set pc, sort_string
stdlib.dasm16
299
2
1eed
9e10
1eee
0001
    ifb [a + HANDLE_TYPE], TYPE_TUPLE + TYPE_LIST
stdlib.dasm16
300
2
1eef
7f81
1ef0
1f17
        set pc, sort_array
stdlib.dasm16
301
0
        
stdlib.dasm16
302
2
1ef1
7c20
1ef2
00c6
    jsr recover
stdlib.dasm16
303
0

stdlib.dasm16
304
0
:sort_string
stdlib.dasm16
305
1
1ef3
0301
    set push, a
stdlib.dasm16
306
2
1ef4
7c20
1ef5
28ca
    jsr array_clone
stdlib.dasm16
307
2
1ef6
0ea1
1ef7
ffff
    set [z-1], x
stdlib.dasm16
308
0

stdlib.dasm16
309
1
1ef8
0f01
    set push, x
stdlib.dasm16
310
2
1ef9
7c32
1efa
02e9
    ife b, BOOL_TRUE
stdlib.dasm16
311
2
1efb
7f01
1efc
1f0f
        set push, char_reverse_comparator
stdlib.dasm16
312
2
1efd
7c32
1efe
02e7
    ife b, BOOL_FALSE
stdlib.dasm16
313
2
1eff
7f01
1f00
1f07
        set push, char_comparator
stdlib.dasm16
314
0
        
stdlib.dasm16
315
2
1f01
7c20
1f02
28a8
    jsr array_sort
stdlib.dasm16
316
2
1f03
5461
1f04
ffff
    set x, [z-1]
stdlib.dasm16
317
2
1f05
7f81
1f06
2026
    set pc, postamble
stdlib.dasm16
318
0
    
stdlib.dasm16
319
0
:char_comparator
stdlib.dasm16
320
1
1f07
8461
    set x, FALSE
stdlib.dasm16
321
3
1f08
6b56
1f09
0001
1f0a
0002
    ifl [sp+2], [sp+1]
stdlib.dasm16
322
1
1f0b
8861
        set x, TRUE
stdlib.dasm16
323
0

stdlib.dasm16
324
1
1f0c
64c1
    set i, [sp]
stdlib.dasm16
325
1
1f0d
9362
    add sp, 3
stdlib.dasm16
326
1
1f0e
1b81
    set pc, i
stdlib.dasm16
327
0

stdlib.dasm16
328
0
:char_reverse_comparator
stdlib.dasm16
329
1
1f0f
8461
    set x, FALSE
stdlib.dasm16
330
3
1f10
6b54
1f11
0001
1f12
0002
    ifg [sp+2], [sp+1]
stdlib.dasm16
331
1
1f13
8861
        set x, TRUE
stdlib.dasm16
332
0

stdlib.dasm16
333
1
1f14
64c1
    set i, [sp]
stdlib.dasm16
334
1
1f15
9362
    add sp, 3
stdlib.dasm16
335
1
1f16
1b81
    set pc, i
stdlib.dasm16
336
0

stdlib.dasm16
337
0
:sort_array
stdlib.dasm16
338
1
1f17
0301
    set push, a
stdlib.dasm16
339
2
1f18
7c32
1f19
02e9
    ife b, BOOL_TRUE
stdlib.dasm16
340
2
1f1a
7f01
1f1b
1f31
        set push, array_reverse_comparator
stdlib.dasm16
341
2
1f1c
7c32
1f1d
02e7
    ife b, BOOL_FALSE
stdlib.dasm16
342
2
1f1e
7f01
1f1f
1f26
        set push, array_comparator
stdlib.dasm16
343
0
        
stdlib.dasm16
344
2
1f20
7c20
1f21
28a8
    jsr array_sort
stdlib.dasm16
345
2
1f22
5461
1f23
000b
    set x, [z+11]
stdlib.dasm16
346
2
1f24
7f81
1f25
2026
    set pc, postamble
stdlib.dasm16
347
0

stdlib.dasm16
348
0
:array_comparator
stdlib.dasm16
349
1
1f26
60c1
    set i, pop
stdlib.dasm16
350
2
1f27
7c20
1f28
1dc0
    jsr val_cmp
stdlib.dasm16
351
1
1f29
1b01
    set push, i
stdlib.dasm16
352
0
    
stdlib.dasm16
353
1
1f2a
8072
    ife x, -1
stdlib.dasm16
354
2
1f2b
7f81
1f2c
1f2f
        set pc, array_comparator_true
stdlib.dasm16
355
1
1f2d
8461
    set x, FALSE
stdlib.dasm16
356
1
1f2e
1b81
    set pc, i
stdlib.dasm16
357
0
:array_comparator_true
stdlib.dasm16
358
1
1f2f
8861
    set x, TRUE
stdlib.dasm16
359
1
1f30
1b81
    set pc, i
stdlib.dasm16
360
0

stdlib.dasm16
361
0
:array_reverse_comparator
stdlib.dasm16
362
1
1f31
60c1
    set i, pop
stdlib.dasm16
363
2
1f32
7c20
1f33
1dc0
    jsr val_cmp
stdlib.dasm16
364
1
1f34
1b01
    set push, i
stdlib.dasm16
365
0
    
stdlib.dasm16
366
1
1f35
8872
    ife x, 1
stdlib.dasm16
367
2
1f36
7f81
1f37
1f2f
        set pc, array_comparator_true
stdlib.dasm16
368
1
1f38
8461
    set x, FALSE
stdlib.dasm16
369
1
1f39
1b81
    set pc, i
stdlib.dasm16
370
0

stdlib.dasm16
371
0
;----------------------------------------------------------------
stdlib.dasm16
372
0
; struct handle *assign(struct handle *left, struct handle *right)
stdlib.dasm16
373
0
;----------------------------------------------------------------
stdlib.dasm16
374
0
:assign
stdlib.dasm16
375
1
1f3a
8f01
    set push, 2
stdlib.dasm16
376
1
1f3b
8f01
    set push, 2
stdlib.dasm16
377
2
1f3c
7c20
1f3d
2039
    jsr preamble
stdlib.dasm16
378
0
    
stdlib.dasm16
379
2
1f3e
5401
1f3f
000b
    set a, [z+11]
stdlib.dasm16
380
2
1f40
5421
1f41
000a
    set b, [z+10]
stdlib.dasm16
381
0

stdlib.dasm16
382
3
1f42
7e12
1f43
0100
1f44
0001
    ife [a + HANDLE_TYPE], TYPE_TUPLE_COMMA
stdlib.dasm16
383
2
1f45
9601
1f46
0001
        set [a + HANDLE_TYPE], TYPE_TUPLE
stdlib.dasm16
384
0

stdlib.dasm16
385
3
1f47
7e12
1f48
0800
1f49
0001
    ife [a + HANDLE_TYPE], TYPE_NAME
stdlib.dasm16
386
2
1f4a
7f81
1f4b
1f88
        set pc, assign_name
stdlib.dasm16
387
2
1f4c
9612
1f4d
0001
    ife [a + HANDLE_TYPE], TYPE_TUPLE
stdlib.dasm16
388
2
1f4e
7f81
1f4f
1f92
        set pc, assign_tuple
stdlib.dasm16
389
3
1f50
7e12
1f51
0400
1f52
0001
    ife [a + HANDLE_TYPE], TYPE_REFERENCE
stdlib.dasm16
390
2
1f53
7f81
1f54
1f7d
        set pc, assign_reference
stdlib.dasm16
391
3
1f55
7e12
1f56
0200
1f57
0001
    ife [a + HANDLE_TYPE], TYPE_SUBSCRIPTION
stdlib.dasm16
392
2
1f58
7f81
1f59
1f5c
        set pc, assign_subscription
stdlib.dasm16
393
0

stdlib.dasm16
394
2
1f5a
7c20
1f5b
00c6
    jsr recover
stdlib.dasm16
395
0

stdlib.dasm16
396
0
:assign_subscription
stdlib.dasm16
397
1
1f5c
2001
    set a, [a]
stdlib.dasm16
398
2
1f5d
4081
1f5e
0001
    set y, [a + SUBSCRIPTION_LIST]
stdlib.dasm16
399
2
1f5f
4041
1f60
0002
    set c, [a + SUBSCRIPTION_INDEX]
stdlib.dasm16
400
0

stdlib.dasm16
401
2
1f61
8a92
1f62
0001
    ife [y + HANDLE_TYPE], TYPE_DICT
stdlib.dasm16
402
3
1f63
7e50
1f64
00f8
1f65
0001
        ifb [c + HANDLE_TYPE], TYPE_GROUP_IMMUTABLE
stdlib.dasm16
403
2
1f66
7f81
1f67
1f79
            set pc, assign_subscription_dict
stdlib.dasm16
404
0
    
stdlib.dasm16
405
2
1f68
8e92
1f69
0001
    ife [y + HANDLE_TYPE], TYPE_LIST
stdlib.dasm16
406
3
1f6a
7e52
1f6b
0020
1f6c
0001
        ife [c + HANDLE_TYPE], TYPE_INT
stdlib.dasm16
407
2
1f6d
7f81
1f6e
1f71
            set pc, assign_subscription_list_int
stdlib.dasm16
408
0

stdlib.dasm16
409
2
1f6f
7c20
1f70
00c6
    jsr recover
stdlib.dasm16
410
0

stdlib.dasm16
411
0
:assign_subscription_list_int
stdlib.dasm16
412
1
1f71
1301
    set push, y
stdlib.dasm16
413
1
1f72
0b01
    set push, c
stdlib.dasm16
414
1
1f73
0701
    set push, b
stdlib.dasm16
415
2
1f74
7c20
1f75
2922
    jsr list_set
stdlib.dasm16
416
0

stdlib.dasm16
417
1
1f76
0461
    set x, b
stdlib.dasm16
418
2
1f77
7f81
1f78
2026
    set pc, postamble
stdlib.dasm16
419
0

stdlib.dasm16
420
0
:assign_subscription_dict
stdlib.dasm16
421
1
1f79
1301
    set push, y
stdlib.dasm16
422
1
1f7a
0b01
    set push, c
stdlib.dasm16
423
2
1f7b
7f81
1f7c
1f82
    set pc, assign_reference_or_subscription_dict
stdlib.dasm16
424
0

stdlib.dasm16
425
0
:assign_reference
stdlib.dasm16
426
1
1f7d
2001
    set a, [a]
stdlib.dasm16
427
2
1f7e
4301
1f7f
0001
    set push, [a + REFERENCE_LEFT]
stdlib.dasm16
428
2
1f80
4301
1f81
0002
    set push, [a + REFERENCE_RIGHT]
stdlib.dasm16
429
0
:assign_reference_or_subscription_dict
stdlib.dasm16
430
1
1f82
0701
    set push, b
stdlib.dasm16
431
2
1f83
7c20
1f84
2f54
    jsr dict__set
stdlib.dasm16
432
1
1f85
0461
    set x, b
stdlib.dasm16
433
2
1f86
7f81
1f87
2026
    set pc, postamble
stdlib.dasm16
434
0
    
stdlib.dasm16
435
0
:assign_name
stdlib.dasm16
436
2
1f88
7b01
1f89
0236
    set push, [current_scope]
stdlib.dasm16
437
1
1f8a
0301
    set push, a
stdlib.dasm16
438
1
1f8b
0701
    set push, b
stdlib.dasm16
439
1
1f8c
9701
    set push, SCOPE_MODE_INSERT
stdlib.dasm16
440
2
1f8d
7c20
1f8e
0096
    jsr scope_set
stdlib.dasm16
441
0

stdlib.dasm16
442
1
1f8f
0461
    set x, b
stdlib.dasm16
443
2
1f90
7f81
1f91
2026
    set pc, postamble
stdlib.dasm16
444
0
    
stdlib.dasm16
445
0
:assign_tuple
stdlib.dasm16
446
1
1f92
84c1
    set i, 0
stdlib.dasm16
447
1
1f93
2041
    set c, [a]
stdlib.dasm16
448
1
1f94
2841
    set c, [c]            ; left side size
stdlib.dasm16
449
0

stdlib.dasm16
450
1
1f95
2481
    set y, [b]
stdlib.dasm16
451
1
1f96
0993
    ifn [y], c            ; if leftLen != rightLen
stdlib.dasm16
452
2
1f97
7c20
1f98
00c6
        jsr recover
stdlib.dasm16
453
0

stdlib.dasm16
454
0
:assign_tuple_loop
stdlib.dasm16
455
1
1f99
08d2
    ife i, c
stdlib.dasm16
456
2
1f9a
7f81
1f9b
1fae
        set pc, assign_tuple_break
stdlib.dasm16
457
0

stdlib.dasm16
458
1
1f9c
2061
    set x, [a]
stdlib.dasm16
459
1
1f9d
1862
    add x, i
stdlib.dasm16
460
2
1f9e
4f01
1f9f
0001
    set push, [x+1]
stdlib.dasm16
461
0
    
stdlib.dasm16
462
1
1fa0
2461
    set x, [b]
stdlib.dasm16
463
1
1fa1
1862
    add x, i
stdlib.dasm16
464
2
1fa2
4f01
1fa3
0001
    set push, [x+1]
stdlib.dasm16
465
0

stdlib.dasm16
466
2
1fa4
a632
1fa5
0001
    ife [b + HANDLE_TYPE], TYPE_STR
stdlib.dasm16
467
2
1fa6
7c20
1fa7
1fb1
        jsr assign_from_string
stdlib.dasm16
468
2
1fa8
a633
1fa9
0001
    ifn [b + HANDLE_TYPE], TYPE_STR
stdlib.dasm16
469
2
1faa
7c20
1fab
1f3a
        jsr assign
stdlib.dasm16
470
0

stdlib.dasm16
471
2
1fac
7f9e
1fad
1f99
    sti pc, assign_tuple_loop
stdlib.dasm16
472
0

stdlib.dasm16
473
0
:assign_tuple_break
stdlib.dasm16
474
1
1fae
0461
    set x, b
stdlib.dasm16
475
2
1faf
7f81
1fb0
2026
    set pc, postamble
stdlib.dasm16
476
0

stdlib.dasm16
477
0
;----------------------------------------------------------------
stdlib.dasm16
478
0
; struct handle *assign_from_string(struct handle *left, uint16 char)
stdlib.dasm16
479
0
;   e.g. a,b = "xy"
stdlib.dasm16
480
0
;----------------------------------------------------------------
stdlib.dasm16
481
0
:assign_from_string
stdlib.dasm16
482
1
1fb1
8f01
    set push, 2
stdlib.dasm16
483
1
1fb2
8b01
    set push, 1
stdlib.dasm16
484
2
1fb3
7c20
1fb4
2039
    jsr preamble
stdlib.dasm16
485
0
    
stdlib.dasm16
486
2
1fb5
5401
1fb6
000b
    set a, [z+11]
stdlib.dasm16
487
0

stdlib.dasm16
488
1
1fb7
8b01
    set push, 1
stdlib.dasm16
489
1
1fb8
a701
    set push, TYPE_STR
stdlib.dasm16
490
2
1fb9
7c20
1fba
2770
    jsr array_create
stdlib.dasm16
491
2
1fbb
0ea1
1fbc
ffff
    set [z-1], x
stdlib.dasm16
492
1
1fbd
0c21
    set b, x
stdlib.dasm16
493
0

stdlib.dasm16
494
1
1fbe
2c41
    set c, [x]
stdlib.dasm16
495
3
1fbf
5641
1fc0
000a
1fc1
0001
    set [c+1], [z+10]
stdlib.dasm16
496
0

stdlib.dasm16
497
3
1fc2
7e12
1fc3
0800
1fc4
0001
    ife [a + HANDLE_TYPE], TYPE_NAME
stdlib.dasm16
498
2
1fc5
7f81
1fc6
1f88
        set pc, assign_name
stdlib.dasm16
499
0

stdlib.dasm16
500
2
1fc7
7c81
1fc8
00c6
    set y, recover
stdlib.dasm16
501
3
1fc9
7e12
1fca
0400
1fcb
0001
    ife [a + HANDLE_TYPE], TYPE_REFERENCE
stdlib.dasm16
502
2
1fcc
7c81
1fcd
2f54
        set y, dict__set
stdlib.dasm16
503
3
1fce
7e12
1fcf
0200
1fd0
0001
    ife [a + HANDLE_TYPE], TYPE_SUBSCRIPTION
stdlib.dasm16
504
2
1fd1
7c81
1fd2
2922
        set y, list_set
stdlib.dasm16
505
0

stdlib.dasm16
506
1
1fd3
2001
    set a, [a]
stdlib.dasm16
507
2
1fd4
4301
1fd5
0001
    set push, [a + REFERENCE_LEFT] ; = SUBSCRIPTION_LIST
stdlib.dasm16
508
2
1fd6
4301
1fd7
0002
    set push, [a + REFERENCE_RIGHT] ; = SUBSCRIPTION_INDEX
stdlib.dasm16
509
1
1fd8
0701
    set push, b
stdlib.dasm16
510
1
1fd9
1020
    jsr y
stdlib.dasm16
511
0
    
stdlib.dasm16
512
1
1fda
0461
    set x, b
stdlib.dasm16
513
2
1fdb
7f81
1fdc
2026
    set pc, postamble
stdlib.dasm16
514
0
    
stdlib.dasm16
515
0
;----------------------------------------------------------------
stdlib.dasm16
516
0
; void del(struct handle *item)
stdlib.dasm16
517
0
;----------------------------------------------------------------
stdlib.dasm16
518
0
:del
stdlib.dasm16
519
1
1fdd
8b01
    set push, 1
stdlib.dasm16
520
1
1fde
8b01
    set push, 1
stdlib.dasm16
521
2
1fdf
7c20
1fe0
2039
    jsr preamble
stdlib.dasm16
522
0
    
stdlib.dasm16
523
2
1fe1
5401
1fe2
000a
    set a, [z+10]
stdlib.dasm16
524
0

stdlib.dasm16
525
3
1fe3
7e12
1fe4
0800
1fe5
0001
    ife [a + HANDLE_TYPE], TYPE_NAME
stdlib.dasm16
526
2
1fe6
7f81
1fe7
1ffe
        set pc, del_name
stdlib.dasm16
527
0

stdlib.dasm16
528
2
1fe8
7c81
1fe9
00c6
    set y, recover
stdlib.dasm16
529
3
1fea
7e12
1feb
0200
1fec
0001
    ife [a + HANDLE_TYPE], TYPE_SUBSCRIPTION
stdlib.dasm16
530
2
1fed
7c81
1fee
2933
        set y, list_del
stdlib.dasm16
531
0

stdlib.dasm16
532
1
1fef
2001
    set a, [a]
stdlib.dasm16
533
2
1ff0
4021
1ff1
0001
    set b, [a + REFERENCE_LEFT]
stdlib.dasm16
534
2
1ff2
8a32
1ff3
0001
    ife [b + HANDLE_TYPE], TYPE_DICT
stdlib.dasm16
535
2
1ff4
7c81
1ff5
2f89
        set y, dict_del
stdlib.dasm16
536
0
    
stdlib.dasm16
537
1
1ff6
0701
    set push, b                     ; LEFT
stdlib.dasm16
538
2
1ff7
4301
1ff8
0002
    set push, [a + REFERENCE_RIGHT] ; RIGHT
stdlib.dasm16
539
1
1ff9
1020
    jsr y
stdlib.dasm16
540
0
    
stdlib.dasm16
541
2
1ffa
7c61
1ffb
029b
    set x, NONE
stdlib.dasm16
542
2
1ffc
7f81
1ffd
2026
    set pc, postamble
stdlib.dasm16
543
0
    
stdlib.dasm16
544
0
:del_name
stdlib.dasm16
545
2
1ffe
7b01
1fff
0236
    set push, [current_scope]
stdlib.dasm16
546
1
2000
0301
    set push, a
stdlib.dasm16
547
2
2001
7c20
2002
0079
    jsr scope_del
stdlib.dasm16
548
0

stdlib.dasm16
549
2
2003
7c61
2004
029b
    set x, NONE
stdlib.dasm16
550
2
2005
7f81
2006
2026
    set pc, postamble
stdlib.dasm16
551
0
    
stdlib.dasm16
552
0
;----------------------------------------------------------------
stdlib.dasm16
553
0
:cast_common_number_type
stdlib.dasm16
554
0
; fastcall
stdlib.dasm16
555
0
;   a: struct handle *left
stdlib.dasm16
556
0
;   b: struct handle *right
stdlib.dasm16
557
0
; return
stdlib.dasm16
558
0
;   a: struct handle *left_or_new_left
stdlib.dasm16
559
0
;   b: struct handle *right_or_new_right
stdlib.dasm16
560
0
;----------------------------------------------------------------
stdlib.dasm16
561
0
    ; automatic type conversions
stdlib.dasm16
562
3
2007
7e10
2008
0030
2009
0001
    ifb [a + HANDLE_TYPE], TYPE_INT + TYPE_BOOL
stdlib.dasm16
563
3
200a
7e32
200b
0040
200c
0001
        ife [b + HANDLE_TYPE], TYPE_FLOAT
stdlib.dasm16
564
2
200d
7f81
200e
2018
            set pc, itof_left
stdlib.dasm16
565
0
    
stdlib.dasm16
566
3
200f
7e30
2010
0030
2011
0001
    ifb [b + HANDLE_TYPE], TYPE_INT + TYPE_BOOL
stdlib.dasm16
567
3
2012
7e12
2013
0040
2014
0001
        ife [a + HANDLE_TYPE], TYPE_FLOAT
stdlib.dasm16
568
2
2015
7f81
2016
201f
            set pc, itof_right
stdlib.dasm16
569
0

stdlib.dasm16
570
1
2017
6381
    set pc, pop
stdlib.dasm16
571
0

stdlib.dasm16
572
0
:itof_left
stdlib.dasm16
573
1
2018
0301
    set push, a
stdlib.dasm16
574
2
2019
7c20
201a
1757
    jsr float__from_int
stdlib.dasm16
575
2
201b
0ea1
201c
ffff
    set [z-1], x
stdlib.dasm16
576
1
201d
0c01
    set a, x
stdlib.dasm16
577
1
201e
6381
    set pc, pop
stdlib.dasm16
578
0

stdlib.dasm16
579
0
:itof_right
stdlib.dasm16
580
1
201f
0701
    set push, b
stdlib.dasm16
581
2
2020
7c20
2021
1757
    jsr float__from_int
stdlib.dasm16
582
2
2022
0ea1
2023
fffe
    set [z-2], x
stdlib.dasm16
583
1
2024
0c21
    set b, x
stdlib.dasm16
584
1
2025
6381
    set pc, pop
stdlib.dasm16
585
0

stdlib.dasm16
586
0
        
stdlib.dasm16
587
0
;----------------------------------------------------------------
stdlib.dasm16
588
0
; utility subroutines to handle function setup and cleanup
stdlib.dasm16
589
0
;----------------------------------------------------------------
stdlib.dasm16
590
0

stdlib.dasm16
591
0
; postamble - subroutines must call postamble to return from
stdlib.dasm16
592
0
; if subroutine was intitialized by preamble. postamble will
stdlib.dasm16
593
0
; restore register and stack to original state and do rts.
stdlib.dasm16
594
0
; x:   return value
stdlib.dasm16
595
0
:postamble
stdlib.dasm16
596
1
2026
1761
    set sp, z                ; free local vars and heap refs
stdlib.dasm16
597
1
2027
60a1
    set z, pop                ; restore fp
stdlib.dasm16
598
0
    
stdlib.dasm16
599
1
2028
6081
    set y, pop                ; restore registers
stdlib.dasm16
600
1
2029
60e1
    set j, pop
stdlib.dasm16
601
1
202a
60c1
    set i, pop
stdlib.dasm16
602
1
202b
6041
    set c, pop
stdlib.dasm16
603
1
202c
6021
    set b, pop
stdlib.dasm16
604
1
202d
6001
    set a, pop
stdlib.dasm16
605
0

stdlib.dasm16
606
1
202e
8b62
    add sp, 1                ; pop sizeof(heap refs)
stdlib.dasm16
607
0

stdlib.dasm16
608
1
202f
6f22
    add [sp], sp            ; calculate ptr to 1st arg
stdlib.dasm16
609
1
2030
8b22
    add [sp], 1                ; sp + num args + 1
stdlib.dasm16
610
0

stdlib.dasm16
611
0
    ; no good... but i couldn't figure out better way to do this
stdlib.dasm16
612
1
2031
1701
    set push, z                ; store fp to free a register for processing
stdlib.dasm16
613
2
2032
68a1
2033
0001
    set z, [sp+1]            ; peek ptr to 1st arg
stdlib.dasm16
614
2
2034
69a1
2035
0002
    set [z], [sp+2]            ; overwrite 1st arg with original return address
stdlib.dasm16
615
1
2036
60a1
    set z, pop                ; pop fp
stdlib.dasm16
616
1
2037
6761
    set sp, [sp]            ; clear stack except for the return address
stdlib.dasm16
617
0
    ; ---
stdlib.dasm16
618
0

stdlib.dasm16
619
1
2038
6381
    set pc, pop                ; rts
stdlib.dasm16
620
0

stdlib.dasm16
621
0
; preamble - subroutines must 
stdlib.dasm16
622
0
;  1. push number of subroutine arguments
stdlib.dasm16
623
0
;  2. push number of required heap references 
stdlib.dasm16
624
0
;  3. call preamble before doing ANYTHING else 
stdlib.dasm16
625
0
;
stdlib.dasm16
626
0
; Stack after preamble
stdlib.dasm16
627
0
;         [preamble]
stdlib.dasm16
628
0
; [sp+ 0] [fp- 1] heap reference (<-sp)
stdlib.dasm16
629
0
; [sp+ 1] [fp+ 0] FP (<-z)
stdlib.dasm16
630
0
; [sp+ 2] [fp+ 1] y
stdlib.dasm16
631
0
; [sp+ 3] [fp+ 2] j
stdlib.dasm16
632
0
; [sp+ 4] [fp+ 3] i
stdlib.dasm16
633
0
; [sp+ 5] [fp+ 4] c
stdlib.dasm16
634
0
; [sp+ 6] [fp+ 5] b
stdlib.dasm16
635
0
; [sp+ 7] [fp+ 6] a
stdlib.dasm16
636
0
;          [callee]
stdlib.dasm16
637
0
; [sp+ 8] [fp+ 7] sizeof(heap_references) (e.g. 1)
stdlib.dasm16
638
0
; [sp+ 9] [fp+ 8] sizeof(args) (e.g. 2)
stdlib.dasm16
639
0
;          [caller]
stdlib.dasm16
640
0
; [sp+10] [fp+9] RTS (to caller func)
stdlib.dasm16
641
0
; [sp+11] [fp+10] arg2 (rightmost)
stdlib.dasm16
642
0
; [sp+12] [fp+11] arg1 (leftmost)
stdlib.dasm16
643
0
:preamble
stdlib.dasm16
644
1
2039
6061
    set x, pop                ; pop return address
stdlib.dasm16
645
0

stdlib.dasm16
646
0
    ; store registers
stdlib.dasm16
647
1
203a
0301
    set push, a
stdlib.dasm16
648
1
203b
0701
    set push, b
stdlib.dasm16
649
1
203c
0b01
    set push, c
stdlib.dasm16
650
1
203d
1b01
    set push, i
stdlib.dasm16
651
1
203e
1f01
    set push, j
stdlib.dasm16
652
1
203f
1301
    set push, y
stdlib.dasm16
653
0

stdlib.dasm16
654
0
    ; update frame pointer
stdlib.dasm16
655
1
2040
1701
    set push, z                ; old fp
stdlib.dasm16
656
1
2041
6ca1
    set z, sp                ; new fp
stdlib.dasm16
657
0

stdlib.dasm16
658
0
    ; init local variables and heap references to 0
stdlib.dasm16
659
1
2042
6cc1
    set i, sp
stdlib.dasm16
660
2
2043
54c3
2044
0007
    sub i, [z+7]
stdlib.dasm16
661
0

stdlib.dasm16
662
0
:preamble_init_local
stdlib.dasm16
663
1
2045
1b72
    ife sp, i
stdlib.dasm16
664
1
2046
0f81
        set pc, x
stdlib.dasm16
665
1
2047
8701
    set push, 0
stdlib.dasm16
666
0

stdlib.dasm16
667
2
2048
7f81
2049
2045
    set pc, preamble_init_local
stdlib.dasm16
668
0

stdlib.dasm16
669
0

stdlib.dasm16
670
0
;----------------------------------------------------------------
stdlib.dasm16
671
0
; void print(struct handle *string)
stdlib.dasm16
672
0
;----------------------------------------------------------------
stdlib.dasm16
673
0
:print_repr
stdlib.dasm16
674
1
204a
8b01
    set push, 1
stdlib.dasm16
675
1
204b
8b01
    set push, 1
stdlib.dasm16
676
2
204c
7c20
204d
2039
    jsr preamble
stdlib.dasm16
677
0

stdlib.dasm16
678
2
204e
7f81
204f
205b
    set pc, print_with_repr
stdlib.dasm16
679
0
;----------------------------------------------------------------
stdlib.dasm16
680
0
; void print(struct handle *string)
stdlib.dasm16
681
0
;----------------------------------------------------------------
stdlib.dasm16
682
0
:print
stdlib.dasm16
683
1
2050
8b01
    set push, 1
stdlib.dasm16
684
1
2051
8b01
    set push, 1
stdlib.dasm16
685
2
2052
7c20
2053
2039
    jsr preamble
stdlib.dasm16
686
0

stdlib.dasm16
687
1
2054
8481
    set y, FALSE
stdlib.dasm16
688
0

stdlib.dasm16
689
2
2055
5401
2056
000a
    set a, [z+10]
stdlib.dasm16
690
2
2057
a612
2058
0001
    ife [a + HANDLE_TYPE], TYPE_STR
stdlib.dasm16
691
2
2059
7f81
205a
2063
        set pc, print_skip_repr
stdlib.dasm16
692
0

stdlib.dasm16
693
0
:print_with_repr
stdlib.dasm16
694
2
205b
5701
205c
000a
    set push, [z+10]
stdlib.dasm16
695
2
205d
7c20
205e
2086
    jsr repr
stdlib.dasm16
696
2
205f
0ea1
2060
ffff
    set [z-1], x
stdlib.dasm16
697
1
2061
0c01
    set a, x
stdlib.dasm16
698
0
    
stdlib.dasm16
699
1
2062
8881
    set y, TRUE
stdlib.dasm16
700
0

stdlib.dasm16
701
0
:print_skip_repr
stdlib.dasm16
702
1
2063
8021
    set b, 0xffff        ; index
stdlib.dasm16
703
0

stdlib.dasm16
704
0
:print_loop
stdlib.dasm16
705
1
2064
8822
    add b, 1
stdlib.dasm16
706
2
2065
7c20
2066
277f
    jsr array__get
stdlib.dasm16
707
0

stdlib.dasm16
708
0
:print_loop__check
stdlib.dasm16
709
1
2067
8472
    ife x, 0
stdlib.dasm16
710
2
2068
7f81
2069
2026
        set pc, postamble
stdlib.dasm16
711
0

stdlib.dasm16
712
1
206a
8492
    ife y, FALSE
stdlib.dasm16
713
2
206b
7c72
206c
002f
        ife x, 47
stdlib.dasm16
714
2
206d
7f81
206e
2074
            set pc, print_loop_escape
stdlib.dasm16
715
0

stdlib.dasm16
716
1
206f
0c41
    set c, x            ; char
stdlib.dasm16
717
2
2070
7c20
2071
2ef4
    jsr screen_add_char
stdlib.dasm16
718
0

stdlib.dasm16
719
2
2072
7f81
2073
2064
    set pc, print_loop
stdlib.dasm16
720
0

stdlib.dasm16
721
0
:print_loop_escape
stdlib.dasm16
722
1
2074
8822
    add b, 1
stdlib.dasm16
723
2
2075
7c20
2076
277f
    jsr array__get
stdlib.dasm16
724
0
    
stdlib.dasm16
725
2
2077
7c72
2078
006e
    ife x, 'n'
stdlib.dasm16
726
2
2079
7f81
207a
2081
        set pc, print_loop_newline
stdlib.dasm16
727
0
        
stdlib.dasm16
728
2
207b
7c41
207c
002f
    set c, 47
stdlib.dasm16
729
2
207d
7c20
207e
2ef4
    jsr screen_add_char
stdlib.dasm16
730
0
    
stdlib.dasm16
731
2
207f
7f81
2080
2067
    set pc, print_loop__check
stdlib.dasm16
732
0

stdlib.dasm16
733
0
:print_loop_newline
stdlib.dasm16
734
1
2081
ac41
    set c, 10
stdlib.dasm16
735
2
2082
7c20
2083
2ef4
    jsr screen_add_char
stdlib.dasm16
736
0

stdlib.dasm16
737
2
2084
7f81
2085
2064
    set pc, print_loop
stdlib.dasm16
738
0

stdlib.dasm16
739
0
;----------------------------------------------------------------
stdlib.dasm16
740
0
; struct handle *repr(struct handle *value)
stdlib.dasm16
741
0
;----------------------------------------------------------------
stdlib.dasm16
742
0
:repr
stdlib.dasm16
743
1
2086
8b01
    set push, 1
stdlib.dasm16
744
1
2087
8b01
    set push, 1
stdlib.dasm16
745
2
2088
7c20
2089
2039
    jsr preamble
stdlib.dasm16
746
0

stdlib.dasm16
747
0
;    set push, [z+10]
stdlib.dasm16
748
0
;    jsr eval
stdlib.dasm16
749
0
;    set [z-1], x
stdlib.dasm16
750
0
;    set a, x
stdlib.dasm16
751
0

stdlib.dasm16
752
2
208a
5461
208b
000a
    set x, [z+10]
stdlib.dasm16
753
0

stdlib.dasm16
754
2
208c
a672
208d
0001
    ife [x + HANDLE_TYPE], TYPE_STR
stdlib.dasm16
755
2
208e
7f81
208f
20b6
        set pc, repr_string
stdlib.dasm16
756
3
2090
7e72
2091
0800
2092
0001
    ife [x + HANDLE_TYPE], TYPE_NAME
stdlib.dasm16
757
2
2093
7f81
2094
2026
        set pc, postamble
stdlib.dasm16
758
2
2095
c672
2096
0001
    ife [x + HANDLE_TYPE], TYPE_BOOL
stdlib.dasm16
759
2
2097
7f81
2098
20d7
        set pc, repr_boolean
stdlib.dasm16
760
3
2099
7e72
209a
0080
209b
0001
    ife [x + HANDLE_TYPE], TYPE_NONE
stdlib.dasm16
761
2
209c
7f81
209d
20e0
        set pc, repr_none
stdlib.dasm16
762
0

stdlib.dasm16
763
2
209e
7c81
209f
00c6
    set y, recover
stdlib.dasm16
764
3
20a0
7e72
20a1
0020
20a2
0001
    ife [x + HANDLE_TYPE], TYPE_INT
stdlib.dasm16
765
2
20a3
7c81
20a4
2371
        set y, int_to_str
stdlib.dasm16
766
3
20a5
7e72
20a6
0040
20a7
0001
    ife [x + HANDLE_TYPE], TYPE_FLOAT
stdlib.dasm16
767
2
20a8
7c81
20a9
19b6
        set y, float__to_str
stdlib.dasm16
768
2
20aa
9e70
20ab
0001
    ifb [x + HANDLE_TYPE], TYPE_TUPLE + TYPE_LIST
stdlib.dasm16
769
2
20ac
7c81
20ad
294c
        set y, list_repr
stdlib.dasm16
770
0

stdlib.dasm16
771
2
20ae
8a72
20af
0001
    ife [x + HANDLE_TYPE], TYPE_DICT
stdlib.dasm16
772
2
20b0
7c81
20b1
2fd1
        set y, dict_repr
stdlib.dasm16
773
0

stdlib.dasm16
774
1
20b2
0f01
    set push, x
stdlib.dasm16
775
1
20b3
1020
    jsr y
stdlib.dasm16
776
2
20b4
7f81
20b5
2026
    set pc, postamble
stdlib.dasm16
777
0

stdlib.dasm16
778
0
:repr_string
stdlib.dasm16
779
1
20b6
2c01
    set a, [x]
stdlib.dasm16
780
1
20b7
2001
    set a, [a]
stdlib.dasm16
781
1
20b8
8c02
    add a, 2
stdlib.dasm16
782
0

stdlib.dasm16
783
1
20b9
0301
    set push, a
stdlib.dasm16
784
1
20ba
a701
    set push, TYPE_STR
stdlib.dasm16
785
2
20bb
7c20
20bc
21d3
    jsr alloc
stdlib.dasm16
786
2
20bd
0ea1
20be
ffff
    set [z-1], x
stdlib.dasm16
787
0
    
stdlib.dasm16
788
2
20bf
5701
20c0
ffff
    set push, [z-1]
stdlib.dasm16
789
2
20c1
7f01
20c2
0027
    set push, 39
stdlib.dasm16
790
2
20c3
7c20
20c4
27d8
    jsr array__append
stdlib.dasm16
791
0
    
stdlib.dasm16
792
2
20c5
5701
20c6
ffff
    set push, [z-1]
stdlib.dasm16
793
2
20c7
5701
20c8
000a
    set push, [z+10]
stdlib.dasm16
794
2
20c9
7c20
20ca
283b
    jsr array_merge
stdlib.dasm16
795
2
20cb
0ea1
20cc
ffff
    set [z-1], x
stdlib.dasm16
796
0

stdlib.dasm16
797
2
20cd
5701
20ce
ffff
    set push, [z-1]
stdlib.dasm16
798
2
20cf
7f01
20d0
0027
    set push, 39
stdlib.dasm16
799
2
20d1
7c20
20d2
27d8
    jsr array__append
stdlib.dasm16
800
0

stdlib.dasm16
801
2
20d3
5461
20d4
ffff
    set x, [z-1]
stdlib.dasm16
802
2
20d5
7f81
20d6
2026
    set pc, postamble
stdlib.dasm16
803
0

stdlib.dasm16
804
0

stdlib.dasm16
805
0
:repr_boolean
stdlib.dasm16
806
1
20d7
0c01
    set a, x
stdlib.dasm16
807
0

stdlib.dasm16
808
2
20d8
7c61
20d9
03ee
    set x, STR_TRUE
stdlib.dasm16
809
2
20da
7c12
20db
02e7
    ife a, BOOL_FALSE
stdlib.dasm16
810
2
20dc
7c61
20dd
03f5
        set x, STR_FALSE
stdlib.dasm16
811
0

stdlib.dasm16
812
2
20de
7f81
20df
2026
    set pc, postamble
stdlib.dasm16
813
0

stdlib.dasm16
814
0
:repr_none
stdlib.dasm16
815
2
20e0
7c61
20e1
03e7
    set x, STR_NONE
stdlib.dasm16
816
2
20e2
7f81
20e3
2026
    set pc, postamble
stdlib.dasm16
817
0

stdlib.dasm16
818
0
;----------------------------------------------------------------
stdlib.dasm16
819
0
:detect_hardware
stdlib.dasm16
820
0
;----------------------------------------------------------------
stdlib.dasm16
821
1
20e4
1a00
    hwn i
stdlib.dasm16
822
0
:detect_hardware__loop
stdlib.dasm16
823
1
20e5
84d2
    ife i, 0
stdlib.dasm16
824
1
20e6
6381
       set pc, pop
stdlib.dasm16
825
1
20e7
88c3
    sub i, 1
stdlib.dasm16
826
1
20e8
1a20
    hwq i
stdlib.dasm16
827
2
20e9
7c12
20ea
f615
    ife a, 0xf615
stdlib.dasm16
828
2
20eb
7c32
20ec
7349
        ife b, 0x7349
stdlib.dasm16
829
2
20ed
1bc1
20ee
0250
            set [monitor], i
stdlib.dasm16
830
2
20ef
7c12
20f0
7406
    ife a, 0x7406
stdlib.dasm16
831
2
20f1
7c32
20f2
30cf
        ife b, 0x30cf
stdlib.dasm16
832
2
20f3
1bc1
20f4
024f
            set [keyboard], i
stdlib.dasm16
833
2
20f5
7c12
20f6
b402
    ife a, 0xb402
stdlib.dasm16
834
2
20f7
7c32
20f8
12d0
        ife b, 0x12d0
stdlib.dasm16
835
2
20f9
1bc1
20fa
0251
            set [clock], i
stdlib.dasm16
836
2
20fb
7c12
20fc
24c5
    ife a, 0x24c5
stdlib.dasm16
837
2
20fd
7c32
20fe
4fd5
        ife b, 0x4fd5
stdlib.dasm16
838
2
20ff
1bc1
2100
0252
            set [floppy], i
stdlib.dasm16
839
2
2101
7f81
2102
20e5
    set pc, detect_hardware__loop
stdlib.dasm16
840
0
          
stdlib.dasm16
841
0
;----------------------------------------------------------------
stdlib.dasm16
842
0
:win_getchar
stdlib.dasm16
843
0
; c: delayed key
stdlib.dasm16
844
0
; return
stdlib.dasm16
845
0
;   c: input character
stdlib.dasm16
846
0
;----------------------------------------------------------------
stdlib.dasm16
847
0
; after 0x10c cancellation this keyboard input subroutine was
stdlib.dasm16
848
0
; simplified to support only megastage DCPU
stdlib.dasm16
849
1
2103
8801
    set a, 1                      ; store next key mode
stdlib.dasm16
850
2
2104
7a40
2105
024f
    hwi [keyboard]
stdlib.dasm16
851
0

stdlib.dasm16
852
1
2106
8452
    ife c, 0
stdlib.dasm16
853
2
2107
7f81
2108
2103
        set pc, win_getchar
stdlib.dasm16
854
0

stdlib.dasm16
855
2
2109
7c52
210a
0091
    ife c, KEY_CTRL
stdlib.dasm16
856
2
210b
7f81
210c
2103
        set pc, win_getchar
stdlib.dasm16
857
0

stdlib.dasm16
858
2
210d
7c52
210e
0090
    ife c, KEY_SHIFT
stdlib.dasm16
859
2
210f
7f81
2110
2103
        set pc, win_getchar
stdlib.dasm16
860
0

stdlib.dasm16
861
1
2111
0b01
    set push, c
stdlib.dasm16
862
0

stdlib.dasm16
863
0
;    set a, 2
stdlib.dasm16
864
0
;    set b, KEY_SHIFT
stdlib.dasm16
865
0
;    hwi [keyboard]
stdlib.dasm16
866
0
;    shl c, 14
stdlib.dasm16
867
0
;    bor [sp], c
stdlib.dasm16
868
0

stdlib.dasm16
869
1
2112
8c01
    set a, 2
stdlib.dasm16
870
2
2113
7c21
2114
0091
    set b, KEY_CTRL
stdlib.dasm16
871
2
2115
7a40
2116
024f
    hwi [keyboard]
stdlib.dasm16
872
1
2117
c04f
    shl c, 15
stdlib.dasm16
873
1
2118
604b
    bor c, pop
stdlib.dasm16
874
0

stdlib.dasm16
875
1
2119
6381
    set pc, pop
stdlib.dasm16
876
0

stdlib.dasm16
877
0
;----------------------------------------------------------------
stdlib.dasm16
878
0
; struct handle *raw_input(struct handle *prompt)
stdlib.dasm16
879
0
;----------------------------------------------------------------
stdlib.dasm16
880
0
:raw_input
stdlib.dasm16
881
1
211a
8b01
    set push, 1
stdlib.dasm16
882
1
211b
8b01
    set push, 1
stdlib.dasm16
883
2
211c
7c20
211d
2039
    jsr preamble
stdlib.dasm16
884
0

stdlib.dasm16
885
2
211e
86b2
211f
000a
    ife [z+10], 0
stdlib.dasm16
886
2
2120
7f81
2121
212c
        set pc, raw_input_no_prompt
stdlib.dasm16
887
0

stdlib.dasm16
888
0
    ; print prompt
stdlib.dasm16
889
2
2122
5701
2123
000a
    set push, [z+10]
stdlib.dasm16
890
2
2124
7c20
2125
1dfc
    jsr eval
stdlib.dasm16
891
2
2126
0ea1
2127
ffff
    set [z-1], x
stdlib.dasm16
892
0
    
stdlib.dasm16
893
2
2128
5701
2129
ffff
    set push, [z-1]
stdlib.dasm16
894
2
212a
7c20
212b
2050
    jsr print
stdlib.dasm16
895
0
    
stdlib.dasm16
896
0
:raw_input_no_prompt
stdlib.dasm16
897
0
;    set y, [cursor]
stdlib.dasm16
898
2
212c
7881
212d
023a
    set y, [current_screen]
stdlib.dasm16
899
2
212e
5021
212f
0002
    set b, [y + SCREEN__CURSOR]
stdlib.dasm16
900
0

stdlib.dasm16
901
0
:next_char_loop
stdlib.dasm16
902
0
    ; start of input
stdlib.dasm16
903
2
2130
7c20
2131
2e21
    jsr screen_toggle_cursor
stdlib.dasm16
904
0
    
stdlib.dasm16
905
0
    ; Handle keyboard input  
stdlib.dasm16
906
0
:input_loop
stdlib.dasm16
907
1
2132
8801
    set a, 1                      ; store next key mode
stdlib.dasm16
908
2
2133
7a40
2134
024f
    hwi [keyboard]
stdlib.dasm16
909
1
2135
8452
    ife c, 0
stdlib.dasm16
910
2
2136
7f81
2137
2132
        set pc, input_loop        ; no input
stdlib.dasm16
911
2
2138
7c54
2139
007f
    ifg c, 0x7f
stdlib.dasm16
912
2
213a
7f81
213b
2132
        set pc, input_loop
stdlib.dasm16
913
0

stdlib.dasm16
914
2
213c
7c20
213d
2e21
    jsr screen_toggle_cursor
stdlib.dasm16
915
0
    
stdlib.dasm16
916
1
213e
c852
    ife c, KEY_NEWLINE
stdlib.dasm16
917
2
213f
7f81
2140
2153
        set pc, finish
stdlib.dasm16
918
0

stdlib.dasm16
919
1
2141
c452
    ife c, KEY_BS
stdlib.dasm16
920
2
2142
0692
2143
0002
        ife [y + SCREEN__CURSOR], b
stdlib.dasm16
921
2
2144
7f81
2145
2130
            set pc, next_char_loop
stdlib.dasm16
922
0

stdlib.dasm16
923
2
2146
5001
2147
0001
    set a, [y + SCREEN__END]
stdlib.dasm16
924
1
2148
8803
    sub a, 1
stdlib.dasm16
925
1
2149
c453
    ifn c, KEY_BS
stdlib.dasm16
926
1
214a
c853
        ifn c, KEY_NEWLINE
stdlib.dasm16
927
2
214b
0292
214c
0002
            ife [y + SCREEN__CURSOR], a
stdlib.dasm16
928
2
214d
7c23
214e
0020
                sub b, SCREEN_COLS
stdlib.dasm16
929
0

stdlib.dasm16
930
2
214f
7c20
2150
2ef4
    jsr screen_add_char
stdlib.dasm16
931
0

stdlib.dasm16
932
2
2151
7f81
2152
2130
    set pc, next_char_loop
stdlib.dasm16
933
0

stdlib.dasm16
934
0
:finish
stdlib.dasm16
935
2
2153
5001
2154
0002
    set a, [y + SCREEN__CURSOR]
stdlib.dasm16
936
1
2155
0403
    sub a, b
stdlib.dasm16
937
1
2156
8802
    add a, 1
stdlib.dasm16
938
0

stdlib.dasm16
939
1
2157
0301
    set push, a
stdlib.dasm16
940
1
2158
a701
    set push, TYPE_STR
stdlib.dasm16
941
2
2159
7c20
215a
2770
    jsr array_create
stdlib.dasm16
942
0

stdlib.dasm16
943
1
215b
2ce1
    set j, [x]                    ; struct string *
stdlib.dasm16
944
1
215c
3ce2
    add j, [j]                    ; string[last]
stdlib.dasm16
945
1
215d
ade1
    set [j], 10                    ; set newline
stdlib.dasm16
946
2
215e
50df
215f
0002
    std i, [y + SCREEN__CURSOR]     ; i = cursor -1
stdlib.dasm16
947
0

stdlib.dasm16
948
0
:finish_loop
stdlib.dasm16
949
1
2160
04d6
    ifl i, b
stdlib.dasm16
950
2
2161
7f81
2162
2026
        set pc, postamble
stdlib.dasm16
951
1
2163
39e1
    set [j], [i]
stdlib.dasm16
952
2
2164
7dea
2165
007f
    and [j], 0x007f
stdlib.dasm16
953
0
    
stdlib.dasm16
954
2
2166
7f9f
2167
2160
    std pc, finish_loop
stdlib.dasm16
955
0
    
stdlib.dasm16
956
0
;----------------------------------------------------------------
stdlib.dasm16
957
0
:built_in_matcher
stdlib.dasm16
958
0
; fastcall
stdlib.dasm16
959
0
;   a: str.ptr
stdlib.dasm16
960
0
;   b: str.len
stdlib.dasm16
961
0
;   x: list
stdlib.dasm16
962
0
; return
stdlib.dasm16
963
0
;   c: value
stdlib.dasm16
964
0
;----------------------------------------------------------------
stdlib.dasm16
965
1
2168
8803
    sub a, 1
stdlib.dasm16
966
1
2169
8822
    add b, 1
stdlib.dasm16
967
1
216a
8863
    sub x, 1
stdlib.dasm16
968
0

stdlib.dasm16
969
0
:built_in_matcher_list_loop
stdlib.dasm16
970
1
216b
0cfe
    sti j, x
stdlib.dasm16
971
0

stdlib.dasm16
972
0
    ; calculate return value pointer
stdlib.dasm16
973
1
216c
3c61
    set x, [j]
stdlib.dasm16
974
1
216d
1c62
    add x, j
stdlib.dasm16
975
0

stdlib.dasm16
976
1
216e
2c41
    set c, [x]
stdlib.dasm16
977
1
216f
89f2
    ife [j], 1      ; length
stdlib.dasm16
978
1
2170
6381
        set pc, pop
stdlib.dasm16
979
0

stdlib.dasm16
980
1
2171
05f3
    ifn [j], b      ; if length != search length -> continue
stdlib.dasm16
981
2
2172
7f81
2173
216b
        set pc, built_in_matcher_list_loop
stdlib.dasm16
982
0

stdlib.dasm16
983
1
2174
00de
    sti i, a
stdlib.dasm16
984
0

stdlib.dasm16
985
0
:built_in_matcher_cmp_loop
stdlib.dasm16
986
1
2175
39f2
    ife [j], [i]
stdlib.dasm16
987
1
2176
0cf6
        ifl j, x
stdlib.dasm16
988
2
2177
7f9e
2178
2175
            sti pc, built_in_matcher_cmp_loop
stdlib.dasm16
989
0

stdlib.dasm16
990
1
2179
0cf2
    ife j, x
stdlib.dasm16
991
1
217a
6381
        set pc, pop
stdlib.dasm16
992
0

stdlib.dasm16
993
2
217b
7f81
217c
216b
    set pc, built_in_matcher_list_loop
stdlib.dasm16
994
0

stdlib.dasm16
995
0
;----------------------------------------------------------------
stdlib.dasm16
996
0
:return_true
stdlib.dasm16
997
0
;----------------------------------------------------------------
stdlib.dasm16
998
2
217d
7c61
217e
02e9
    set x, BOOL_TRUE
stdlib.dasm16
999
2
217f
7f81
2180
2026
    set pc, postamble
stdlib.dasm16
1000
0

stdlib.dasm16
1001
0
;----------------------------------------------------------------
stdlib.dasm16
1002
0
:return_false
stdlib.dasm16
1003
0
;----------------------------------------------------------------
stdlib.dasm16
1004
2
2181
7c61
2182
02e7
    set x, BOOL_FALSE
stdlib.dasm16
1005
2
2183
7f81
2184
2026
    set pc, postamble
stdlib.dasm16
1006
0

memory.dasm16
0
0
;----------------------------------------------------------------
memory.dasm16
1
0
; void realloc(struct handle *handle, uint16 size)
memory.dasm16
2
0
; return pointer to allocated handle or zero if error
memory.dasm16
3
0
;----------------------------------------------------------------
memory.dasm16
4
0
:realloc
memory.dasm16
5
1
2185
8f01
    set push, 2
memory.dasm16
6
1
2186
8701
    set push, 0
memory.dasm16
7
2
2187
7c20
2188
2039
    jsr preamble
memory.dasm16
8
0

memory.dasm16
9
2
2189
5441
218a
000b
    set c, [z+11]                        ; struct handle *
memory.dasm16
10
2
218b
5401
218c
000a
    set a, [z+10]                        ; size
memory.dasm16
11
0

memory.dasm16
12
2
218d
0256
218e
0002
    ifl [c + HANDLE_SIZE], a
memory.dasm16
13
2
218f
7f81
2190
2195
        set pc, realloc__grow
memory.dasm16
14
0

memory.dasm16
15
0
    ; shrinking is easy
memory.dasm16
16
2
2191
0241
2192
0002
    set [c + HANDLE_SIZE], a    
memory.dasm16
17
2
2193
7f81
2194
2026
    set pc, postamble
memory.dasm16
18
0
        
memory.dasm16
19
0
:realloc__grow
memory.dasm16
20
2
2195
7861
2196
0255
    set x, [heap_handle_start]
memory.dasm16
21
2
2197
7863
2198
0254
    sub x, [heap_free_start]
memory.dasm16
22
0

memory.dasm16
23
1
2199
0076
    ifl x, a                            ; if available space < required space
memory.dasm16
24
2
219a
7c20
219b
2208
        jsr free_memory
memory.dasm16
25
0

memory.dasm16
26
0
    ; init allocated space
memory.dasm16
27
2
219c
78c1
219d
0254
    set i, [heap_free_start]            ; first word of allocated memory region
memory.dasm16
28
1
219e
1802
    add a, i                            ; first word after allocated memory
memory.dasm16
29
0

memory.dasm16
30
1
219f
28e1
    set j, [c + HANDLE_PTR]                ; first word of old region
memory.dasm16
31
1
21a0
1c21
    set b, j                            ; first word after the old region
memory.dasm16
32
2
21a1
4822
21a2
0002
    add b, [c + HANDLE_SIZE]
memory.dasm16
33
0

memory.dasm16
34
0
:realloc__copy_loop
memory.dasm16
35
1
21a3
04f2
    ife j, b
memory.dasm16
36
2
21a4
7f81
21a5
21a9
        set pc, realloc__zero_loop
memory.dasm16
37
0

memory.dasm16
38
1
21a6
3dc1
    set [i], [j]                        ; default init with zero
memory.dasm16
39
2
21a7
7f9e
21a8
21a3
    sti pc, realloc__copy_loop
memory.dasm16
40
0
    
memory.dasm16
41
0
:realloc__zero_loop
memory.dasm16
42
1
21a9
00d2
    ife i, a
memory.dasm16
43
2
21aa
7f81
21ab
21af
        set pc, realloc__remove_from_list
memory.dasm16
44
0

memory.dasm16
45
1
21ac
85c1
    set [i], 0                            ; default init with zero
memory.dasm16
46
2
21ad
7f9e
21ae
21a9
    sti pc, realloc__zero_loop
memory.dasm16
47
0

memory.dasm16
48
0
:realloc__remove_from_list
memory.dasm16
49
2
21af
0bd2
21b0
0257
    ife [heap_handle_tail], c
memory.dasm16
50
2
21b1
7f81
21b2
21c7
        set pc, realloc__set_handle_values
memory.dasm16
51
0
    
memory.dasm16
52
0
    ; remove handle from reserved list
memory.dasm16
53
2
21b3
7c21
21b4
0256
    set b, heap_handle_head
memory.dasm16
54
1
21b5
9023
    sub b, HANDLE_NEXT
memory.dasm16
55
0

memory.dasm16
56
0
:realloc__remove_from_list__loop
memory.dasm16
57
2
21b6
0a32
21b7
0003
    ife [b + HANDLE_NEXT], c
memory.dasm16
58
2
21b8
7f81
21b9
21be
        set pc, realloc__remove_from_list__break
memory.dasm16
59
0
        
memory.dasm16
60
2
21ba
4421
21bb
0003
    set b, [b + HANDLE_NEXT]
memory.dasm16
61
2
21bc
7f81
21bd
21b6
    set pc, realloc__remove_from_list__loop
memory.dasm16
62
0
    
memory.dasm16
63
0
:realloc__remove_from_list__break
memory.dasm16
64
3
21be
4a21
21bf
0003
21c0
0003
    set [b + HANDLE_NEXT], [c + HANDLE_NEXT]
memory.dasm16
65
0
    
memory.dasm16
66
0
    ; append new handle to tail reserved handles list
memory.dasm16
67
2
21c1
7821
21c2
0257
    set b, [heap_handle_tail]                    ; store pointer to last item in reserved handles list
memory.dasm16
68
2
21c3
0bc1
21c4
0257
    set [heap_handle_tail], c                    ; set reserved handles tail pointer to point in new handle
memory.dasm16
69
2
21c5
0a21
21c6
0003
    set [b + HANDLE_NEXT], c                    ; set previous tail's next to point to new handle
memory.dasm16
70
0

memory.dasm16
71
0
:realloc__set_handle_values
memory.dasm16
72
0
    ; initialize handle structure
memory.dasm16
73
2
21c7
7941
21c8
0254
    set [c + HANDLE_PTR], [heap_free_start]     ; pointer to allocated memory region
memory.dasm16
74
3
21c9
5641
21ca
000a
21cb
0002
    set [c + HANDLE_SIZE], [z+10]                ; size of allocated memory region
memory.dasm16
75
2
21cc
8641
21cd
0003
    set [c + HANDLE_NEXT], 0                    ; next handle in reserved handles list
memory.dasm16
76
0

memory.dasm16
77
2
21ce
03c1
21cf
0254
    set [heap_free_start], a                    ; update unallocated heap space pointer
memory.dasm16
78
0

memory.dasm16
79
1
21d0
0861
    set x, c                                    ; return pointer to new handle
memory.dasm16
80
2
21d1
7f81
21d2
2026
    set pc, postamble    
memory.dasm16
81
0

memory.dasm16
82
0
;----------------------------------------------------------------
memory.dasm16
83
0
; struct handle *alloc(uint16 size, uint16 type)
memory.dasm16
84
0
; return pointer to allocated handle or zero if error
memory.dasm16
85
0
;----------------------------------------------------------------
memory.dasm16
86
0
; [SP + 3] SIZE
memory.dasm16
87
0
; [SP + 2] TYPE
memory.dasm16
88
0
; [SP + 1] RTS
memory.dasm16
89
0
; [SP + 0] a
memory.dasm16
90
0
:alloc
memory.dasm16
91
1
21d3
0301
    set push, a
memory.dasm16
92
0

memory.dasm16
93
0
    ;------------------------------
memory.dasm16
94
0
    ; ENSURE FREE CAPACITY
memory.dasm16
95
0
    ;------------------------------
memory.dasm16
96
0
    ; calculate required heap space
memory.dasm16
97
2
21d4
6801
21d5
0003
    set a, [sp + 3]                        ; allocation size
memory.dasm16
98
1
21d6
9402
    add a, SIZEOF_HANDLE                ; + handle size = max space required
memory.dasm16
99
0

memory.dasm16
100
2
21d7
7861
21d8
0255
    set x, [heap_handle_start]            ; end of free heap space
memory.dasm16
101
2
21d9
7863
21da
0254
    sub x, [heap_free_start]            ; - start of free heap space = available heap space
memory.dasm16
102
0

memory.dasm16
103
1
21db
0076
    ifl x, a                            ; if available space < required space
memory.dasm16
104
2
21dc
7c20
21dd
2208
        jsr free_memory                    ; try to free more memory
memory.dasm16
105
0

memory.dasm16
106
0
    ; free handles periodically
memory.dasm16
107
2
21de
8bc3
21df
0253
    sub [heap_counter], 1
memory.dasm16
108
1
21e0
83b2
    ife ex, 0xffff
memory.dasm16
109
2
21e1
7c20
21e2
2237
        jsr mark
memory.dasm16
110
0

memory.dasm16
111
0
    ;------------------------------
memory.dasm16
112
0
    ; ALLOCATE HANDLE
memory.dasm16
113
0
    ;------------------------------
memory.dasm16
114
0
    ; try to get recycled handle
memory.dasm16
115
2
21e3
7861
21e4
0258
    set x, [heap_handle_free]
memory.dasm16
116
0

memory.dasm16
117
1
21e5
8472
    ife x, 0                            ; did we get free handle?
memory.dasm16
118
2
21e6
7f81
21e7
2202
        set pc, alloc__handle__new        ; no, reserve new
memory.dasm16
119
0

memory.dasm16
120
3
21e8
4fc1
21e9
0003
21ea
0258
    set [heap_handle_free], [x + HANDLE_NEXT]
memory.dasm16
121
0

memory.dasm16
122
0
:alloc__finish
memory.dasm16
123
0
    ;------------------------------
memory.dasm16
124
0
    ; FINALIZE ALLOCATION
memory.dasm16
125
0
    ;------------------------------
memory.dasm16
126
0
    ; initialize handle structure
memory.dasm16
127
2
21eb
7961
21ec
0254
    set [x + HANDLE_PTR], [heap_free_start]     ; pointer to allocated memory region
memory.dasm16
128
3
21ed
6a61
21ee
0003
21ef
0002
    set [x + HANDLE_SIZE], [sp + 3]                ; size of allocated memory region
memory.dasm16
129
3
21f0
6a61
21f1
0002
21f2
0001
    set [x + HANDLE_TYPE], [sp + 2]                ; type of data that is pointed by this handle
memory.dasm16
130
2
21f3
8661
21f4
0003
    set [x + HANDLE_NEXT], 0                    ; next handle in reserved handles list
memory.dasm16
131
0

memory.dasm16
132
3
21f5
6bc2
21f6
0003
21f7
0254
    add [heap_free_start], [sp + 3]                ; update unallocated heap space pointer
memory.dasm16
133
0

memory.dasm16
134
0
    ; append new handle to reserved handles list
memory.dasm16
135
2
21f8
7801
21f9
0257
    set a, [heap_handle_tail]                    ; store pointer to last item in reserved handles list
memory.dasm16
136
2
21fa
0fc1
21fb
0257
    set [heap_handle_tail], x                    ; set reserved handles tail pointer to point in new handle
memory.dasm16
137
2
21fc
0e01
21fd
0003
    set [a + HANDLE_NEXT], x                    ; set previous tail's next to point to new handle
memory.dasm16
138
0

memory.dasm16
139
1
21fe
6001
    set a, pop                                    ; restore a
memory.dasm16
140
0
    
memory.dasm16
141
1
21ff
6321
    set [sp], pop                                ; remove arguments from stack
memory.dasm16
142
1
2200
6321
    set [sp], pop
memory.dasm16
143
0

memory.dasm16
144
1
2201
6381
    set pc, pop
memory.dasm16
145
0

memory.dasm16
146
0
:alloc__handle__new
memory.dasm16
147
0
    ; reserve more space for handles
memory.dasm16
148
2
2202
97c3
2203
0255
    sub [heap_handle_start], SIZEOF_HANDLE
memory.dasm16
149
2
2204
7861
2205
0255
    set x, [heap_handle_start]
memory.dasm16
150
0

memory.dasm16
151
2
2206
7f81
2207
21eb
    set pc, alloc__finish
memory.dasm16
152
0

memory.dasm16
153
0
;----------------------------------------------------------------
memory.dasm16
154
0
:free_memory
memory.dasm16
155
0
; fastcall
memory.dasm16
156
0
;  a: required memory
memory.dasm16
157
0
;  x: available space
memory.dasm16
158
0
;----------------------------------------------------------------
memory.dasm16
159
2
2208
7c20
2209
2237
    jsr mark
memory.dasm16
160
2
220a
7c20
220b
2214
    jsr compact
memory.dasm16
161
0

memory.dasm16
162
0
    ; recalculate space in heap gap
memory.dasm16
163
2
220c
7861
220d
0255
    set x, [heap_handle_start]
memory.dasm16
164
2
220e
7863
220f
0254
    sub x, [heap_free_start]
memory.dasm16
165
0

memory.dasm16
166
1
2210
0076
    ifl x, a                        ; if available space < required space
memory.dasm16
167
2
2211
7c20
2212
00c6
        jsr recover
memory.dasm16
168
0

memory.dasm16
169
1
2213
6381
    set pc, pop
memory.dasm16
170
0
    
memory.dasm16
171
0
;----------------------------------------------------------------
memory.dasm16
172
0
; void compact()
memory.dasm16
173
0
;----------------------------------------------------------------
memory.dasm16
174
0
:compact
memory.dasm16
175
1
2214
8701
    set push, 0
memory.dasm16
176
1
2215
8701
    set push, 0
memory.dasm16
177
2
2216
7c20
2217
2039
    jsr preamble
memory.dasm16
178
0

memory.dasm16
179
2
2218
7cc1
2219
4000
    set i, MEM_HEAP_START
memory.dasm16
180
0

memory.dasm16
181
2
221a
7c01
221b
0253
    set a, heap_handle_head - HANDLE_NEXT            ; struct handle *
memory.dasm16
182
0
;    sub a, HANDLE_NEXT
memory.dasm16
183
0
    
memory.dasm16
184
0
:compact_loop
memory.dasm16
185
2
221c
4001
221d
0003
    set a, [a + HANDLE_NEXT]
memory.dasm16
186
1
221e
8412
    ife a, 0
memory.dasm16
187
2
221f
7f81
2220
2231
        set pc, compact_finish
memory.dasm16
188
0

memory.dasm16
189
1
2221
20e1
    set j, [a + HANDLE_PTR]        ; copy from
memory.dasm16
190
1
2222
18f6
    ifl j, i                    ; is it pointing to static data?
memory.dasm16
191
0
;        set pc, compact_loop
memory.dasm16
192
2
2223
7c20
2224
00c6
        jsr recover
memory.dasm16
193
0

memory.dasm16
194
1
2225
1821
    set b, i            ; calculate end pointer
memory.dasm16
195
2
2226
4022
2227
0002
    add b, [a + HANDLE_SIZE]
memory.dasm16
196
0

memory.dasm16
197
1
2228
1901
    set [a + HANDLE_PTR], i
memory.dasm16
198
0

memory.dasm16
199
1
2229
1cd2
    ife i, j            ; if src == dst
memory.dasm16
200
1
222a
04c1
        set i, b        ; skip copy
memory.dasm16
201
0

memory.dasm16
202
0
:compact_copy_loop
memory.dasm16
203
1
222b
04d2
    ife i, b
memory.dasm16
204
2
222c
7f81
222d
221c
        set pc, compact_loop
memory.dasm16
205
1
222e
3dde
    sti [i], [j]
memory.dasm16
206
2
222f
7f81
2230
222b
    set pc, compact_copy_loop
memory.dasm16
207
0

memory.dasm16
208
0
:compact_finish
memory.dasm16
209
2
2231
1bc1
2232
0254
    set [heap_free_start], i
memory.dasm16
210
2
2233
7c20
2234
228b
    jsr mem_clear
memory.dasm16
211
2
2235
7f81
2236
2026
    set pc, postamble
memory.dasm16
212
0

memory.dasm16
213
0
;----------------------------------------------------------------
memory.dasm16
214
0
; void free_handles()
memory.dasm16
215
0
;----------------------------------------------------------------
memory.dasm16
216
0
:mark
memory.dasm16
217
1
2237
8701
    set push, 0
memory.dasm16
218
1
2238
8701
    set push, 0
memory.dasm16
219
2
2239
7c20
223a
2039
    jsr preamble
memory.dasm16
220
0

memory.dasm16
221
0
    ; reset handle reservation counter
memory.dasm16
222
3
223b
7fc1
223c
0028
223d
0253
    set [heap_counter], HEAP_GC_TRIGGER
memory.dasm16
223
0

memory.dasm16
224
1
223e
1481
    set y, z                ; y: temp fp
memory.dasm16
225
0

memory.dasm16
226
0
:mark__process_frame
memory.dasm16
227
0
    ; i = y - number_of_references
memory.dasm16
228
1
223f
10c1
    set i, y 
memory.dasm16
229
2
2240
50c3
2241
0007
    sub i, [y + 7]
memory.dasm16
230
0

memory.dasm16
231
0
:mark__loop_references
memory.dasm16
232
1
2242
10d2
    ife i, y                            ; are all references processed?
memory.dasm16
233
2
2243
7f81
2244
224a
        set pc, mark__advance
memory.dasm16
234
0

memory.dasm16
235
1
2245
3b01
    set push, [i]
memory.dasm16
236
2
2246
7c20
2247
2274
    jsr mark_handle
memory.dasm16
237
0
    
memory.dasm16
238
2
2248
7f9e
2249
2242
    sti pc, mark__loop_references
memory.dasm16
239
0

memory.dasm16
240
0
:mark__advance
memory.dasm16
241
0
    ; set y to next frame pointer in call stack
memory.dasm16
242
1
224a
3081
    set y, [y]
memory.dasm16
243
0

memory.dasm16
244
0
    ; continue loop if more frames
memory.dasm16
245
1
224b
8493
    ifn y, 0
memory.dasm16
246
2
224c
7f81
224d
223f
        set pc, mark__process_frame
memory.dasm16
247
0

memory.dasm16
248
0
    ;---------------------------------------
memory.dasm16
249
0
    ; done marking,
memory.dasm16
250
0
    ; reconstruct reserved and free lists
memory.dasm16
251
0
    ;---------------------------------------
memory.dasm16
252
0
    ; use j to iterate over reserved handles list
memory.dasm16
253
2
224e
7cc1
224f
0253
    set i, heap_handle_head - HANDLE_NEXT    ; struct handle *
memory.dasm16
254
2
2250
78e1
2251
0256
    set j, [heap_handle_head]
memory.dasm16
255
0
    
memory.dasm16
256
0
:mark__free_loop
memory.dasm16
257
0
    ; this loop 
memory.dasm16
258
0
    ; 1) removes marked-flag from marked handles
memory.dasm16
259
0
    ; 2) inserts each handle to reserved or free list
memory.dasm16
260
0

memory.dasm16
261
0
; RED ZONE START
memory.dasm16
262
0

memory.dasm16
263
1
2252
84f2
    ife j, 0                        ; if end of list
memory.dasm16
264
2
2253
7f81
2254
226e
        set pc, mark__free_loop__break
memory.dasm16
265
0

memory.dasm16
266
3
2255
7ef1
2256
8000
2257
0001
    ifc [j + HANDLE_TYPE], TYPE_MARKED
memory.dasm16
267
2
2258
7f81
2259
2264
        set pc, mark__free_loop__unmarked
memory.dasm16
268
0

memory.dasm16
269
0
:mark__free_loop__marked
memory.dasm16
270
0
    ; clear marked flag
memory.dasm16
271
3
225a
7eec
225b
8000
225c
0001
    xor [j + HANDLE_TYPE], TYPE_MARKED
memory.dasm16
272
0

memory.dasm16
273
0
    ; set next pointer in previous reserved handle
memory.dasm16
274
2
225d
1ec1
225e
0003
    set [i + HANDLE_NEXT], j
memory.dasm16
275
0

memory.dasm16
276
0
    ; advance previous handle pointer
memory.dasm16
277
1
225f
1cc1
    set i, j
memory.dasm16
278
0

memory.dasm16
279
0
    ; advance handle pointer
memory.dasm16
280
2
2260
5ce1
2261
0003
    set j, [j + HANDLE_NEXT]
memory.dasm16
281
0

memory.dasm16
282
2
2262
7f81
2263
2252
    set pc, mark__free_loop
memory.dasm16
283
0

memory.dasm16
284
0
; RED ZONE END
memory.dasm16
285
0

memory.dasm16
286
0
:mark__free_loop__unmarked
memory.dasm16
287
0
    ; store pointer to next handle
memory.dasm16
288
2
2264
5c61
2265
0003
    set x, [j + HANDLE_NEXT]
memory.dasm16
289
0

memory.dasm16
290
0
    ; add item to free list
memory.dasm16
291
3
2266
7ae1
2267
0258
2268
0003
    set [j + HANDLE_NEXT], [heap_handle_free]    ; add to free list
memory.dasm16
292
2
2269
1fc1
226a
0258
    set [heap_handle_free], j
memory.dasm16
293
0

memory.dasm16
294
0
    ; set j to next handle in reserved list
memory.dasm16
295
1
226b
0ce1
    set j, x
memory.dasm16
296
0

memory.dasm16
297
2
226c
7f81
226d
2252
    set pc, mark__free_loop
memory.dasm16
298
0

memory.dasm16
299
0
:mark__free_loop__break
memory.dasm16
300
2
226e
86c1
226f
0003
    set [i + HANDLE_NEXT], 0
memory.dasm16
301
2
2270
1bc1
2271
0257
    set [heap_handle_tail], i
memory.dasm16
302
2
2272
7f81
2273
2026
    set pc, postamble
memory.dasm16
303
0

memory.dasm16
304
0
;----------------------------------------------------------------
memory.dasm16
305
0
; void free_handles__mark(struct handle *item)
memory.dasm16
306
0
; recursively sets the mark bit in item and contained items
memory.dasm16
307
0
;----------------------------------------------------------------
memory.dasm16
308
0
:mark_handle
memory.dasm16
309
0

memory.dasm16
310
0
; RED ZONE START
memory.dasm16
311
0

memory.dasm16
312
0
    ; this function uses standard call convention, but optimized implementation
memory.dasm16
313
2
2274
6861
2275
0001
    set x, [sp + 1]                        ; struct handle *item
memory.dasm16
314
0

memory.dasm16
315
0
    ; remove item from stack (preserve rts)
memory.dasm16
316
1
2276
6321
    set [sp], pop
memory.dasm16
317
0
    
memory.dasm16
318
0
    ;---------------------------------------
memory.dasm16
319
0
    ; return if handle is outside HEAP handles
memory.dasm16
320
0
    ;---------------------------------------
memory.dasm16
321
2
2277
7876
2278
0255
    ifl x, [heap_handle_start]
memory.dasm16
322
1
2279
6381
        set pc, pop
memory.dasm16
323
0

memory.dasm16
324
0
;   according to memory layout this is not needed
memory.dasm16
325
0
;    ifg x, MEM_HEAP_END - SIZEOF_HANDLE
memory.dasm16
326
0
;        set pc, pop
memory.dasm16
327
0
    ;---------------------------------------
memory.dasm16
328
0

memory.dasm16
329
3
227a
7e70
227b
8000
227c
0001
    ifb [x + HANDLE_TYPE], TYPE_MARKED    ; return if handle is already marked
memory.dasm16
330
1
227d
6381
        set pc, pop
memory.dasm16
331
0

memory.dasm16
332
3
227e
7e6b
227f
8000
2280
0001
    bor [x + HANDLE_TYPE], TYPE_MARKED    ; set mark on handle
memory.dasm16
333
0

memory.dasm16
334
0
    ; return if handle is not container
memory.dasm16
335
0
;    ifc [x + HANDLE_TYPE], TYPE_CONTROL + TYPE_REFERENCE + TYPE_SUBSCRIPTION + TYPE_TUPLE + TYPE_LIST + TYPE_DICT
memory.dasm16
336
3
2281
7e71
2282
2707
2283
0001
    ifc [x + HANDLE_TYPE], TYPE_GROUP_CONTAINER
memory.dasm16
337
1
2284
6381
        set pc, pop
memory.dasm16
338
0

memory.dasm16
339
0
; RED ZONE END
memory.dasm16
340
0

memory.dasm16
341
1
2285
0f01
    set push, x
memory.dasm16
342
2
2286
7f01
2287
2274
    set push, mark_handle        ; map() function for iterate
memory.dasm16
343
2
2288
7c20
2289
28e4
    jsr array_map
memory.dasm16
344
0

memory.dasm16
345
1
228a
6381
    set pc, pop
memory.dasm16
346
0

memory.dasm16
347
0
; mem_clear
memory.dasm16
348
0
; fill a memory area with a value.
memory.dasm16
349
0
;
memory.dasm16
350
0
; input I, [heap_handle_start]: address, end address
memory.dasm16
351
0
;
memory.dasm16
352
0
; clobbers A, B, C, Y
memory.dasm16
353
0
;
memory.dasm16
354
0
; 23 words / 16 + len*1.375 cycles
memory.dasm16
355
0
:mem_clear
memory.dasm16
356
0
    ; i heap free start
memory.dasm16
357
1
228b
084c
    xor c, c        ; fill char
memory.dasm16
358
2
228c
7c21
228d
2296
    set b, mem_clear__loop
memory.dasm16
359
1
228e
6c81
    set y, sp        ; store sp
memory.dasm16
360
0

memory.dasm16
361
2
228f
7b61
2290
0255
    set sp, [heap_handle_start]
memory.dasm16
362
1
2291
6c01
    set a, sp
memory.dasm16
363
1
2292
1803
    sub a, i        ; len
memory.dasm16
364
1
2293
a00a
    and a, 7
memory.dasm16
365
1
2294
a403
    sub a, 8
memory.dasm16
366
1
2295
0383
    sub pc, a
memory.dasm16
367
0
:mem_clear__loop
memory.dasm16
368
1
2296
0b01
    set push, c
memory.dasm16
369
1
2297
0b01
    set push, c
memory.dasm16
370
1
2298
0b01
    set push, c
memory.dasm16
371
1
2299
0b01
    set push, c
memory.dasm16
372
1
229a
0b01
    set push, c
memory.dasm16
373
1
229b
0b01
    set push, c
memory.dasm16
374
1
229c
0b01
    set push, c
memory.dasm16
375
1
229d
0b01
    set push, c
memory.dasm16
376
0

memory.dasm16
377
1
229e
1b74
    ifg sp, i
memory.dasm16
378
1
229f
0781
        set pc, b
memory.dasm16
379
0

memory.dasm16
380
1
22a0
1361
    set sp, y
memory.dasm16
381
1
22a1
6381
    set pc, pop
integer.dasm16
0
0
;----------------------------------------------------------------
integer.dasm16
1
0
; struct handle *int16_to_int(int16 value)
integer.dasm16
2
0
; convert 16 bit register value to admiral's integer
integer.dasm16
3
0
;----------------------------------------------------------------
integer.dasm16
4
0
;:int16_to_int
integer.dasm16
5
0
;    set push, 1
integer.dasm16
6
0
;    set push, 0
integer.dasm16
7
0
;    jsr preamble
integer.dasm16
8
0
;
integer.dasm16
9
0
;    set c, 1
integer.dasm16
10
0
;    set pc, uint16_to_int_alloc
integer.dasm16
11
0

integer.dasm16
12
0
;----------------------------------------------------------------
integer.dasm16
13
0
; struct handle *uint16_to_int(uint16 value)
integer.dasm16
14
0
; convert 16 bit register value to admiral's integer
integer.dasm16
15
0
;----------------------------------------------------------------
integer.dasm16
16
0
:uint16_to_int
integer.dasm16
17
2
22a2
cb56
22a3
0001
    ifl [sp+1], 0x11
integer.dasm16
18
2
22a4
7f81
22a5
22b5
        set pc, uint16_to_int__optimize
integer.dasm16
19
0

integer.dasm16
20
1
22a6
8b01
    set push, 1
integer.dasm16
21
0

integer.dasm16
22
0
    ; special case here. if msb is 1, we must not convert it to
integer.dasm16
23
0
    ; negative integer, but instead extend integer length to keep the
integer.dasm16
24
0
    ; value positive
integer.dasm16
25
3
22a7
7f50
22a8
8000
22a9
0002
    ifb [sp+2], 0x8000
integer.dasm16
26
1
22aa
8f21
        set [sp], 2
integer.dasm16
27
0

integer.dasm16
28
2
22ab
7f01
22ac
0020
    set push, TYPE_INT
integer.dasm16
29
2
22ad
7c20
22ae
2770
    jsr array_create
integer.dasm16
30
0

integer.dasm16
31
1
22af
2c01
    set a, [x]
integer.dasm16
32
1
22b0
2002
    add a, [a]
integer.dasm16
33
2
22b1
6901
22b2
0001
    set [a], [sp+1]    
integer.dasm16
34
0

integer.dasm16
35
1
22b3
6321
    set [sp], pop
integer.dasm16
36
1
22b4
6381
    set pc, pop
integer.dasm16
37
0

integer.dasm16
38
0
:uint16_to_int__optimize
integer.dasm16
39
2
22b5
6861
22b6
0001
    set x, [sp+1]
integer.dasm16
40
1
22b7
8c6f
    shl x, 2
integer.dasm16
41
2
22b8
7c62
22b9
02a3
    add x, INT_TABLE
integer.dasm16
42
1
22ba
6321
    set [sp], pop
integer.dasm16
43
1
22bb
6381
    set pc ,pop
integer.dasm16
44
0
;----------------------------------------------------------------
integer.dasm16
45
0
; struct handle *int_to_int16(struct handle *integer)
integer.dasm16
46
0
:int_to_int16
integer.dasm16
47
0
; fastcall with argument in stack
integer.dasm16
48
0
;  [sp+1]    struct handle integer *
integer.dasm16
49
0
; return
integer.dasm16
50
0
;  x: int16 value
integer.dasm16
51
0
;----------------------------------------------------------------
integer.dasm16
52
2
22bc
6861
22bd
0001
    set x, [sp+1]    ; struct handle *
integer.dasm16
53
1
22be
2c61
    set x, [x]        ; struct integer *
integer.dasm16
54
1
22bf
2c62
    add x, [x]        ; integer.lsw *
integer.dasm16
55
1
22c0
2c61
    set x, [x]        ; integer.lsw
integer.dasm16
56
0
    
integer.dasm16
57
1
22c1
6321
    set [sp], pop    ; move rts over arg
integer.dasm16
58
1
22c2
6381
    set pc, pop
integer.dasm16
59
0

integer.dasm16
60
0
;----------------------------------------------------------------
integer.dasm16
61
0
; extern struct handle *int_parse(struct handle *string)
integer.dasm16
62
0
;
integer.dasm16
63
0
; Parses the start of string str interpreting its content as an 
integer.dasm16
64
0
; integer.
integer.dasm16
65
0
; 
integer.dasm16
66
0
; Return pointer to int handle or 0 if error
integer.dasm16
67
0
;----------------------------------------------------------------
integer.dasm16
68
0
:int_parse
integer.dasm16
69
1
22c3
8b01
    set push, 1            ; sizeof(args)
integer.dasm16
70
1
22c4
8b01
    set push, 1            ; sizeof(refs)
integer.dasm16
71
2
22c5
7c20
22c6
2039
    jsr preamble
integer.dasm16
72
0

integer.dasm16
73
3
22c7
7ea1
22c8
02a3
22c9
ffff
    set [z-1], INT_0
integer.dasm16
74
0

integer.dasm16
75
2
22ca
5401
22cb
000a
    set a, [z+10]        ; struct handle *str
integer.dasm16
76
1
22cc
8421
    set b, 0            ; index
integer.dasm16
77
1
22cd
8481
    set y, FALSE        ; negative flag
integer.dasm16
78
0

integer.dasm16
79
2
22ce
7c20
22cf
277f
    jsr array__get
integer.dasm16
80
3
22d0
7e73
22d1
1c3b
22d2
0721
    ifn [x + lexer_table], lexer_char_minus
integer.dasm16
81
2
22d3
7f81
22d4
22d9
        set pc, int_parse_hex_check
integer.dasm16
82
0

integer.dasm16
83
1
22d5
8881
    set y, TRUE
integer.dasm16
84
1
22d6
8822
    add b, 1
integer.dasm16
85
2
22d7
7c20
22d8
277f
    jsr array__get
integer.dasm16
86
0
    
integer.dasm16
87
0
:int_parse_hex_check
integer.dasm16
88
2
22d9
7c73
22da
0030
    ifn x, '0'
integer.dasm16
89
2
22db
7f81
22dc
22e9
        set pc, int_parse_loop
integer.dasm16
90
0

integer.dasm16
91
1
22dd
8822
    add b, 1
integer.dasm16
92
2
22de
7c20
22df
277f
    jsr array__get
integer.dasm16
93
2
22e0
7c73
22e1
0078
    ifn x, 'x'
integer.dasm16
94
2
22e2
7f81
22e3
22e9
        set pc, int_parse_loop
integer.dasm16
95
0

integer.dasm16
96
1
22e4
8822
    add b, 1
integer.dasm16
97
2
22e5
7c20
22e6
277f
    jsr array__get
integer.dasm16
98
0

integer.dasm16
99
2
22e7
7f81
22e8
232a
    set pc, int_parse_hex_loop
integer.dasm16
100
0

integer.dasm16
101
0
:int_parse_loop
integer.dasm16
102
1
22e9
0c41
    set c, x
integer.dasm16
103
0

integer.dasm16
104
3
22ea
7e53
22eb
1ce3
22ec
0721
    ifn [c + lexer_table], lexer_char_digit
integer.dasm16
105
2
22ed
7f81
22ee
2308
        set pc, int_parse_finish
integer.dasm16
106
0

integer.dasm16
107
2
22ef
7f01
22f0
02cb
    set push, INT_10
integer.dasm16
108
2
22f1
5701
22f2
ffff
    set push, [z-1]
integer.dasm16
109
2
22f3
7c20
22f4
25c7
    jsr int_mul
integer.dasm16
110
2
22f5
0ea1
22f6
ffff
    set [z-1], x
integer.dasm16
111
0

integer.dasm16
112
2
22f7
7c43
22f8
0030
    sub c, '0'                        ; convert char to int
integer.dasm16
113
1
22f9
8c4f
    shl c, 2
integer.dasm16
114
2
22fa
7c42
22fb
02a3
    add c, INT_TABLE
integer.dasm16
115
0

integer.dasm16
116
2
22fc
5701
22fd
ffff
    set push, [z-1]
integer.dasm16
117
1
22fe
0b01
    set push, c
integer.dasm16
118
2
22ff
7c20
2300
254d
    jsr int_add    
integer.dasm16
119
2
2301
0ea1
2302
ffff
    set [z-1], x
integer.dasm16
120
0
    
integer.dasm16
121
1
2303
8822
    add b, 1
integer.dasm16
122
2
2304
7c20
2305
277f
    jsr array__get
integer.dasm16
123
2
2306
7f81
2307
22e9
    set pc, int_parse_loop    
integer.dasm16
124
0

integer.dasm16
125
0
:int_parse_finish
integer.dasm16
126
2
2308
5461
2309
ffff
    set x, [z-1]
integer.dasm16
127
1
230a
8492
    ife y, FALSE
integer.dasm16
128
2
230b
7f81
230c
2026
        set pc, postamble
integer.dasm16
129
0

integer.dasm16
130
2
230d
5701
230e
ffff
    set push, [z-1]
integer.dasm16
131
2
230f
7c20
2310
24c3
    jsr int_negate
integer.dasm16
132
0

integer.dasm16
133
2
2311
7f81
2312
2026
    set pc, postamble
integer.dasm16
134
0

integer.dasm16
135
0
;----------------------------------------------------------------
integer.dasm16
136
0
; extern struct handle *int_parse_hex(struct handle *string)
integer.dasm16
137
0
;----------------------------------------------------------------
integer.dasm16
138
0
:int_parse_hex
integer.dasm16
139
1
2313
8b01
    set push, 1            ; sizeof(args)
integer.dasm16
140
1
2314
8b01
    set push, 1            ; sizeof(refs)
integer.dasm16
141
2
2315
7c20
2316
2039
    jsr preamble
integer.dasm16
142
0

integer.dasm16
143
3
2317
7ea1
2318
02a3
2319
ffff
    set [z-1], INT_0
integer.dasm16
144
0

integer.dasm16
145
2
231a
5401
231b
000a
    set a, [z+10]        ; struct handle *str
integer.dasm16
146
1
231c
8421
    set b, 0            ; index
integer.dasm16
147
1
231d
8481
    set y, FALSE        ; negative flag
integer.dasm16
148
0

integer.dasm16
149
2
231e
7c20
231f
277f
    jsr array__get
integer.dasm16
150
3
2320
7e73
2321
1c3b
2322
0721
    ifn [x + lexer_table], lexer_char_minus
integer.dasm16
151
2
2323
7f81
2324
2327
        set pc, int_parse_hex_0x
integer.dasm16
152
0

integer.dasm16
153
1
2325
8881
    set y, TRUE
integer.dasm16
154
1
2326
8822
    add b, 1
integer.dasm16
155
0

integer.dasm16
156
0
:int_parse_hex_0x
integer.dasm16
157
1
2327
8c22
    add b, 2
integer.dasm16
158
2
2328
7c20
2329
277f
    jsr array__get
integer.dasm16
159
0

integer.dasm16
160
0
:int_parse_hex_loop
integer.dasm16
161
1
232a
0c41
    set c, x
integer.dasm16
162
0

integer.dasm16
163
2
232b
7c54
232c
002f
    ifg c, '0'-1
integer.dasm16
164
2
232d
7c56
232e
003a
        ifl c, '9'+1
integer.dasm16
165
2
232f
7f81
2330
233f
            set pc, int_parse_hex_loop_continue
integer.dasm16
166
0

integer.dasm16
167
2
2331
7c54
2332
0060
    ifg c, 'a'-1
integer.dasm16
168
2
2333
7c56
2334
0067
        ifl c, 'f'+1
integer.dasm16
169
2
2335
7f81
2336
233f
            set pc, int_parse_hex_loop_continue
integer.dasm16
170
0

integer.dasm16
171
2
2337
7c54
2338
0040
    ifg c, 'A'-1
integer.dasm16
172
2
2339
7c56
233a
0047
        ifl c, 'F'+1
integer.dasm16
173
2
233b
7f81
233c
233f
            set pc, int_parse_hex_loop_continue
integer.dasm16
174
0

integer.dasm16
175
2
233d
7f81
233e
2308
    set pc, int_parse_finish
integer.dasm16
176
0

integer.dasm16
177
0
:int_parse_hex_loop_continue
integer.dasm16
178
2
233f
7f01
2340
02e3
    set push, INT_16
integer.dasm16
179
2
2341
5701
2342
ffff
    set push, [z-1]
integer.dasm16
180
2
2343
7c20
2344
25c7
    jsr int_mul
integer.dasm16
181
2
2345
0ea1
2346
ffff
    set [z-1], x
integer.dasm16
182
0

integer.dasm16
183
1
2347
0861
    set x, c
integer.dasm16
184
2
2348
7c54
2349
002f
    ifg c, '0'-1
integer.dasm16
185
2
234a
7c56
234b
003a
        ifl c, '9'+1
integer.dasm16
186
2
234c
7c63
234d
0030
            sub x, '0'
integer.dasm16
187
0

integer.dasm16
188
2
234e
7c54
234f
0060
    ifg c, 'a'-1
integer.dasm16
189
2
2350
7c56
2351
0067
        ifl c, 'f'+1
integer.dasm16
190
2
2352
7c63
2353
0057
            sub x, 'a'-10
integer.dasm16
191
0

integer.dasm16
192
2
2354
7c54
2355
0040
    ifg c, 'A'-1
integer.dasm16
193
2
2356
7c56
2357
0047
        ifl c, 'F'+1
integer.dasm16
194
2
2358
7c63
2359
0037
            sub x, 'A'-10
integer.dasm16
195
0
    
integer.dasm16
196
1
235a
8c6f
    shl x, 2
integer.dasm16
197
2
235b
7c62
235c
02a3
    add x, INT_TABLE
integer.dasm16
198
0

integer.dasm16
199
2
235d
5701
235e
ffff
    set push, [z-1]
integer.dasm16
200
1
235f
0f01
    set push, x
integer.dasm16
201
2
2360
7c20
2361
254d
    jsr int_add    
integer.dasm16
202
2
2362
0ea1
2363
ffff
    set [z-1], x
integer.dasm16
203
0
    
integer.dasm16
204
1
2364
8822
    add b, 1
integer.dasm16
205
2
2365
7c20
2366
277f
    jsr array__get
integer.dasm16
206
2
2367
7f81
2368
232a
    set pc, int_parse_hex_loop    
integer.dasm16
207
0

integer.dasm16
208
0
:int_to_hex
integer.dasm16
209
1
2369
8b01
    set push, 1
integer.dasm16
210
1
236a
8b01
    set push, 1
integer.dasm16
211
2
236b
7c20
236c
2039
    jsr preamble
integer.dasm16
212
2
236d
7c81
236e
02e3
    set y, INT_16
integer.dasm16
213
2
236f
7f81
2370
2377
    set pc, int_to_str_start
integer.dasm16
214
0
;----------------------------------------------------------------
integer.dasm16
215
0
; extern struct handle *int_to_str(struct handle *integer)
integer.dasm16
216
0
; local variable space
integer.dasm16
217
0
;   [ -1] REF temp
integer.dasm16
218
0
;----------------------------------------------------------------
integer.dasm16
219
0
:int_to_str
integer.dasm16
220
1
2371
8b01
    set push, 1
integer.dasm16
221
1
2372
8b01
    set push, 1
integer.dasm16
222
2
2373
7c20
2374
2039
    jsr preamble
integer.dasm16
223
2
2375
7c81
2376
02cb
    set y, INT_10
integer.dasm16
224
0

integer.dasm16
225
0
:int_to_str_start
integer.dasm16
226
2
2377
5701
2378
000a
    set push, [z+10]
integer.dasm16
227
2
2379
7c20
237a
24ab
    jsr int_abs
integer.dasm16
228
2
237b
0ea1
237c
ffff
    set [z-1], x
integer.dasm16
229
0

integer.dasm16
230
0
    ; character count
integer.dasm16
231
1
237d
84c1
    set i, 0
integer.dasm16
232
0

integer.dasm16
233
0
:int_to_str_loop
integer.dasm16
234
2
237e
5701
237f
ffff
    set push, [z-1]
integer.dasm16
235
1
2380
1301
    set push, y
integer.dasm16
236
2
2381
7c20
2382
2639
    jsr int_division
integer.dasm16
237
2
2383
0ea1
2384
ffff
    set [z-1], x
integer.dasm16
238
0

integer.dasm16
239
1
2385
2c01
    set a, [x]    ; struct list *tuple
integer.dasm16
240
2
2386
4021
2387
0002
    set b, [a + INT_DIVISION_REMAINDER]    ; struct handle *remainder
integer.dasm16
241
1
2388
2421
    set b, [b]    ; struct int *remainder
integer.dasm16
242
1
2389
2422
    add b, [b]    ; remainder lsw *
integer.dasm16
243
1
238a
2421
    set b, [b]    ; remainder lsw
integer.dasm16
244
2
238b
4421
238c
0400
    set b, [b + HEX]
integer.dasm16
245
1
238d
071e
    sti push, b
integer.dasm16
246
0

integer.dasm16
247
3
238e
42a1
238f
0001
2390
ffff
    set [z-1], [a + INT_DIVISION_QUOTIENT]
integer.dasm16
248
0

integer.dasm16
249
2
2391
5701
2392
ffff
    set push, [z-1]
integer.dasm16
250
2
2393
7c20
2394
24df
    jsr int_sgn
integer.dasm16
251
0

integer.dasm16
252
1
2395
8473
    ifn x, 0
integer.dasm16
253
2
2396
7f81
2397
237e
        set pc, int_to_str_loop
integer.dasm16
254
0

integer.dasm16
255
2
2398
7c92
2399
02cb
    ife y, INT_10
integer.dasm16
256
2
239a
7f81
239b
23a0
        set pc, int_to_str_negative
integer.dasm16
257
0
        
integer.dasm16
258
2
239c
7f1e
239d
0078
    sti push, 'x'
integer.dasm16
259
2
239e
7f1e
239f
0030
    sti push, '0'
integer.dasm16
260
0

integer.dasm16
261
0
:int_to_str_negative
integer.dasm16
262
0
    ; add minus sign
integer.dasm16
263
2
23a0
5701
23a1
000a
    set push, [z+10]
integer.dasm16
264
2
23a2
7c20
23a3
24df
    jsr int_sgn
integer.dasm16
265
0

integer.dasm16
266
1
23a4
8073
    ifn x, -1
integer.dasm16
267
2
23a5
7f81
23a6
23a9
        set pc, allocate_chars
integer.dasm16
268
0

integer.dasm16
269
2
23a7
7f1e
23a8
002d
    sti push, '-'
integer.dasm16
270
0

integer.dasm16
271
0
:allocate_chars
integer.dasm16
272
1
23a9
1b01
    set push, i
integer.dasm16
273
1
23aa
a701
    set push, TYPE_STR
integer.dasm16
274
2
23ab
7c20
23ac
2770
    jsr array_create
integer.dasm16
275
2
23ad
0ea1
23ae
ffff
    set [z-1], x
integer.dasm16
276
0

integer.dasm16
277
1
23af
2c01
    set a, [x]
integer.dasm16
278
1
23b0
1802
    add a, i
integer.dasm16
279
0

integer.dasm16
280
1
23b1
2cfe
    sti j, [x]    ; struct string *
integer.dasm16
281
0

integer.dasm16
282
0
:itoa_reverse_string
integer.dasm16
283
1
23b2
61e1
    set [j], pop
integer.dasm16
284
0
    
integer.dasm16
285
1
23b3
00f6
    ifl j, a
integer.dasm16
286
2
23b4
7f9e
23b5
23b2
        sti pc, itoa_reverse_string
integer.dasm16
287
0

integer.dasm16
288
2
23b6
7f81
23b7
2026
    set pc, postamble
integer.dasm16
289
0

integer.dasm16
290
0
;----------------------------------------------------------------
integer.dasm16
291
0
; extern struct handle *int_random(struct handle *min, struct handle *max)
integer.dasm16
292
0
;----------------------------------------------------------------
integer.dasm16
293
0
:int_random
integer.dasm16
294
1
23b8
8f01
    set push, 2
integer.dasm16
295
1
23b9
8f01
    set push, 2
integer.dasm16
296
2
23ba
7c20
23bb
2039
    jsr preamble
integer.dasm16
297
0
    
integer.dasm16
298
2
23bc
5701
23bd
000a
    set push, [z+10]
integer.dasm16
299
2
23be
5701
23bf
000b
    set push, [z+11]
integer.dasm16
300
2
23c0
7c20
23c1
253b
    jsr int_sub
integer.dasm16
301
2
23c2
0ea1
23c3
ffff
    set [z-1], x
integer.dasm16
302
0

integer.dasm16
303
2
23c4
5401
23c5
ffff
    set a, [z-1]
integer.dasm16
304
1
23c6
2001
    set a, [a]
integer.dasm16
305
0
    
integer.dasm16
306
1
23c7
2301
    set push, [a]
integer.dasm16
307
2
23c8
7f01
23c9
0020
    set push, TYPE_INT
integer.dasm16
308
2
23ca
7c20
23cb
2770
    jsr array_create
integer.dasm16
309
2
23cc
0ea1
23cd
fffe
    set [z-2], x
integer.dasm16
310
0
    
integer.dasm16
311
1
23ce
2c01
    set a, [x]
integer.dasm16
312
1
23cf
8802
    add a, 1
integer.dasm16
313
0
    
integer.dasm16
314
1
23d0
2cc1
    set i, [x]
integer.dasm16
315
1
23d1
38c2
    add i, [i]
integer.dasm16
316
0
    
integer.dasm16
317
0
:int_random_loop
integer.dasm16
318
2
23d2
7c20
23d3
23ed
    jsr int_rnd_lfsr
integer.dasm16
319
0
;    jsr int_rnd_lcg
integer.dasm16
320
1
23d4
00d2
    ife i, a
integer.dasm16
321
2
23d5
7c6a
23d6
7fff
        and x, 0x7fff
integer.dasm16
322
1
23d7
0dc1
    set [i], x
integer.dasm16
323
1
23d8
00d4
    ifg i, a
integer.dasm16
324
2
23d9
7f9f
23da
23d2
        std pc, int_random_loop
integer.dasm16
325
0

integer.dasm16
326
2
23db
5701
23dc
fffe
    set push, [z-2]
integer.dasm16
327
2
23dd
5701
23de
ffff
    set push, [z-1]
integer.dasm16
328
2
23df
7c20
23e0
2639
    jsr int_division
integer.dasm16
329
0
    
integer.dasm16
330
1
23e1
2c61
    set x, [x]
integer.dasm16
331
3
23e2
4ea1
23e3
0002
23e4
ffff
    set [z-1], [x + INT_DIVISION_REMAINDER]
integer.dasm16
332
0

integer.dasm16
333
2
23e5
5701
23e6
000b
    set push, [z+11]
integer.dasm16
334
2
23e7
5701
23e8
ffff
    set push, [z-1]
integer.dasm16
335
2
23e9
7c20
23ea
254d
    jsr int_add
integer.dasm16
336
0

integer.dasm16
337
2
23eb
7f81
23ec
2026
    set pc, postamble
integer.dasm16
338
0

integer.dasm16
339
0
;----------------------------------------------------------------
integer.dasm16
340
0
; kirinyaga's "Linear feedback shift register" pseudo random number generator
integer.dasm16
341
0
; 
integer.dasm16
342
0
; output every number twice per period. 
integer.dasm16
343
0
; return the higher 16bits out of 17. 
integer.dasm16
344
0
; 
integer.dasm16
345
0
; out A: 0000-FFFF 
integer.dasm16
346
0
; 
integer.dasm16
347
0
; uses 0 word from stack 
integer.dasm16
348
0
; 13 words / 14 cycles 
integer.dasm16
349
0
;----------------------------------------------------------------
integer.dasm16
350
0
:int_rnd_lfsr ; return pseudo-random 0000-FFFF in x 
integer.dasm16
351
2
23ed
7861
23ee
024a
    set x, [rnd_lfsr_seed] 
integer.dasm16
352
1
23ef
886d
    shr x, 1 
integer.dasm16
353
2
23f0
786b
23f1
024b
    bor x, [rnd_lfsr_seed + 1] 
integer.dasm16
354
2
23f2
77c1
23f3
024b
    set [rnd_lfsr_seed + 1], ex 
integer.dasm16
355
1
23f4
87b3
    ifn ex, 0 
integer.dasm16
356
2
23f5
786c
23f6
024c
        xor x, [rnd_lfsr_poly] 
integer.dasm16
357
2
23f7
0fc1
23f8
024a
    set [rnd_lfsr_seed], x 
integer.dasm16
358
1
23f9
6381
    set pc, pop 
integer.dasm16
359
0

integer.dasm16
360
0
;----------------------------------------------------------------
integer.dasm16
361
0
; Entroper's Linear congruential generator
integer.dasm16
362
0
; Generates random words, using two words of state.
integer.dasm16
363
0
; Based on the algorithm described here:
integer.dasm16
364
0
; http://6502.org/source/integers/random/random.html 
integer.dasm16
365
0
; Sets x to a 16-bit PRN.
integer.dasm16
366
0
;----------------------------------------------------------------
integer.dasm16
367
0
;:int_rnd_lcg
integer.dasm16
368
0
;    ; 0x0019660D x seed + 1
integer.dasm16
369
0
;    set push, a
integer.dasm16
370
0
;    set a, [rnd_lcg_seed]
integer.dasm16
371
0
;    set x, [rnd_lcg_seed + 1]
integer.dasm16
372
0
;    mul x, 0x660D
integer.dasm16
373
0
;    mul a, 0x0019
integer.dasm16
374
0
;    mul [rnd_lcg_seed], 0x660D
integer.dasm16
375
0
;    adx x, a
integer.dasm16
376
0
;    add [rnd_lcg_seed], 1
integer.dasm16
377
0
;    add x, ex
integer.dasm16
378
0
;    set [rnd_lcg_seed + 1], x
integer.dasm16
379
0
;    set a, pop
integer.dasm16
380
0
;    set pc, pop
integer.dasm16
381
0

integer.dasm16
382
0
;----------------------------------------------------------------
integer.dasm16
383
0
; extern struct handle *int_bitwise_or(struct handle *i1, struct handle *i2)
integer.dasm16
384
0
;----------------------------------------------------------------
integer.dasm16
385
0
:int_bitwise_or
integer.dasm16
386
1
23fa
8f01
    set push, 2
integer.dasm16
387
1
23fb
8f01
    set push, 2
integer.dasm16
388
2
23fc
7c20
23fd
2039
    jsr preamble
integer.dasm16
389
0

integer.dasm16
390
2
23fe
7c81
23ff
23fa
    set y, int_bitwise_or
integer.dasm16
391
0

integer.dasm16
392
0
:int_bitwise
integer.dasm16
393
0
    ; figure out max length
integer.dasm16
394
2
2400
5401
2401
000b
    set a, [z+11]
integer.dasm16
395
1
2402
2001
    set a, [a]
integer.dasm16
396
2
2403
5421
2404
000a
    set b, [z+10]
integer.dasm16
397
1
2405
2421
    set b, [b]
integer.dasm16
398
0

integer.dasm16
399
1
2406
2041
    set c, [a]
integer.dasm16
400
1
2407
0934
    ifg [b], c
integer.dasm16
401
1
2408
2441
        set c, [b]
integer.dasm16
402
0

integer.dasm16
403
0
    ; extend both arguments to max length
integer.dasm16
404
2
2409
5701
240a
000a
    set push, [z+10]
integer.dasm16
405
1
240b
0b01
    set push, c
integer.dasm16
406
2
240c
7c20
240d
274d
    jsr int_extend
integer.dasm16
407
2
240e
0ea1
240f
fffe
    set [z-2], x
integer.dasm16
408
0

integer.dasm16
409
2
2410
5701
2411
000b
    set push, [z+11]
integer.dasm16
410
1
2412
0b01
    set push, c
integer.dasm16
411
2
2413
7c20
2414
274d
    jsr int_extend
integer.dasm16
412
2
2415
0ea1
2416
ffff
    set [z-1], x
integer.dasm16
413
0

integer.dasm16
414
0
    ; get pointers to extended values
integer.dasm16
415
1
2417
2c01
    set a, [x]
integer.dasm16
416
1
2418
00c1
    set i, a
integer.dasm16
417
1
2419
2002
    add a, [a]
integer.dasm16
418
0
    
integer.dasm16
419
2
241a
54e1
241b
fffe
    set j, [z-2]
integer.dasm16
420
1
241c
3cfe
    sti j, [j]
integer.dasm16
421
0

integer.dasm16
422
0
:int_bitwise_loop
integer.dasm16
423
2
241d
7c92
241e
23fa
    ife y, int_bitwise_or
integer.dasm16
424
1
241f
3dcb
        bor [i], [j]
integer.dasm16
425
2
2420
7c92
2421
242e
    ife y, int_bitwise_xor
integer.dasm16
426
1
2422
3dcc
        xor [i], [j]
integer.dasm16
427
2
2423
7c92
2424
2436
    ife y, int_bitwise_and
integer.dasm16
428
1
2425
3dca
        and [i], [j]
integer.dasm16
429
0

integer.dasm16
430
1
2426
00d6
    ifl i, a
integer.dasm16
431
2
2427
7f9e
2428
241d
        sti pc, int_bitwise_loop
integer.dasm16
432
0

integer.dasm16
433
1
2429
0f01
    set push, x
integer.dasm16
434
2
242a
7c20
242b
2716
    jsr int_normalize
integer.dasm16
435
0
    
integer.dasm16
436
2
242c
7f81
242d
2026
    set pc, postamble
integer.dasm16
437
0

integer.dasm16
438
0
;----------------------------------------------------------------
integer.dasm16
439
0
; extern struct handle *int_bitwise_xor(struct handle *i1, struct handle *i2)
integer.dasm16
440
0
;----------------------------------------------------------------
integer.dasm16
441
0
:int_bitwise_xor
integer.dasm16
442
1
242e
8f01
    set push, 2
integer.dasm16
443
1
242f
8f01
    set push, 2
integer.dasm16
444
2
2430
7c20
2431
2039
    jsr preamble
integer.dasm16
445
0

integer.dasm16
446
2
2432
7c81
2433
242e
    set y, int_bitwise_xor
integer.dasm16
447
2
2434
7f81
2435
2400
    set pc, int_bitwise
integer.dasm16
448
0

integer.dasm16
449
0
;----------------------------------------------------------------
integer.dasm16
450
0
; extern struct handle *int_bitwise_and(struct handle *i1, struct handle *i2)
integer.dasm16
451
0
;----------------------------------------------------------------
integer.dasm16
452
0
:int_bitwise_and
integer.dasm16
453
1
2436
8f01
    set push, 2
integer.dasm16
454
1
2437
8f01
    set push, 2
integer.dasm16
455
2
2438
7c20
2439
2039
    jsr preamble
integer.dasm16
456
0
    
integer.dasm16
457
2
243a
7c81
243b
2436
    set y, int_bitwise_and
integer.dasm16
458
2
243c
7f81
243d
2400
    set pc, int_bitwise
integer.dasm16
459
0

integer.dasm16
460
0
;----------------------------------------------------------------
integer.dasm16
461
0
; extern struct handle *int_lshift(struct handle *i1, struct handle *i2)
integer.dasm16
462
0
;----------------------------------------------------------------
integer.dasm16
463
0
:int_lshift
integer.dasm16
464
1
243e
8f01
    set push, 2
integer.dasm16
465
1
243f
8b01
    set push, 1
integer.dasm16
466
2
2440
7c20
2441
2039
    jsr preamble
integer.dasm16
467
0

integer.dasm16
468
2
2442
5701
2443
000a
    set push, [z+10]
integer.dasm16
469
2
2444
7c20
2445
22bc
    jsr int_to_int16
integer.dasm16
470
0

integer.dasm16
471
0
    ; number of words to add to tail
integer.dasm16
472
1
2446
0c01
    set a, x
integer.dasm16
473
1
2447
c406
    div a, 16
integer.dasm16
474
0

integer.dasm16
475
0
    ; number of bits to shift
integer.dasm16
476
1
2448
0c21
    set b, x
integer.dasm16
477
1
2449
c428
    mod b, 16
integer.dasm16
478
0
    
integer.dasm16
479
2
244a
5441
244b
000b
    set c, [z+11]    ; struct handle *int
integer.dasm16
480
1
244c
2841
    set c, [c]        ; struct int *base
integer.dasm16
481
0

integer.dasm16
482
1
244d
2841
    set c, [c]        ; orig size
integer.dasm16
483
1
244e
0042
    add c, a        ; new words
integer.dasm16
484
1
244f
8842
    add c, 1        ; one for shift overflow
integer.dasm16
485
0
    
integer.dasm16
486
2
2450
5701
2451
000b
    set push, [z+11]
integer.dasm16
487
1
2452
0b01
    set push, c
integer.dasm16
488
2
2453
7c20
2454
274d
    jsr int_extend
integer.dasm16
489
2
2455
0ea1
2456
ffff
    set [z-1], x
integer.dasm16
490
0

integer.dasm16
491
0
    ; x: struct handle *new
integer.dasm16
492
0
    ; c: size of new int
integer.dasm16
493
0
    ; a: number of words to shift
integer.dasm16
494
0
    ; b: number of bits to shift
integer.dasm16
495
1
2457
2cc1
    set i, [x]
integer.dasm16
496
1
2458
2ce1
    set j, [x]
integer.dasm16
497
1
2459
2c42
    add c, [x]
integer.dasm16
498
0
    
integer.dasm16
499
1
245a
00e2
    add j, a
integer.dasm16
500
1
245b
8ce2
    add j, 2
integer.dasm16
501
0
    
integer.dasm16
502
2
245c
06cf
245d
0001
    shl [i+1], b
integer.dasm16
503
0

integer.dasm16
504
0
:int_lshift_loop
integer.dasm16
505
1
245e
3c81
    set y, [j]
integer.dasm16
506
1
245f
85e1
    set [j], 0
integer.dasm16
507
2
2460
12c1
2461
0002
    set [i+2], y
integer.dasm16
508
0
    
integer.dasm16
509
2
2462
06cf
2463
0002
    shl [i+2], b
integer.dasm16
510
2
2464
76cb
2465
0001
    bor [i+1], ex
integer.dasm16
511
0
    
integer.dasm16
512
1
2466
08f6
    ifl j, c
integer.dasm16
513
2
2467
7f9e
2468
245e
        sti pc, int_lshift_loop
integer.dasm16
514
0

integer.dasm16
515
0
    ; the end
integer.dasm16
516
1
2469
0f01
    set push, x
integer.dasm16
517
2
246a
7c20
246b
2716
    jsr int_normalize    
integer.dasm16
518
0

integer.dasm16
519
2
246c
7f81
246d
2026
    set pc, postamble
integer.dasm16
520
0

integer.dasm16
521
0
:int_rshift_by_uint
integer.dasm16
522
1
246e
8f01
    set push, 2
integer.dasm16
523
1
246f
8b01
    set push, 1
integer.dasm16
524
2
2470
7c20
2471
2039
    jsr preamble
integer.dasm16
525
0

integer.dasm16
526
2
2472
5461
2473
000a
    set x, [z+10]
integer.dasm16
527
2
2474
7f81
2475
247e
    set pc, int_rshift_join
integer.dasm16
528
0

integer.dasm16
529
0
;----------------------------------------------------------------
integer.dasm16
530
0
; extern struct handle *int_rshift(struct handle *i1, struct handle *i2)
integer.dasm16
531
0
;----------------------------------------------------------------
integer.dasm16
532
0
:int_rshift
integer.dasm16
533
1
2476
8f01
    set push, 2
integer.dasm16
534
1
2477
8b01
    set push, 1
integer.dasm16
535
2
2478
7c20
2479
2039
    jsr preamble
integer.dasm16
536
0
    
integer.dasm16
537
2
247a
5701
247b
000a
    set push, [z+10]
integer.dasm16
538
2
247c
7c20
247d
22bc
    jsr int_to_int16
integer.dasm16
539
0

integer.dasm16
540
0
:int_rshift_join
integer.dasm16
541
0
    ; number of words to add to tail
integer.dasm16
542
1
247e
0c01
    set a, x
integer.dasm16
543
1
247f
c406
    div a, 16
integer.dasm16
544
0

integer.dasm16
545
0
    ; number of bits to shift
integer.dasm16
546
1
2480
0c21
    set b, x
integer.dasm16
547
1
2481
c428
    mod b, 16
integer.dasm16
548
0
    
integer.dasm16
549
2
2482
5441
2483
000b
    set c, [z+11]    ; struct handle *int
integer.dasm16
550
1
2484
2841
    set c, [c]        ; struct int *base
integer.dasm16
551
0

integer.dasm16
552
1
2485
2841
    set c, [c]        ; orig size
integer.dasm16
553
0

integer.dasm16
554
1
2486
0816
    ifl a, c
integer.dasm16
555
2
2487
7f81
2488
248d
        set pc, int_rshift_real
integer.dasm16
556
0

integer.dasm16
557
2
2489
7c61
248a
02a3
    set x, INT_0
integer.dasm16
558
2
248b
7f81
248c
2026
    set pc, postamble
integer.dasm16
559
0

integer.dasm16
560
0
:int_rshift_real
integer.dasm16
561
1
248d
0043
    sub c, a
integer.dasm16
562
0
    
integer.dasm16
563
2
248e
54c1
248f
000b
    set i, [z+11]
integer.dasm16
564
1
2490
38c1
    set i, [i]
integer.dasm16
565
1
2491
08c2
    add i, c        ; src[-1]
integer.dasm16
566
0

integer.dasm16
567
1
2492
0b01
    set push, c
integer.dasm16
568
2
2493
7f01
2494
0020
    set push, TYPE_INT
integer.dasm16
569
2
2495
7c20
2496
2770
    jsr array_create
integer.dasm16
570
1
2497
2c01
    set a, [x]
integer.dasm16
571
1
2498
8802
    add a, 1        ; dst[0]
integer.dasm16
572
0

integer.dasm16
573
1
2499
2c42
    add c, [x]        ; dst[-1]
integer.dasm16
574
1
249a
08e1
    set j, c        ; dst[-1]
integer.dasm16
575
0

integer.dasm16
576
0
:int_rshift_loop
integer.dasm16
577
1
249b
39e1
    set [j], [i]
integer.dasm16
578
1
249c
1c12
    ife a, j
integer.dasm16
579
1
249d
05ee
        asr [j], b
integer.dasm16
580
1
249e
1c13
    ifn a, j
integer.dasm16
581
1
249f
05ed
        shr [j], b
integer.dasm16
582
1
24a0
1c53
    ifn c, j
integer.dasm16
583
2
24a1
76eb
24a2
0001
        bor [j+1], ex
integer.dasm16
584
0

integer.dasm16
585
1
24a3
1c13
    ifn a, j
integer.dasm16
586
2
24a4
7f9f
24a5
249b
        std pc, int_rshift_loop    
integer.dasm16
587
0
    
integer.dasm16
588
1
24a6
0f01
    set push, x
integer.dasm16
589
2
24a7
7c20
24a8
2716
    jsr int_normalize    
integer.dasm16
590
2
24a9
7f81
24aa
2026
    set pc, postamble
integer.dasm16
591
0

integer.dasm16
592
0
;----------------------------------------------------------------
integer.dasm16
593
0
; extern struct handle *int_abs(struct handle *integer)
integer.dasm16
594
0
;----------------------------------------------------------------
integer.dasm16
595
0
:int_abs
integer.dasm16
596
1
24ab
8b01
    set push, 1
integer.dasm16
597
1
24ac
8701
    set push, 0
integer.dasm16
598
2
24ad
7c20
24ae
2039
    jsr preamble
integer.dasm16
599
0

integer.dasm16
600
2
24af
5461
24b0
000a
    set x, [z+10]
integer.dasm16
601
1
24b1
2c01
    set a, [x]
integer.dasm16
602
3
24b2
7e11
24b3
8000
24b4
0001
    ifc [a+1], 0x8000
integer.dasm16
603
2
24b5
7c20
24b6
2026
        jsr postamble
integer.dasm16
604
0

integer.dasm16
605
1
24b7
0f01
    set push, x
integer.dasm16
606
2
24b8
7c20
24b9
24c3
    jsr int_negate
integer.dasm16
607
0

integer.dasm16
608
2
24ba
7c20
24bb
2026
    jsr postamble
integer.dasm16
609
0

integer.dasm16
610
0
;----------------------------------------------------------------
integer.dasm16
611
0
; extern struct handle *int_complement(struct handle *integer)
integer.dasm16
612
0
; bitwise complement -1 <-> 0
integer.dasm16
613
0
;----------------------------------------------------------------
integer.dasm16
614
0
:int_complement
integer.dasm16
615
1
24bc
8b01
    set push, 1
integer.dasm16
616
1
24bd
8b01
    set push, 1
integer.dasm16
617
2
24be
7c20
24bf
2039
    jsr preamble
integer.dasm16
618
0

integer.dasm16
619
1
24c0
8421
    set b, 0
integer.dasm16
620
0

integer.dasm16
621
2
24c1
7f81
24c2
24c7
    set pc, int_negate_or_complement
integer.dasm16
622
0

integer.dasm16
623
0
;----------------------------------------------------------------
integer.dasm16
624
0
; extern struct handle *int_negate(struct handle *integer)
integer.dasm16
625
0
; arithmetic negative -1 <-> +1
integer.dasm16
626
0
;----------------------------------------------------------------
integer.dasm16
627
0
:int_negate
integer.dasm16
628
1
24c3
8b01
    set push, 1
integer.dasm16
629
1
24c4
8b01
    set push, 1
integer.dasm16
630
2
24c5
7c20
24c6
2039
    jsr preamble
integer.dasm16
631
0

integer.dasm16
632
0
:int_negate_or_complement
integer.dasm16
633
2
24c7
54c1
24c8
000a
    set i, [z+10]    ; struct handle *
integer.dasm16
634
1
24c9
38c1
    set i, [i]    ; struct int *
integer.dasm16
635
0

integer.dasm16
636
1
24ca
3b01
    set push, [i]    ; len
integer.dasm16
637
2
24cb
7f01
24cc
0020
    set push, TYPE_INT
integer.dasm16
638
2
24cd
7c20
24ce
2770
    jsr array_create
integer.dasm16
639
2
24cf
0ea1
24d0
ffff
    set [z-1], x
integer.dasm16
640
0
    
integer.dasm16
641
1
24d1
2c01
    set a, [x]    ; struct int *
integer.dasm16
642
0

integer.dasm16
643
1
24d2
38c2
    add i, [i]    ; i: orig lsw
integer.dasm16
644
0

integer.dasm16
645
1
24d3
00e1
    set j, a    ; j: new lsw
integer.dasm16
646
1
24d4
20e2
    add j, [a]
integer.dasm16
647
0

integer.dasm16
648
1
24d5
8821
    set b, 1
integer.dasm16
649
0
:xor_loop
integer.dasm16
650
1
24d6
39e1
    set [j], [i]
integer.dasm16
651
1
24d7
81ec
    xor [j], 0xffff
integer.dasm16
652
1
24d8
05e2
    add [j], b
integer.dasm16
653
1
24d9
743f
    std b, ex
integer.dasm16
654
1
24da
00f3
    ifn j, a
integer.dasm16
655
2
24db
7f81
24dc
24d6
        set pc, xor_loop
integer.dasm16
656
0

integer.dasm16
657
2
24dd
7c20
24de
2026
    jsr postamble
integer.dasm16
658
0

integer.dasm16
659
0
;----------------------------------------------------------------
integer.dasm16
660
0
; extern int16 int_sgn(struct handle *integer)
integer.dasm16
661
0
; 
integer.dasm16
662
0
; return 
integer.dasm16
663
0
;   -1 if integer < 0
integer.dasm16
664
0
;    0 if integer = 0
integer.dasm16
665
0
;   +1 if integer > 0
integer.dasm16
666
0
;----------------------------------------------------------------
integer.dasm16
667
0
:int_sgn
integer.dasm16
668
1
24df
8b01
    set push, 1
integer.dasm16
669
1
24e0
8701
    set push, 0
integer.dasm16
670
2
24e1
7c20
24e2
2039
    jsr preamble
integer.dasm16
671
0

integer.dasm16
672
2
24e3
5401
24e4
000a
    set a, [z+10]
integer.dasm16
673
1
24e5
2001
    set a, [a]
integer.dasm16
674
0

integer.dasm16
675
0
    ; sign comparison
integer.dasm16
676
3
24e6
7e10
24e7
8000
24e8
0001
    ifb [a + INT_DATA], 0x8000
integer.dasm16
677
1
24e9
8061
        set x, -1
integer.dasm16
678
0
            
integer.dasm16
679
3
24ea
7e11
24eb
8000
24ec
0001
    ifc [a + INT_DATA], 0x8000
integer.dasm16
680
1
24ed
8861
        set x, 1
integer.dasm16
681
0

integer.dasm16
682
1
24ee
8912
    ife [a + INT_LEN], 1
integer.dasm16
683
2
24ef
8612
24f0
0001
        ife [a + INT_DATA], 0
integer.dasm16
684
1
24f1
8461
            set x, 0
integer.dasm16
685
0

integer.dasm16
686
2
24f2
7c20
24f3
2026
    jsr postamble
integer.dasm16
687
0

integer.dasm16
688
0
;----------------------------------------------------------------
integer.dasm16
689
0
; extern int16 int_cmp(struct handle *left, struct handle *right)
integer.dasm16
690
0
; 
integer.dasm16
691
0
; return 
integer.dasm16
692
0
;   -1 if left < right
integer.dasm16
693
0
;    0 if left = right
integer.dasm16
694
0
;   +1 if left > right
integer.dasm16
695
0
;----------------------------------------------------------------
integer.dasm16
696
0
; [sp + 4] left
integer.dasm16
697
0
; [sp + 3] right
integer.dasm16
698
0
; [sp + 2] RTS
integer.dasm16
699
0
; [sp + 1] i
integer.dasm16
700
0
; [sp + 0] j
integer.dasm16
701
0
:int_cmp
integer.dasm16
702
1
24f4
1b01
    set push, i
integer.dasm16
703
1
24f5
1f01
    set push, j
integer.dasm16
704
0

integer.dasm16
705
2
24f6
68c1
24f7
0004
    set i, [sp + 4]
integer.dasm16
706
1
24f8
38c1
    set i, [i]        ; struct int *left
integer.dasm16
707
0

integer.dasm16
708
2
24f9
68e1
24fa
0003
    set j, [sp + 3]
integer.dasm16
709
1
24fb
3ce1
    set j, [j]        ; struct int *right
integer.dasm16
710
0

integer.dasm16
711
0
    ; sign comparison
integer.dasm16
712
3
24fc
7ed0
24fd
8000
24fe
0001
    ifb [i + INT_DATA], 0x8000
integer.dasm16
713
3
24ff
7ef1
2500
8000
2501
0001
        ifc [j + INT_DATA], 0x8000
integer.dasm16
714
2
2502
7f81
2503
2535
            set pc, int_cmp_lt
integer.dasm16
715
0
            
integer.dasm16
716
3
2504
7ed1
2505
8000
2506
0001
    ifc [i + INT_DATA], 0x8000
integer.dasm16
717
3
2507
7ef0
2508
8000
2509
0001
        ifb [j + INT_DATA], 0x8000
integer.dasm16
718
2
250a
7f81
250b
2538
            set pc, int_cmp_gt
integer.dasm16
719
0

integer.dasm16
720
0
    ; length comparison
integer.dasm16
721
0
    ; for negative numbers, long is less than short
integer.dasm16
722
3
250c
7ed0
250d
8000
250e
0001
    ifb [i + INT_DATA], 0x8000 ; if negative
integer.dasm16
723
1
250f
3dd4
        ifg [i], [j]
integer.dasm16
724
2
2510
7f81
2511
2535
            set pc, int_cmp_lt
integer.dasm16
725
0

integer.dasm16
726
3
2512
7ed0
2513
8000
2514
0001
    ifb [i + INT_DATA], 0x8000 ; if negative
integer.dasm16
727
1
2515
3dd6
        ifl [i], [j]
integer.dasm16
728
2
2516
7f81
2517
2538
            set pc, int_cmp_gt
integer.dasm16
729
0

integer.dasm16
730
0
    ; for positive numbers, long is greater than short
integer.dasm16
731
3
2518
7ed1
2519
8000
251a
0001
    ifc [i + INT_DATA], 0x8000 ; if positive
integer.dasm16
732
1
251b
3dd4
        ifg [i], [j]
integer.dasm16
733
2
251c
7f81
251d
2538
            set pc, int_cmp_gt
integer.dasm16
734
0

integer.dasm16
735
3
251e
7ed1
251f
8000
2520
0001
    ifc [i + INT_DATA], 0x8000 ; if positive
integer.dasm16
736
1
2521
3dd6
        ifl [i], [j]
integer.dasm16
737
2
2522
7f81
2523
2535
            set pc, int_cmp_lt
integer.dasm16
738
0

integer.dasm16
739
0
    ; compare each word
integer.dasm16
740
1
2524
187e
    sti x, i
integer.dasm16
741
1
2525
2c62
    add x, [x]
integer.dasm16
742
0

integer.dasm16
743
0
:int_cmp_loop            
integer.dasm16
744
1
2526
3dd4
    ifg [i], [j]
integer.dasm16
745
2
2527
7f81
2528
2538
        set pc, int_cmp_gt
integer.dasm16
746
1
2529
3dd6
    ifl [i], [j]
integer.dasm16
747
2
252a
7f81
252b
2535
        set pc, int_cmp_lt
integer.dasm16
748
1
252c
0cd3
    ifn i, x
integer.dasm16
749
2
252d
7f9e
252e
2526
        sti pc, int_cmp_loop
integer.dasm16
750
0

integer.dasm16
751
1
252f
0c63
    sub x, x
integer.dasm16
752
0

integer.dasm16
753
0
:int_cmp__finish
integer.dasm16
754
1
2530
60e1
    set j, pop
integer.dasm16
755
1
2531
60c1
    set i, pop
integer.dasm16
756
0

integer.dasm16
757
1
2532
6321
    set [sp], pop
integer.dasm16
758
1
2533
6321
    set [sp], pop
integer.dasm16
759
0

integer.dasm16
760
1
2534
6381
    set pc, pop
integer.dasm16
761
0

integer.dasm16
762
0
:int_cmp_lt
integer.dasm16
763
1
2535
8061
    set x, -1
integer.dasm16
764
2
2536
7f81
2537
2530
    set pc, int_cmp__finish
integer.dasm16
765
0
    
integer.dasm16
766
0
:int_cmp_gt
integer.dasm16
767
1
2538
8861
    set x, 1
integer.dasm16
768
2
2539
7f81
253a
2530
    set pc, int_cmp__finish
integer.dasm16
769
0

integer.dasm16
770
0
;----------------------------------------------------------------
integer.dasm16
771
0
; extern struct handle *int_sub(struct handle *minuend, struct handle *subtrahend)
integer.dasm16
772
0
;----------------------------------------------------------------
integer.dasm16
773
0
:int_sub
integer.dasm16
774
1
253b
8f01
    set push, 2
integer.dasm16
775
1
253c
8b01
    set push, 1
integer.dasm16
776
2
253d
7c20
253e
2039
    jsr preamble
integer.dasm16
777
0

integer.dasm16
778
2
253f
5701
2540
000a
    set push, [z+10]           ; negate subtrahend
integer.dasm16
779
2
2541
7c20
2542
24c3
    jsr int_negate
integer.dasm16
780
2
2543
0ea1
2544
ffff
    set [z-1], x
integer.dasm16
781
0

integer.dasm16
782
2
2545
5701
2546
000b
    set push, [z+11]
integer.dasm16
783
2
2547
5701
2548
ffff
    set push, [z-1]
integer.dasm16
784
2
2549
7c20
254a
254d
    jsr int_add
integer.dasm16
785
0

integer.dasm16
786
2
254b
7c20
254c
2026
    jsr postamble
integer.dasm16
787
0

integer.dasm16
788
0
;----------------------------------------------------------------
integer.dasm16
789
0
; extern struct handle *int_add(struct handle *term1, struct handle *term2)
integer.dasm16
790
0
;----------------------------------------------------------------
integer.dasm16
791
0
:int_add
integer.dasm16
792
1
254d
8f01
    set push, 2
integer.dasm16
793
1
254e
8b01
    set push, 1
integer.dasm16
794
2
254f
7c20
2550
2039
    jsr preamble
integer.dasm16
795
0

integer.dasm16
796
2
2551
5401
2552
000b
    set a, [z+11]    ; struct handle *term1
integer.dasm16
797
1
2553
2001
    set a, [a]        ; a: struct int *term1
integer.dasm16
798
0

integer.dasm16
799
1
2554
00c1
    set i, a        ; ptr to len
integer.dasm16
800
1
2555
20c2
    add i, [a]        ; i: ptr to lsw
integer.dasm16
801
0

integer.dasm16
802
2
2556
5421
2557
000a
    set b, [z+10]    ; struct handle *term2
integer.dasm16
803
1
2558
2421
    set b, [b]        ; b: struct int *term2
integer.dasm16
804
0

integer.dasm16
805
1
2559
04e1
    set j, b        ; ptr to len
integer.dasm16
806
1
255a
24e2
    add j, [b]        ; j: ptr to lsw
integer.dasm16
807
0

integer.dasm16
808
0
    ; lsw + lsw
integer.dasm16
809
1
255b
8841
    set c, 1        ; c: number of words in result
integer.dasm16
810
1
255c
3881
    set y, [i]        ; y: current sum
integer.dasm16
811
1
255d
3c82
    add y, [j]
integer.dasm16
812
1
255e
7461
    set x, ex
integer.dasm16
813
1
255f
1301
    set push, y
integer.dasm16
814
0

integer.dasm16
815
0
:int_add_loop
integer.dasm16
816
1
2560
0c9f
    std y, x        ; init sum with previous carry, and move indexes toward msw
integer.dasm16
817
0

integer.dasm16
818
0
    ; --------- term 1 ---------    
integer.dasm16
819
2
2561
4061
2562
0001
    set x, [a+1]    ; x: default value for term1 current word (no data)
integer.dasm16
820
1
2563
c06e
    asr x, 15        ; sign extension
integer.dasm16
821
0

integer.dasm16
822
1
2564
00d4
    ifg i, a        ; ...use real value if more words are available
integer.dasm16
823
1
2565
3861
        set x, [i]
integer.dasm16
824
0

integer.dasm16
825
1
2566
0c82
    add y, x        ; add term1 word to sum
integer.dasm16
826
0
    
integer.dasm16
827
0
    ; --------- term 2 ---------    
integer.dasm16
828
2
2567
4461
2568
0001
    set x, [b+1]    ; do the same for term2
integer.dasm16
829
1
2569
c06e
    asr x, 15
integer.dasm16
830
0
    
integer.dasm16
831
1
256a
04f4
    ifg j, b
integer.dasm16
832
1
256b
3c61
        set x, [j]
integer.dasm16
833
0
        
integer.dasm16
834
1
256c
0c82
    add y, x
integer.dasm16
835
1
256d
7461
    set x, ex
integer.dasm16
836
0

integer.dasm16
837
0
    ; ---------  ---------    
integer.dasm16
838
1
256e
1301
    set push, y        ; push current sum
integer.dasm16
839
1
256f
8842
    add c, 1        ; add word counter
integer.dasm16
840
0

integer.dasm16
841
1
2570
1816
    ifl a, i        ; continue if more words available in term1
integer.dasm16
842
2
2571
7f81
2572
2560
        set pc, int_add_loop
integer.dasm16
843
0

integer.dasm16
844
1
2573
1c36
    ifl b, j        ; continue if more words available in term2
integer.dasm16
845
2
2574
7f81
2575
2560
        set pc, int_add_loop
integer.dasm16
846
0
    ; ---------  ---------    
integer.dasm16
847
1
2576
0b01
    set push, c
integer.dasm16
848
2
2577
7f01
2578
0020
    set push, TYPE_INT
integer.dasm16
849
2
2579
7c20
257a
2770
    jsr array_create
integer.dasm16
850
2
257b
0ea1
257c
ffff
    set [z-1], x
integer.dasm16
851
0
    
integer.dasm16
852
1
257d
2cde
    sti i, [x]
integer.dasm16
853
1
257e
1842
    add c, i
integer.dasm16
854
0

integer.dasm16
855
0
:int_add_copy_loop
integer.dasm16
856
1
257f
61de
    sti [i], pop
integer.dasm16
857
1
2580
08d3
    ifn i, c
integer.dasm16
858
2
2581
7f81
2582
257f
        set pc, int_add_copy_loop
integer.dasm16
859
0

integer.dasm16
860
2
2583
5701
2584
ffff
    set push, [z-1]
integer.dasm16
861
2
2585
7c20
2586
2716
    jsr int_normalize
integer.dasm16
862
0

integer.dasm16
863
2
2587
7c20
2588
2026
    jsr postamble
integer.dasm16
864
0

integer.dasm16
865
0
;----------------------------------------------------------------
integer.dasm16
866
0
; extern struct handle *int_pow(struct handle *base, struct handle *exp)
integer.dasm16
867
0
;----------------------------------------------------------------
integer.dasm16
868
0
:int_pow
integer.dasm16
869
1
2589
8f01
    set push, 2                        ; number of function arguments (base and exp)
integer.dasm16
870
1
258a
8f01
    set push, 2                        ; number of heap handles
integer.dasm16
871
2
258b
7c20
258c
2039
    jsr preamble
integer.dasm16
872
0

integer.dasm16
873
2
258d
5701
258e
000a
    set push, [z+10]                ; sgn(exp)
integer.dasm16
874
2
258f
7c20
2590
24df
    jsr int_sgn
integer.dasm16
875
0
    
integer.dasm16
876
1
2591
8472
    ife x, 0                        ; exp = 0
integer.dasm16
877
2
2592
7f81
2593
25c3
        set pc, int_pow_1            ; return 1
integer.dasm16
878
1
2594
8072
    ife x, -1                        ; base < 0
integer.dasm16
879
2
2595
7f81
2596
25bf
        set pc, int_pow_0            ; return 0
integer.dasm16
880
0

integer.dasm16
881
2
2597
5701
2598
000a
    set push, [z+10]                ; exp to register (only support exp < 2**16)
integer.dasm16
882
2
2599
7c20
259a
22bc
    jsr int_to_int16
integer.dasm16
883
1
259b
0c41
    set c, x                        ; c = (uint16) exp
integer.dasm16
884
0

integer.dasm16
885
3
259c
56a1
259d
000b
259e
ffff
    set [z-1], [z+11]                 ; p
integer.dasm16
886
3
259f
7ea1
25a0
02a7
25a1
fffe
    set [z-2], INT_1        ; r
integer.dasm16
887
0
    
integer.dasm16
888
0
:int_pow_loop
integer.dasm16
889
1
25a2
8452
    ife c, 0
integer.dasm16
890
2
25a3
7f81
25a4
25bb
        set pc, int_pow_break
integer.dasm16
891
0

integer.dasm16
892
1
25a5
8851
    ifc c, 1
integer.dasm16
893
2
25a6
7f81
25a7
25b0
        set pc, int_pow_skip
integer.dasm16
894
0

integer.dasm16
895
0
    ; r = p * r
integer.dasm16
896
2
25a8
5701
25a9
fffe
    set push, [z-2]
integer.dasm16
897
2
25aa
5701
25ab
ffff
    set push, [z-1]
integer.dasm16
898
2
25ac
7c20
25ad
25c7
    jsr int_mul
integer.dasm16
899
2
25ae
0ea1
25af
fffe
    set [z-2], x
integer.dasm16
900
0
    
integer.dasm16
901
0
:int_pow_skip
integer.dasm16
902
0
    ; p = p * p
integer.dasm16
903
2
25b0
5701
25b1
ffff
    set push, [z-1]
integer.dasm16
904
2
25b2
5701
25b3
ffff
    set push, [z-1]
integer.dasm16
905
2
25b4
7c20
25b5
25c7
    jsr int_mul
integer.dasm16
906
2
25b6
0ea1
25b7
ffff
    set [z-1], x
integer.dasm16
907
0

integer.dasm16
908
0
    ; c = c / 2
integer.dasm16
909
1
25b8
8c46
    div c, 2
integer.dasm16
910
2
25b9
7f81
25ba
25a2
    set pc, int_pow_loop
integer.dasm16
911
0

integer.dasm16
912
0
:int_pow_break
integer.dasm16
913
0
    ; return r
integer.dasm16
914
2
25bb
5461
25bc
fffe
    set x, [z-2]
integer.dasm16
915
2
25bd
7f81
25be
2026
    set pc, postamble    
integer.dasm16
916
0

integer.dasm16
917
0
:int_pow_0
integer.dasm16
918
0
    ; return 0
integer.dasm16
919
2
25bf
7c61
25c0
02a3
    set x, INT_0
integer.dasm16
920
2
25c1
7f81
25c2
2026
    set pc, postamble
integer.dasm16
921
0
:int_pow_1
integer.dasm16
922
0
    ; return 1
integer.dasm16
923
2
25c3
7c61
25c4
02a7
    set x, INT_1
integer.dasm16
924
2
25c5
7f81
25c6
2026
    set pc, postamble
integer.dasm16
925
0

integer.dasm16
926
0
;----------------------------------------------------------------
integer.dasm16
927
0
; extern struct handle *int_mul(struct handle *factor1, struct handle *factor2)
integer.dasm16
928
0
;----------------------------------------------------------------
integer.dasm16
929
0
:int_mul
integer.dasm16
930
1
25c7
8f01
    set push, 2
integer.dasm16
931
1
25c8
9301
    set push, 3
integer.dasm16
932
2
25c9
7c20
25ca
2039
    jsr preamble
integer.dasm16
933
0

integer.dasm16
934
2
25cb
5701
25cc
000b
    set push, [z+11]    ; struct handle *factor1
integer.dasm16
935
2
25cd
7c20
25ce
24ab
    jsr int_abs
integer.dasm16
936
2
25cf
0ea1
25d0
ffff
    set [z-1], x        ; struct handle *f1
integer.dasm16
937
1
25d1
2c01
    set a, [x]            ; a: struct int *f1
integer.dasm16
938
0

integer.dasm16
939
1
25d2
00c1
    set i, a
integer.dasm16
940
1
25d3
20c2
    add i, [a]            ; i: lsw of f1
integer.dasm16
941
0
    
integer.dasm16
942
2
25d4
5701
25d5
000a
    set push, [z+10]    ; struct handle *factor2
integer.dasm16
943
2
25d6
7c20
25d7
24ab
    jsr int_abs
integer.dasm16
944
2
25d8
0ea1
25d9
fffe
    set [z-2], x        ; struct handle *f2
integer.dasm16
945
1
25da
2c21
    set b, [x]            ; b: struct int *f2
integer.dasm16
946
0

integer.dasm16
947
1
25db
04e1
    set j, b            ; j: lsw of f2
integer.dasm16
948
1
25dc
24e2
    add j, [b]
integer.dasm16
949
0
    
integer.dasm16
950
1
25dd
2041
    set c, [a]            ; max product size
integer.dasm16
951
1
25de
2442
    add c, [b]
integer.dasm16
952
0

integer.dasm16
953
1
25df
0b01
    set push, c
integer.dasm16
954
2
25e0
7f01
25e1
0020
    set push, TYPE_INT
integer.dasm16
955
2
25e2
7c20
25e3
2770
    jsr array_create
integer.dasm16
956
0

integer.dasm16
957
2
25e4
0ea1
25e5
fffd
    set [z-3], x
integer.dasm16
958
0
    
integer.dasm16
959
1
25e6
2c41
    set c, [x]
integer.dasm16
960
1
25e7
2842
    add c, [c]            ; c: product lsw
integer.dasm16
961
0

integer.dasm16
962
0
    ; a: struct int *factor1 
integer.dasm16
963
0
    ; b: struct int *factor2
integer.dasm16
964
0
    ; c: product current word *
integer.dasm16
965
0
    ; i: factor1 current word *
integer.dasm16
966
0
    ; j: factor2 current word *
integer.dasm16
967
0
    ; x: product word
integer.dasm16
968
0
:int_mul_words_loop
integer.dasm16
969
1
25e8
3c61
    set x, [j]
integer.dasm16
970
1
25e9
3864
    mul x, [i]
integer.dasm16
971
0

integer.dasm16
972
1
25ea
7481
    set y, ex        ; store product high
integer.dasm16
973
1
25eb
0d42
    add [c], x        ; add product low
integer.dasm16
974
2
25ec
125a
25ed
ffff
    adx [c-1], y    ; add product high
integer.dasm16
975
1
25ee
7461
    set x, ex
integer.dasm16
976
0

integer.dasm16
977
1
25ef
0881
    set y, c        ; y: product current word
integer.dasm16
978
1
25f0
8c83
    sub y, 2
integer.dasm16
979
0
:int_mul_carry_loop
integer.dasm16
980
1
25f1
8472
    ife x, 0
integer.dasm16
981
2
25f2
7f81
25f3
25f9
        set pc, int_mul_carry_break
integer.dasm16
982
1
25f4
0d82
    add [y], x
integer.dasm16
983
1
25f5
7461
    set x, ex    
integer.dasm16
984
1
25f6
8883
    sub y, 1
integer.dasm16
985
2
25f7
7f81
25f8
25f1
    set pc, int_mul_carry_loop
integer.dasm16
986
0

integer.dasm16
987
0
:int_mul_carry_break
integer.dasm16
988
1
25f9
88e3
    sub j, 1        ; move f2 cword towards msw
integer.dasm16
989
1
25fa
8843
    sub c, 1        ; move product cword towards msw
integer.dasm16
990
0

integer.dasm16
991
1
25fb
04f3
    ifn j, b        ; if f2 cword not out of bounds
integer.dasm16
992
2
25fc
7f81
25fd
25e8
        set pc, int_mul_words_loop
integer.dasm16
993
0

integer.dasm16
994
1
25fe
24e2
    add j, [b]        ; set f2 cword back to lsw
integer.dasm16
995
1
25ff
2442
    add c, [b]        ; move product cword back the same amount
integer.dasm16
996
0
    
integer.dasm16
997
1
2600
88c3
    sub i, 1        ; move f1 cwords towards msw
integer.dasm16
998
1
2601
8843
    sub c, 1        ; move product cword towards msw
integer.dasm16
999
0
    
integer.dasm16
1000
1
2602
00d3
    ifn i, a        ; if f1 cword not out of bounds
integer.dasm16
1001
2
2603
7f81
2604
25e8
        set pc, int_mul_words_loop
integer.dasm16
1002
0

integer.dasm16
1003
0
    ; all multiplications done here
integer.dasm16
1004
0

integer.dasm16
1005
2
2605
5701
2606
fffd
    set push, [z-3]
integer.dasm16
1006
2
2607
7c20
2608
2716
    jsr int_normalize
integer.dasm16
1007
2
2609
0ea1
260a
fffd
    set [z-3], x
integer.dasm16
1008
0

integer.dasm16
1009
2
260b
5701
260c
000a
    set push, [z+10]    ; factor 2 sign
integer.dasm16
1010
2
260d
7c20
260e
24df
    jsr int_sgn
integer.dasm16
1011
1
260f
0c01
    set a, x
integer.dasm16
1012
0
    
integer.dasm16
1013
2
2610
5701
2611
000b
    set push, [z+11]    ; factor 1 sign
integer.dasm16
1014
2
2612
7c20
2613
24df
    jsr int_sgn
integer.dasm16
1015
1
2614
0c0c
    xor a, x
integer.dasm16
1016
0

integer.dasm16
1017
2
2615
5461
2616
fffd
    set x, [z-3]
integer.dasm16
1018
2
2617
7c11
2618
8000
    ifc a, 0x8000
integer.dasm16
1019
2
2619
7c20
261a
2026
        jsr postamble
integer.dasm16
1020
0

integer.dasm16
1021
0
    ; negate product
integer.dasm16
1022
2
261b
5701
261c
fffd
    set push, [z-3]
integer.dasm16
1023
2
261d
7c20
261e
24c3
    jsr int_negate
integer.dasm16
1024
0
    
integer.dasm16
1025
2
261f
7c20
2620
2026
    jsr postamble
integer.dasm16
1026
0

integer.dasm16
1027
0
;----------------------------------------------------------------
integer.dasm16
1028
0
; extern struct handle *int_div(struct handle *divident, struct handle *divisor)
integer.dasm16
1029
0
;----------------------------------------------------------------
integer.dasm16
1030
0
:int_div
integer.dasm16
1031
0
    ; [SP + 2] divident
integer.dasm16
1032
0
    ; [SP + 1] divisor
integer.dasm16
1033
0
    ; [SP + 0] RTS
integer.dasm16
1034
0

integer.dasm16
1035
2
2621
6b01
2622
0002
    set push, [sp + 2]
integer.dasm16
1036
2
2623
6b01
2624
0002
    set push, [sp + 2]
integer.dasm16
1037
2
2625
7c20
2626
2639
    jsr int_division
integer.dasm16
1038
0

integer.dasm16
1039
1
2627
2c61
    set x, [x]
integer.dasm16
1040
2
2628
4c61
2629
0001
    set x, [x + INT_DIVISION_QUOTIENT]
integer.dasm16
1041
0
    
integer.dasm16
1042
1
262a
6321
    set [sp], pop
integer.dasm16
1043
1
262b
6321
    set [sp], pop
integer.dasm16
1044
1
262c
6381
    set pc, pop
integer.dasm16
1045
0

integer.dasm16
1046
0
;----------------------------------------------------------------
integer.dasm16
1047
0
; extern struct handle *int_mod(struct handle *divident, struct handle *divisor)
integer.dasm16
1048
0
;----------------------------------------------------------------
integer.dasm16
1049
0
:int_mod
integer.dasm16
1050
0
    ; [SP + 2] divident
integer.dasm16
1051
0
    ; [SP + 1] divisor
integer.dasm16
1052
0
    ; [SP + 0] RTS
integer.dasm16
1053
0

integer.dasm16
1054
2
262d
6b01
262e
0002
    set push, [sp + 2]
integer.dasm16
1055
2
262f
6b01
2630
0002
    set push, [sp + 2]
integer.dasm16
1056
2
2631
7c20
2632
2639
    jsr int_division
integer.dasm16
1057
0

integer.dasm16
1058
1
2633
2c61
    set x, [x]
integer.dasm16
1059
2
2634
4c61
2635
0002
    set x, [x + INT_DIVISION_REMAINDER]
integer.dasm16
1060
0

integer.dasm16
1061
1
2636
6321
    set [sp], pop
integer.dasm16
1062
1
2637
6321
    set [sp], pop
integer.dasm16
1063
1
2638
6381
    set pc, pop
integer.dasm16
1064
0
    
integer.dasm16
1065
0
;----------------------------------------------------------------
integer.dasm16
1066
0
; struct handle *int_division(struct handle *divident, struct handle *divisor)
integer.dasm16
1067
0
; return x: (struct handle *quotient, struct handle *remainder)
integer.dasm16
1068
0
;  three different algorithms (16-bit/16-bit, n-bit/8-bit, n-bit/n-bit)
integer.dasm16
1069
0
;  are used to optimize calculation speed
integer.dasm16
1070
0
; [z-1] quotient
integer.dasm16
1071
0
; [z-2] divisor
integer.dasm16
1072
0
; [z-3] remainder
integer.dasm16
1073
0
;----------------------------------------------------------------
integer.dasm16
1074
0
:int_division
integer.dasm16
1075
1
2639
8f01
    set push, 2
integer.dasm16
1076
1
263a
9301
    set push, 3
integer.dasm16
1077
2
263b
7c20
263c
2039
    jsr preamble
integer.dasm16
1078
0

integer.dasm16
1079
0
    ; quotient = abs(divident)
integer.dasm16
1080
2
263d
5701
263e
000b
    set push, [z+11]
integer.dasm16
1081
2
263f
7c20
2640
24ab
    jsr int_abs
integer.dasm16
1082
2
2641
0ea1
2642
ffff
    set [z-1], x
integer.dasm16
1083
1
2643
2c01
    set a, [x]
integer.dasm16
1084
0

integer.dasm16
1085
0
    ; divisor = abs(divisor)
integer.dasm16
1086
2
2644
5701
2645
000a
    set push, [z+10]
integer.dasm16
1087
2
2646
7c20
2647
24ab
    jsr int_abs
integer.dasm16
1088
2
2648
0ea1
2649
fffe
    set [z-2], x
integer.dasm16
1089
1
264a
2c21
    set b, [x]
integer.dasm16
1090
0

integer.dasm16
1091
0
    ; max len
integer.dasm16
1092
1
264b
2041
    set c, [a]
integer.dasm16
1093
1
264c
2134
    ifg [b], [a]
integer.dasm16
1094
1
264d
2441
        set c, [b]
integer.dasm16
1095
0

integer.dasm16
1096
2
264e
5701
264f
ffff
    set push, [z-1]
integer.dasm16
1097
1
2650
0b01
    set push, c
integer.dasm16
1098
2
2651
7c20
2652
274d
    jsr int_extend
integer.dasm16
1099
2
2653
0ea1
2654
ffff
    set [z-1], x    ; quotient
integer.dasm16
1100
1
2655
2c01
    set a, [x]
integer.dasm16
1101
0

integer.dasm16
1102
2
2656
5701
2657
fffe
    set push, [z-2]
integer.dasm16
1103
1
2658
0b01
    set push, c
integer.dasm16
1104
2
2659
7c20
265a
274d
    jsr int_extend
integer.dasm16
1105
2
265b
0ea1
265c
fffe
    set [z-2], x    ; divisor
integer.dasm16
1106
1
265d
2c21
    set b, [x]
integer.dasm16
1107
0

integer.dasm16
1108
1
265e
0b01
    set push, c
integer.dasm16
1109
2
265f
7f01
2660
0020
    set push, TYPE_INT
integer.dasm16
1110
2
2661
7c20
2662
2770
    jsr array_create
integer.dasm16
1111
2
2663
0ea1
2664
fffd
    set [z-3], x    ; remainder
integer.dasm16
1112
1
2665
2c41
    set c, [x]
integer.dasm16
1113
0

integer.dasm16
1114
1
2666
8912
    ife [a], 1
integer.dasm16
1115
1
2667
8932
        ife [b], 1
integer.dasm16
1116
2
2668
7f81
2669
26a6
            set pc, division_16
integer.dasm16
1117
0

integer.dasm16
1118
1
266a
8932
    ife [b], 1
integer.dasm16
1119
3
266b
7e31
266c
ff00
266d
0001
        ifc [b+1], 0xff00
integer.dasm16
1120
2
266e
7f81
266f
26b1
            set pc, division__nbit_8bit
integer.dasm16
1121
0

integer.dasm16
1122
0
    ; here starts long division
integer.dasm16
1123
1
2670
2081
    set y, [a]    ; y: bits left
integer.dasm16
1124
1
2671
948f
    shl y, 4    ; words * 16 = bits
integer.dasm16
1125
0

integer.dasm16
1126
0
:division_loop
integer.dasm16
1127
1
2672
8492
    ife y, 0
integer.dasm16
1128
2
2673
7f81
2674
26d8
        set pc, division_finish
integer.dasm16
1129
1
2675
8883
    sub y, 1
integer.dasm16
1130
0

integer.dasm16
1131
0
    ; remainder << 1
integer.dasm16
1132
1
2676
08c1
    set i, c
integer.dasm16
1133
0

integer.dasm16
1134
1
2677
0861
    set x, c    ; x: remainder end
integer.dasm16
1135
1
2678
2862
    add x, [c]
integer.dasm16
1136
0

integer.dasm16
1137
0
:remainder_shift_loop
integer.dasm16
1138
2
2679
8acf
267a
0001
    shl [i+1], 1
integer.dasm16
1139
1
267b
08d3
    ifn i, c
integer.dasm16
1140
1
267c
75cb
        bor [i], ex
integer.dasm16
1141
0

integer.dasm16
1142
1
267d
88c2
    add i, 1
integer.dasm16
1143
1
267e
0cd3
    ifn i, x
integer.dasm16
1144
2
267f
7f81
2680
2679
        set pc, remainder_shift_loop
integer.dasm16
1145
0

integer.dasm16
1146
0
    ; quotient << 1 (roll carry to remainder lsb)
integer.dasm16
1147
1
2681
00c1
    set i, a
integer.dasm16
1148
0

integer.dasm16
1149
1
2682
00e1
    set j, a    ; j: quotient_divident end
integer.dasm16
1150
1
2683
20e2
    add j, [a]
integer.dasm16
1151
0

integer.dasm16
1152
0
:quotient_shift_loop
integer.dasm16
1153
2
2684
8acf
2685
0001
    shl [i+1], 1
integer.dasm16
1154
1
2686
00d2
    ife i, a
integer.dasm16
1155
1
2687
756b
        bor [x], ex
integer.dasm16
1156
1
2688
00d3
    ifn i, a
integer.dasm16
1157
1
2689
75cb
        bor [i], ex
integer.dasm16
1158
0

integer.dasm16
1159
1
268a
88c2
    add i, 1
integer.dasm16
1160
1
268b
1cd3
    ifn i, j
integer.dasm16
1161
2
268c
7f81
268d
2684
        set pc, quotient_shift_loop
integer.dasm16
1162
0

integer.dasm16
1163
0
    ; if remainder < divisor: loop
integer.dasm16
1164
1
268e
08c1
    set i, c
integer.dasm16
1165
1
268f
04e1
    set j, b
integer.dasm16
1166
0

integer.dasm16
1167
0
:division_cmp_loop
integer.dasm16
1168
1
2690
0c7e
    sti x, x
integer.dasm16
1169
1
2691
3dd6
    ifl [i], [j]
integer.dasm16
1170
2
2692
7f81
2693
2672
        set pc, division_loop
integer.dasm16
1171
0

integer.dasm16
1172
1
2694
3dd2
    ife [i], [j]
integer.dasm16
1173
1
2695
0cd3
        ifn i, x
integer.dasm16
1174
2
2696
7f81
2697
2690
            set pc, division_cmp_loop
integer.dasm16
1175
0

integer.dasm16
1176
0
    ; remainder -= divisor    
integer.dasm16
1177
1
2698
08c1
    set i, c
integer.dasm16
1178
1
2699
28c2
    add i, [c]
integer.dasm16
1179
0

integer.dasm16
1180
1
269a
04e1
    set j, b
integer.dasm16
1181
1
269b
24e2
    add j, [b]
integer.dasm16
1182
0

integer.dasm16
1183
0
:division_subtract_loop
integer.dasm16
1184
1
269c
3ddb
    sbx [i], [j]
integer.dasm16
1185
1
269d
0c7f
    std x, x
integer.dasm16
1186
1
269e
08d3
    ifn i, c
integer.dasm16
1187
2
269f
7f81
26a0
269c
        set pc, division_subtract_loop
integer.dasm16
1188
0

integer.dasm16
1189
0
    ; set quotient lsb=1
integer.dasm16
1190
1
26a1
0061
    set x, a
integer.dasm16
1191
1
26a2
2062
    add x, [a]
integer.dasm16
1192
1
26a3
896b
    bor [x], 1
integer.dasm16
1193
2
26a4
7f81
26a5
2672
    set pc, division_loop
integer.dasm16
1194
0

integer.dasm16
1195
0
:division_16
integer.dasm16
1196
3
26a6
4241
26a7
0001
26a8
0001
    set [c+1], [a+1]
integer.dasm16
1197
3
26a9
4606
26aa
0001
26ab
0001
    div [a+1], [b+1]
integer.dasm16
1198
3
26ac
4648
26ad
0001
26ae
0001
    mod [c+1], [b+1]
integer.dasm16
1199
2
26af
7f81
26b0
26e4
    set pc, division_finish_signs
integer.dasm16
1200
0

integer.dasm16
1201
0
:division__nbit_8bit
integer.dasm16
1202
0
    ; divident / quotient
integer.dasm16
1203
2
26b1
54c1
26b2
ffff
    set i, [z-1]
integer.dasm16
1204
1
26b3
38c1
    set i, [i]
integer.dasm16
1205
1
26b4
1861
    set x, i
integer.dasm16
1206
1
26b5
2c62
    add x, [x]        ; x: quotient[-1] *
integer.dasm16
1207
1
26b6
88c2
    add i, 1        ; j: quotient *
integer.dasm16
1208
0

integer.dasm16
1209
0
    ; divisor
integer.dasm16
1210
2
26b7
5481
26b8
fffe
    set y, [z - 2]
integer.dasm16
1211
1
26b9
3081
    set y, [y]
integer.dasm16
1212
2
26ba
5081
26bb
0001
    set y, [y + 1]    ; y: divisor value (8bit)
integer.dasm16
1213
0

integer.dasm16
1214
1
26bc
8421
    set b, 0
integer.dasm16
1215
0

integer.dasm16
1216
0
:division__nbit_8bit__loop
integer.dasm16
1217
1
26bd
a42f
    shl b, 8
integer.dasm16
1218
0

integer.dasm16
1219
1
26be
3801
    set a, [i]
integer.dasm16
1220
1
26bf
a40d
    shr a, 8
integer.dasm16
1221
0

integer.dasm16
1222
1
26c0
040b
    bor a, b
integer.dasm16
1223
1
26c1
0021
    set b, a
integer.dasm16
1224
0

integer.dasm16
1225
1
26c2
1006
    div a, y
integer.dasm16
1226
1
26c3
1028
    mod b, y
integer.dasm16
1227
0

integer.dasm16
1228
1
26c4
a40f
    shl a, 8
integer.dasm16
1229
1
26c5
0041
    set c, a
integer.dasm16
1230
0

integer.dasm16
1231
1
26c6
a42f
    shl b, 8
integer.dasm16
1232
0
    
integer.dasm16
1233
1
26c7
3801
    set a, [i]
integer.dasm16
1234
2
26c8
7c0a
26c9
00ff
    and a, 0x00ff
integer.dasm16
1235
0
    
integer.dasm16
1236
1
26ca
040b
    bor a, b
integer.dasm16
1237
1
26cb
0021
    set b, a
integer.dasm16
1238
0
    
integer.dasm16
1239
1
26cc
1006
    div a, y
integer.dasm16
1240
1
26cd
1028
    mod b, y
integer.dasm16
1241
0

integer.dasm16
1242
1
26ce
004b
    bor c, a
integer.dasm16
1243
1
26cf
09c1
    set [i], c
integer.dasm16
1244
0
    
integer.dasm16
1245
1
26d0
0cd3
    ifn i, x
integer.dasm16
1246
2
26d1
7f9e
26d2
26bd
        sti pc, division__nbit_8bit__loop
integer.dasm16
1247
0

integer.dasm16
1248
2
26d3
5461
26d4
fffd
    set x, [z-3]
integer.dasm16
1249
1
26d5
2c61
    set x, [x]
integer.dasm16
1250
1
26d6
2c62
    add x, [x]
integer.dasm16
1251
1
26d7
0561
    set [x], b
integer.dasm16
1252
0

integer.dasm16
1253
0
:division_finish
integer.dasm16
1254
2
26d8
5701
26d9
ffff
    set push, [z-1]
integer.dasm16
1255
2
26da
7c20
26db
2716
    jsr int_normalize
integer.dasm16
1256
2
26dc
0ea1
26dd
ffff
    set [z-1], x
integer.dasm16
1257
0

integer.dasm16
1258
2
26de
5701
26df
fffd
    set push, [z-3]
integer.dasm16
1259
2
26e0
7c20
26e1
2716
    jsr int_normalize
integer.dasm16
1260
2
26e2
0ea1
26e3
fffd
    set [z-3], x
integer.dasm16
1261
0

integer.dasm16
1262
0
:division_finish_signs
integer.dasm16
1263
0
    ; figure out signs
integer.dasm16
1264
2
26e4
54c1
26e5
000b
    set i, [z+11]
integer.dasm16
1265
1
26e6
38c1
    set i, [i]
integer.dasm16
1266
2
26e7
58c1
26e8
0001
    set i, [i+1]
integer.dasm16
1267
0
    
integer.dasm16
1268
2
26e9
54e1
26ea
000a
    set j, [z+10]
integer.dasm16
1269
1
26eb
3ce1
    set j, [j]
integer.dasm16
1270
2
26ec
5ce1
26ed
0001
    set j, [j+1]
integer.dasm16
1271
0
    
integer.dasm16
1272
1
26ee
1ccc
    xor i, j
integer.dasm16
1273
0

integer.dasm16
1274
2
26ef
7cd1
26f0
8000
    ifc i, 0x8000
integer.dasm16
1275
2
26f1
7f81
26f2
2701
        set pc, division_set_modulo_sign
integer.dasm16
1276
0

integer.dasm16
1277
0
    ; negate quotient and invert modulo
integer.dasm16
1278
2
26f3
5701
26f4
ffff
    set push, [z-1]
integer.dasm16
1279
2
26f5
7c20
26f6
24c3
    jsr int_negate
integer.dasm16
1280
2
26f7
0ea1
26f8
ffff
    set [z-1], x
integer.dasm16
1281
0

integer.dasm16
1282
2
26f9
5701
26fa
fffe
    set push, [z-2]
integer.dasm16
1283
2
26fb
5701
26fc
fffd
    set push, [z-3]
integer.dasm16
1284
2
26fd
7c20
26fe
253b
    jsr int_sub
integer.dasm16
1285
2
26ff
0ea1
2700
fffd
    set [z-3], x
integer.dasm16
1286
0

integer.dasm16
1287
0
:division_set_modulo_sign
integer.dasm16
1288
2
2701
7cf1
2702
8000
    ifc j, 0x8000
integer.dasm16
1289
2
2703
7f81
2704
270b
        set pc, division_return_tuple
integer.dasm16
1290
0

integer.dasm16
1291
2
2705
5701
2706
fffd
    set push, [z-3]
integer.dasm16
1292
2
2707
7c20
2708
24c3
    jsr int_negate
integer.dasm16
1293
2
2709
0ea1
270a
fffd
    set [z-3], x
integer.dasm16
1294
0

integer.dasm16
1295
0
:division_return_tuple
integer.dasm16
1296
0
    ; finally create result tuple
integer.dasm16
1297
1
270b
8f01
    set push, 2
integer.dasm16
1298
1
270c
9701
    set push, TYPE_TUPLE
integer.dasm16
1299
2
270d
7c20
270e
2770
    jsr array_create
integer.dasm16
1300
0
    
integer.dasm16
1301
1
270f
2cde
    sti i, [x]
integer.dasm16
1302
0

integer.dasm16
1303
2
2710
55de
2711
ffff
    sti [i], [z-1]
integer.dasm16
1304
2
2712
55c1
2713
fffd
    set [i], [z-3]
integer.dasm16
1305
0
    
integer.dasm16
1306
2
2714
7c20
2715
2026
    jsr postamble
integer.dasm16
1307
0

integer.dasm16
1308
0
;----------------------------------------------------------------
integer.dasm16
1309
0
; struct handle *int_normalize(struct handle *integer)
integer.dasm16
1310
0
;----------------------------------------------------------------
integer.dasm16
1311
0
:int_normalize
integer.dasm16
1312
1
2716
8b01
    set push, 1
integer.dasm16
1313
1
2717
8b01
    set push, 1
integer.dasm16
1314
2
2718
7c20
2719
2039
    jsr preamble
integer.dasm16
1315
0

integer.dasm16
1316
2
271a
5421
271b
000a
    set b, [z+10]
integer.dasm16
1317
1
271c
2401
    set a, [b]    ; a: struct int *
integer.dasm16
1318
0
    
integer.dasm16
1319
1
271d
00c1
    set i, a    ; i: msw *
integer.dasm16
1320
1
271e
2002
    add a, [a]    ; a: lsw *
integer.dasm16
1321
0

integer.dasm16
1322
0
:int_normalize_count_loop
integer.dasm16
1323
1
271f
88c2
    add i, 1
integer.dasm16
1324
0

integer.dasm16
1325
1
2720
00d2
    ife i, a
integer.dasm16
1326
2
2721
7f81
2722
272f
        set pc, int_normalize_count_break
integer.dasm16
1327
0

integer.dasm16
1328
1
2723
81d2
    ife [i], 0xffff
integer.dasm16
1329
3
2724
7ed0
2725
8000
2726
0001
        ifb [i+1], 0x8000
integer.dasm16
1330
2
2727
7f81
2728
271f
            set pc, int_normalize_count_loop
integer.dasm16
1331
0

integer.dasm16
1332
1
2729
85d2
    ife [i], 0x0000
integer.dasm16
1333
3
272a
7ed1
272b
8000
272c
0001
        ifc [i+1], 0x8000
integer.dasm16
1334
2
272d
7f81
272e
271f
            set pc, int_normalize_count_loop
integer.dasm16
1335
0
    
integer.dasm16
1336
0
:int_normalize_count_break
integer.dasm16
1337
1
272f
8802
    add a, 1
integer.dasm16
1338
1
2730
0041
    set c, a
integer.dasm16
1339
1
2731
1843
    sub c, i
integer.dasm16
1340
0

integer.dasm16
1341
1
2732
24c3
    sub i, [b]
integer.dasm16
1342
0

integer.dasm16
1343
1
2733
0461
    set x, b
integer.dasm16
1344
1
2734
2421
    set b, [b]
integer.dasm16
1345
1
2735
0932
    ife [b + INT_LEN], c
integer.dasm16
1346
2
2736
7c20
2737
2026
        jsr postamble
integer.dasm16
1347
0
    
integer.dasm16
1348
1
2738
0b01
    set push, c
integer.dasm16
1349
2
2739
7f01
273a
0020
    set push, TYPE_INT
integer.dasm16
1350
2
273b
7c20
273c
2770
    jsr array_create
integer.dasm16
1351
0

integer.dasm16
1352
2
273d
0ea1
273e
ffff
    set [z-1], x
integer.dasm16
1353
0

integer.dasm16
1354
2
273f
5401
2740
000a
    set a, [z+10]
integer.dasm16
1355
1
2741
2001
    set a, [a]
integer.dasm16
1356
1
2742
00c2
    add i, a
integer.dasm16
1357
1
2743
2002
    add a, [a]    
integer.dasm16
1358
1
2744
8802
    add a, 1
integer.dasm16
1359
0

integer.dasm16
1360
1
2745
2ce1
    set j, [x]    ; struct int *new
integer.dasm16
1361
1
2746
88e2
    add j, 1    ; msw *
integer.dasm16
1362
0

integer.dasm16
1363
0
:int_normalize_copy_loop
integer.dasm16
1364
1
2747
39fe
    sti [j], [i]                
integer.dasm16
1365
1
2748
00d3
    ifn i, a
integer.dasm16
1366
2
2749
7f81
274a
2747
        set pc, int_normalize_copy_loop
integer.dasm16
1367
0

integer.dasm16
1368
2
274b
7c20
274c
2026
    jsr postamble
integer.dasm16
1369
0

integer.dasm16
1370
0
;----------------------------------------------------------------
integer.dasm16
1371
0
; struct handle *int_extend(struct handle *integer, uint len)
integer.dasm16
1372
0
; extend always return different object
integer.dasm16
1373
0
;----------------------------------------------------------------
integer.dasm16
1374
0
:int_extend
integer.dasm16
1375
0
; [SP + 5] struct handle *
integer.dasm16
1376
0
; [SP + 4] len
integer.dasm16
1377
0
; [SP + 3] RTS
integer.dasm16
1378
0
; [SP + 2] a
integer.dasm16
1379
0
; [SP + 1] i
integer.dasm16
1380
0
; [SP + 0] j
integer.dasm16
1381
0

integer.dasm16
1382
1
274d
0301
    set push, a
integer.dasm16
1383
1
274e
1b01
    set push, i
integer.dasm16
1384
1
274f
1f01
    set push, j
integer.dasm16
1385
0

integer.dasm16
1386
2
2750
6b01
2751
0004
    set push, [sp + 4]
integer.dasm16
1387
2
2752
7f01
2753
0020
    set push, TYPE_INT
integer.dasm16
1388
2
2754
7c20
2755
2770
    jsr array_create
integer.dasm16
1389
0

integer.dasm16
1390
1
2756
2ce1
    set j, [x]        ; j: new lsw
integer.dasm16
1391
1
2757
3ce2
    add j, [j]
integer.dasm16
1392
0

integer.dasm16
1393
2
2758
6801
2759
0005
    set a, [sp + 5]    ; struct handle *
integer.dasm16
1394
0

integer.dasm16
1395
1
275a
20c1
    set i, [a]
integer.dasm16
1396
1
275b
38c2
    add i, [i]        ; i: orig lsw
integer.dasm16
1397
0

integer.dasm16
1398
0
:int_extend_copy_loop
integer.dasm16
1399
1
275c
39ff
    std [j], [i]
integer.dasm16
1400
1
275d
20d4
    ifg i, [a]
integer.dasm16
1401
2
275e
7f81
275f
275c
        set pc, int_extend_copy_loop
integer.dasm16
1402
0
        
integer.dasm16
1403
1
2760
2cf2
    ife j, [x]
integer.dasm16
1404
2
2761
7f81
2762
276a
        set pc, int_extend_finish
integer.dasm16
1405
0

integer.dasm16
1406
2
2763
5801
2764
0001
    set a, [i+1]
integer.dasm16
1407
1
2765
c00e
    asr a, 15
integer.dasm16
1408
0
    
integer.dasm16
1409
0
:int_extend_fill_loop
integer.dasm16
1410
1
2766
01ff
    std [j], a
integer.dasm16
1411
1
2767
2cf4
    ifg j, [x]
integer.dasm16
1412
2
2768
7f81
2769
2766
        set pc, int_extend_fill_loop
integer.dasm16
1413
0

integer.dasm16
1414
0
:int_extend_finish
integer.dasm16
1415
1
276a
60e1
    set j, pop
integer.dasm16
1416
1
276b
60c1
    set i, pop
integer.dasm16
1417
1
276c
6001
    set a, pop
integer.dasm16
1418
1
276d
6321
    set [sp], pop
integer.dasm16
1419
1
276e
6321
    set [sp], pop    
integer.dasm16
1420
0

integer.dasm16
1421
1
276f
6381
    set pc, pop
integer.dasm16
1422
0

array.dasm16
0
0
;----------------------------------------------------------------
array.dasm16
1
0
; struct handle *array_create(uint16 len, uint16 type)
array.dasm16
2
0
;  ugly hack to mimic call conventions
array.dasm16
3
0
;----------------------------------------------------------------
array.dasm16
4
0
:array_create
array.dasm16
5
2
2770
6b01
2771
0002
    set push, [sp + 2]        ; size
array.dasm16
6
1
2772
8b22
    add [sp], 1
array.dasm16
7
2
2773
6b01
2774
0002
    set push, [sp + 2]        ; type
array.dasm16
8
2
2775
7c20
2776
21d3
    jsr alloc
array.dasm16
9
0
    
array.dasm16
10
1
2777
0f01
    set push, x
array.dasm16
11
0
    
array.dasm16
12
1
2778
2c61
    set x, [x]
array.dasm16
13
2
2779
6961
277a
0003
    set [x], [sp + 3]
array.dasm16
14
0
    
array.dasm16
15
0
    ; restore stack
array.dasm16
16
1
277b
6061
    set x, pop
array.dasm16
17
1
277c
6321
    set [sp], pop
array.dasm16
18
1
277d
6321
    set [sp], pop
array.dasm16
19
0

array.dasm16
20
1
277e
6381
    set pc, pop
array.dasm16
21
0

array.dasm16
22
0
;----------------------------------------------------------------
array.dasm16
23
0
:array__get
array.dasm16
24
0
; fastcall
array.dasm16
25
0
; a: struct handle *
array.dasm16
26
0
; b: index
array.dasm16
27
0
; return x: uint16 at specified index or 0
array.dasm16
28
0
;----------------------------------------------------------------
array.dasm16
29
2
277f
7c20
2780
27a1
    jsr array__get_memory_addr
array.dasm16
30
0
    
array.dasm16
31
1
2781
8473
    ifn x, 0
array.dasm16
32
1
2782
2c61
        set x, [x]
array.dasm16
33
0
    
array.dasm16
34
1
2783
6381
    set pc, pop    
array.dasm16
35
0

array.dasm16
36
0
;----------------------------------------------------------------
array.dasm16
37
0
:array__set
array.dasm16
38
0
; fastcall
array.dasm16
39
0
; a: struct handle *
array.dasm16
40
0
; b: index
array.dasm16
41
0
; c: item (struct handle * or char)
array.dasm16
42
0
;----------------------------------------------------------------
array.dasm16
43
2
2784
7c20
2785
27a1
    jsr array__get_memory_addr
array.dasm16
44
0
    
array.dasm16
45
1
2786
8472
    ife x, 0
array.dasm16
46
2
2787
7c20
2788
00c6
        jsr recover
array.dasm16
47
0
    
array.dasm16
48
1
2789
0961
    set [x], c
array.dasm16
49
0

array.dasm16
50
1
278a
6381
    set pc, pop    
array.dasm16
51
0

array.dasm16
52
0
;----------------------------------------------------------------
array.dasm16
53
0
:array__del
array.dasm16
54
0
; fastcall
array.dasm16
55
0
; a: struct handle *
array.dasm16
56
0
; b: index
array.dasm16
57
0
;----------------------------------------------------------------
array.dasm16
58
2
278b
7c20
278c
27a1
    jsr array__get_memory_addr
array.dasm16
59
0
    
array.dasm16
60
1
278d
8472
    ife x, 0
array.dasm16
61
2
278e
7c20
278f
00c6
        jsr recover
array.dasm16
62
0

array.dasm16
63
1
2790
1b01
    set push, i
array.dasm16
64
1
2791
1f01
    set push, j
array.dasm16
65
0

array.dasm16
66
1
2792
0cc1
    set i, x
array.dasm16
67
1
2793
0ce1
    set j, x
array.dasm16
68
1
2794
88e2
    add j, 1
array.dasm16
69
0
    
array.dasm16
70
1
2795
2061
    set x, [a]
array.dasm16
71
1
2796
8963
    sub [x], 1
array.dasm16
72
1
2797
2c62
    add x, [x]
array.dasm16
73
0

array.dasm16
74
0
:array__del__loop
array.dasm16
75
1
2798
0cd4
    ifg i, x
array.dasm16
76
2
2799
7f81
279a
279e
        set pc, array__del__finish
array.dasm16
77
0
        
array.dasm16
78
1
279b
3dc1
    set [i], [j]
array.dasm16
79
2
279c
7f9e
279d
2798
    sti pc, array__del__loop
array.dasm16
80
0
    
array.dasm16
81
0
:array__del__finish
array.dasm16
82
1
279e
60e1
    set j, pop
array.dasm16
83
1
279f
60c1
    set i, pop
array.dasm16
84
1
27a0
6381
    set pc, pop
array.dasm16
85
0

array.dasm16
86
0
;----------------------------------------------------------------
array.dasm16
87
0
:array__get_memory_addr
array.dasm16
88
0
; fastcall
array.dasm16
89
0
; a: struct handle *array
array.dasm16
90
0
; b: index
array.dasm16
91
0
; return x: memory location or 0 for out of bounds
array.dasm16
92
0
;----------------------------------------------------------------
array.dasm16
93
1
27a1
0301
    set push, a
array.dasm16
94
0
    
array.dasm16
95
1
27a2
2001
    set a, [a]            ; struct array *
array.dasm16
96
0

array.dasm16
97
1
27a3
0461
    set x, b
array.dasm16
98
2
27a4
7c30
27a5
8000
    ifb b, 0x8000
array.dasm16
99
1
27a6
2062
        add x, [a]
array.dasm16
100
0

array.dasm16
101
2
27a7
7c70
27a8
8000
    ifb x, 0x8000
array.dasm16
102
2
27a9
7f81
27aa
27b2
        set pc, array__get_memory_addr__out_of_bounds
array.dasm16
103
0

array.dasm16
104
1
27ab
8862
    add x, 1
array.dasm16
105
1
27ac
2074
    ifg x, [a]
array.dasm16
106
2
27ad
7f81
27ae
27b2
        set pc, array__get_memory_addr__out_of_bounds
array.dasm16
107
0

array.dasm16
108
1
27af
0062
    add x, a
array.dasm16
109
0
    
array.dasm16
110
1
27b0
6001
    set a, pop
array.dasm16
111
1
27b1
6381
    set pc, pop
array.dasm16
112
0

array.dasm16
113
0
:array__get_memory_addr__out_of_bounds
array.dasm16
114
1
27b2
6001
    set a, pop
array.dasm16
115
1
27b3
8461
    set x, 0
array.dasm16
116
1
27b4
6381
    set pc, pop
array.dasm16
117
0

array.dasm16
118
0
;----------------------------------------------------------------
array.dasm16
119
0
; extern struct handle *array_insert(struct handle *array, uint index, void item)
array.dasm16
120
0
;----------------------------------------------------------------
array.dasm16
121
0
:array__insert
array.dasm16
122
1
27b5
9301
    set push, 3
array.dasm16
123
1
27b6
8701
    set push, 0
array.dasm16
124
2
27b7
7c20
27b8
2039
    jsr preamble
array.dasm16
125
0

array.dasm16
126
0
    ; calculate index to b
array.dasm16
127
2
27b9
5401
27ba
000c
    set a, [z+12]        ; struct handle *array
array.dasm16
128
1
27bb
2041
    set c, [a]            ; struct array *
array.dasm16
129
0

array.dasm16
130
2
27bc
5421
27bd
000b
    set b, [z+11]        ; index
array.dasm16
131
0

array.dasm16
132
2
27be
7c30
27bf
8000
    ifb b, 0x8000        ; if index < 0
array.dasm16
133
1
27c0
2822
        add b, [c]        ;   index += len
array.dasm16
134
0

array.dasm16
135
2
27c1
7c30
27c2
8000
    ifb b, 0x8000        ; if index < 0
array.dasm16
136
1
27c3
8421
        set b, 0        ;   index = 0
array.dasm16
137
0

array.dasm16
138
1
27c4
2834
    ifg b, [c]            ; if index > len
array.dasm16
139
1
27c5
2821
        set b, [c]        ;   index = len
array.dasm16
140
0

array.dasm16
141
2
27c6
7c20
27c7
2803
    jsr array__increment_length
array.dasm16
142
0

array.dasm16
143
1
27c8
20c1
    set i, [a]            ; realloc has moved the memory
array.dasm16
144
1
27c9
38c2
    add i, [i]
array.dasm16
145
0

array.dasm16
146
1
27ca
20e1
    set j, [a]
array.dasm16
147
1
27cb
3ce2
    add j, [j]
array.dasm16
148
1
27cc
88e3
    sub j, 1
array.dasm16
149
0

array.dasm16
150
1
27cd
2022
    add b, [a]
array.dasm16
151
0

array.dasm16
152
0
:array__insert__loop
array.dasm16
153
1
27ce
04f2
    ife j, b
array.dasm16
154
2
27cf
7f81
27d0
27d4
        set pc, array__insert__finish
array.dasm16
155
0
        
array.dasm16
156
1
27d1
3dc1
    set [i], [j]
array.dasm16
157
2
27d2
7f9f
27d3
27ce
    std pc, array__insert__loop
array.dasm16
158
0
    
array.dasm16
159
0
:array__insert__finish
array.dasm16
160
2
27d4
55c1
27d5
000a
    set [i], [z+10]
array.dasm16
161
2
27d6
7c20
27d7
2026
    jsr postamble
array.dasm16
162
0

array.dasm16
163
0
;----------------------------------------------------------------
array.dasm16
164
0
; extern struct handle *array_insert(struct handle *array, void item)
array.dasm16
165
0
;----------------------------------------------------------------
array.dasm16
166
0
; [sp + 3] array
array.dasm16
167
0
; [sp + 2] item
array.dasm16
168
0
; [sp + 1] RTS
array.dasm16
169
0
; [sp + 0] a
array.dasm16
170
0
:array__append
array.dasm16
171
1
27d8
0301
    set push, a
array.dasm16
172
0

array.dasm16
173
2
27d9
6801
27da
0003
    set a, [sp + 3]
array.dasm16
174
2
27db
7c20
27dc
2803
    jsr array__increment_length
array.dasm16
175
0

array.dasm16
176
1
27dd
2001
    set a, [a]
array.dasm16
177
1
27de
2002
    add a, [a]
array.dasm16
178
0

array.dasm16
179
2
27df
6901
27e0
0002
    set [a], [sp + 2]
array.dasm16
180
0

array.dasm16
181
1
27e1
6001
    set a, pop
array.dasm16
182
2
27e2
6861
27e3
0002
    set x, [sp + 2]
array.dasm16
183
0
    
array.dasm16
184
1
27e4
6321
    set [sp], pop
array.dasm16
185
1
27e5
6321
    set [sp], pop
array.dasm16
186
1
27e6
6381
    set pc, pop
array.dasm16
187
0

array.dasm16
188
0
;----------------------------------------------------------------
array.dasm16
189
0
; struct handle *array_append_array(struct handle *array, struct handle *array)
array.dasm16
190
0
;----------------------------------------------------------------
array.dasm16
191
0
; [sp + 5] this_array
array.dasm16
192
0
; [sp + 4] arg_array
array.dasm16
193
0
; [sp + 3] RTS
array.dasm16
194
0
; [sp + 2] a
array.dasm16
195
0
; [sp + 1] b
array.dasm16
196
0
; [sp + 0] len(arg)
array.dasm16
197
0
:array__append_array
array.dasm16
198
1
27e7
0301
    set push, a
array.dasm16
199
1
27e8
0701
    set push, b
array.dasm16
200
0

array.dasm16
201
2
27e9
6801
27ea
0003
    set a, [sp + 3] ; struct handle *arg
array.dasm16
202
1
27eb
2061
    set x, [a]      ; struct array *arg
array.dasm16
203
1
27ec
2f01
    set push, [x]   ; len(arg)
array.dasm16
204
0

array.dasm16
205
1
27ed
0423
    sub b, b        ; index
array.dasm16
206
0

array.dasm16
207
0
:array__append_array__loop
array.dasm16
208
1
27ee
6432
    ife b, [sp]
array.dasm16
209
2
27ef
7f81
27f0
27fb
        set pc, array__append_array__finish
array.dasm16
210
0

array.dasm16
211
2
27f1
7c20
27f2
277f
    jsr array__get
array.dasm16
212
0
    
array.dasm16
213
2
27f3
6b01
27f4
0005
    set push, [sp + 5]
array.dasm16
214
1
27f5
0f01
    set push, x
array.dasm16
215
2
27f6
7c20
27f7
27d8
    jsr array__append
array.dasm16
216
0

array.dasm16
217
1
27f8
8822
    add b, 1
array.dasm16
218
2
27f9
7f81
27fa
27ee
    set pc, array__append_array__loop
array.dasm16
219
0

array.dasm16
220
0
:array__append_array__finish
array.dasm16
221
2
27fb
6861
27fc
0005
    set x, [sp + 5]
array.dasm16
222
1
27fd
8b62
    add sp, 1
array.dasm16
223
1
27fe
6021
    set b, pop
array.dasm16
224
1
27ff
6001
    set a, pop
array.dasm16
225
1
2800
6321
    set [sp], pop
array.dasm16
226
1
2801
6321
    set [sp], pop
array.dasm16
227
1
2802
6381
    set pc, pop
array.dasm16
228
0

array.dasm16
229
0
;----------------------------------------------------------------
array.dasm16
230
0
:array__increment_length
array.dasm16
231
0
; fastcall
array.dasm16
232
0
; a: struct handle *array
array.dasm16
233
0
;----------------------------------------------------------------    
array.dasm16
234
1
2803
2061
    set x, [a]
array.dasm16
235
1
2804
8962
    add [x], 1
array.dasm16
236
0
    
array.dasm16
237
2
2805
4176
2806
0002
    ifl [x], [a + HANDLE_SIZE]                ; if len < capacity+1
array.dasm16
238
1
2807
6381
        set pc, pop
array.dasm16
239
0

array.dasm16
240
0
    ; increase list capacity
array.dasm16
241
1
2808
0301
    set push, a
array.dasm16
242
1
2809
2f01
    set push, [x]
array.dasm16
243
1
280a
ab22
    add [sp], 9
array.dasm16
244
2
280b
7c20
280c
2185
    jsr realloc
array.dasm16
245
0

array.dasm16
246
1
280d
6381
    set pc, pop
array.dasm16
247
0
    
array.dasm16
248
0
;----------------------------------------------------------------
array.dasm16
249
0
; extern struct handle *array_split(struct handle *orig, uint start, uint end)
array.dasm16
250
0
;----------------------------------------------------------------
array.dasm16
251
0
:array_split
array.dasm16
252
1
280e
9301
    set push, 3
array.dasm16
253
1
280f
8b01
    set push, 1
array.dasm16
254
2
2810
7c20
2811
2039
    jsr preamble
array.dasm16
255
0

array.dasm16
256
2
2812
5401
2813
000c
    set a, [z+12]
array.dasm16
257
1
2814
2021
    set b, [a]
array.dasm16
258
0

array.dasm16
259
0
    ; start index
array.dasm16
260
2
2815
54e1
2816
000b
    set j, [z+11]
array.dasm16
261
1
2817
84f7
    ifu j, 0
array.dasm16
262
1
2818
24e2
        add j, [b]
array.dasm16
263
1
2819
84f7
    ifu j, 0
array.dasm16
264
1
281a
1cec
        xor j, j
array.dasm16
265
0

array.dasm16
266
0
    ; end index
array.dasm16
267
2
281b
5441
281c
000a
    set c, [z+10]
array.dasm16
268
1
281d
8457
    ifu c, 0
array.dasm16
269
1
281e
2442
        add c, [b]
array.dasm16
270
1
281f
8457
    ifu c, 0
array.dasm16
271
1
2820
084c
        xor c, c
array.dasm16
272
0

array.dasm16
273
1
2821
2455
    ifa c, [b]
array.dasm16
274
1
2822
2441
        set c, [b]
array.dasm16
275
0
        
array.dasm16
276
1
2823
08f5
    ifa j, c
array.dasm16
277
1
2824
08e1
        set j, c
array.dasm16
278
0

array.dasm16
279
1
2825
0881
    set y, c
array.dasm16
280
1
2826
1c83
    sub y, j
array.dasm16
281
0

array.dasm16
282
1
2827
1301
    set push, y
array.dasm16
283
2
2828
4301
2829
0001
    set push, [a + HANDLE_TYPE]
array.dasm16
284
2
282a
7c20
282b
2770
    jsr array_create
array.dasm16
285
2
282c
0ea1
282d
ffff
    set [z+-1], x
array.dasm16
286
0

array.dasm16
287
1
282e
2021
    set b, [a]
array.dasm16
288
1
282f
04e2
    add j, b
array.dasm16
289
1
2830
0442
    add c, b
array.dasm16
290
0
    
array.dasm16
291
1
2831
2cc1
    set i, [x]
array.dasm16
292
1
2832
11c1
    set [i], y
array.dasm16
293
0
    
array.dasm16
294
0
:array_split_loop
array.dasm16
295
1
2833
08f2
    ife j, c
array.dasm16
296
2
2834
7c20
2835
2026
        jsr postamble
array.dasm16
297
3
2836
5ede
2837
0001
2838
0001
    sti [i+1], [j+1]
array.dasm16
298
2
2839
7f81
283a
2833
    set pc, array_split_loop
array.dasm16
299
0

array.dasm16
300
0
;----------------------------------------------------------------
array.dasm16
301
0
; extern struct handle *array_merge(struct handle *left, struct handle *right)
array.dasm16
302
0
;----------------------------------------------------------------
array.dasm16
303
0
:array_merge
array.dasm16
304
1
283b
8f01
    set push, 2
array.dasm16
305
1
283c
8b01
    set push, 1
array.dasm16
306
2
283d
7c20
283e
2039
    jsr preamble
array.dasm16
307
0

array.dasm16
308
2
283f
5401
2840
000b
    set a, [z+11]
array.dasm16
309
2
2841
5421
2842
000a
    set b, [z+10]
array.dasm16
310
0
    
array.dasm16
311
1
2843
2041
    set c, [a]
array.dasm16
312
1
2844
2841
    set c, [c]
array.dasm16
313
1
2845
2461
    set x, [b]
array.dasm16
314
1
2846
2c42
    add c, [x]
array.dasm16
315
0
    
array.dasm16
316
1
2847
0b01
    set push, c
array.dasm16
317
2
2848
4301
2849
0001
    set push, [a + HANDLE_TYPE]
array.dasm16
318
2
284a
7c20
284b
2770
    jsr array_create
array.dasm16
319
2
284c
0ea1
284d
ffff
    set [z-1], x        ; struct handle *result
array.dasm16
320
0

array.dasm16
321
1
284e
20c1
    set i, [a]
array.dasm16
322
1
284f
2041
    set c, [a]
array.dasm16
323
1
2850
2842
    add c, [c]
array.dasm16
324
0
    
array.dasm16
325
1
2851
2cfe
    sti j, [x]
array.dasm16
326
0

array.dasm16
327
0
:array_merge__left_loop
array.dasm16
328
1
2852
08d4
    ifg i, c
array.dasm16
329
2
2853
7f81
2854
2858
        set pc, array_merge__right
array.dasm16
330
0
        
array.dasm16
331
1
2855
39fe
    sti [j], [i]
array.dasm16
332
2
2856
7f81
2857
2852
    set pc, array_merge__left_loop
array.dasm16
333
0
    
array.dasm16
334
0
:array_merge__right
array.dasm16
335
1
2858
24c1
    set i, [b]
array.dasm16
336
1
2859
88c2
    add i, 1
array.dasm16
337
0

array.dasm16
338
1
285a
2441
    set c, [b]
array.dasm16
339
1
285b
2842
    add c, [c]
array.dasm16
340
0

array.dasm16
341
0
:array_merge__right_loop
array.dasm16
342
1
285c
08d4
    ifg i, c
array.dasm16
343
2
285d
7c20
285e
2026
        jsr postamble
array.dasm16
344
0
        
array.dasm16
345
1
285f
39fe
    sti [j], [i]
array.dasm16
346
2
2860
7f81
2861
285c
    set pc, array_merge__right_loop
array.dasm16
347
0
        
array.dasm16
348
0
;----------------------------------------------------------------
array.dasm16
349
0
; uint array_cmp(struct handle *array, struct handle *array, func *comparator)
array.dasm16
350
0
;----------------------------------------------------------------
array.dasm16
351
0
:array_cmp
array.dasm16
352
1
2862
9301
    set push, 3        ; sizeof(args)
array.dasm16
353
1
2863
8701
    set push, 0        ; sizeof(vars)
array.dasm16
354
2
2864
7c20
2865
2039
    jsr preamble
array.dasm16
355
0

array.dasm16
356
2
2866
54c1
2867
000c
    set i, [z+12]    ; struct handle *list1
array.dasm16
357
1
2868
38c1
    set i, [i]        ; struct list *list1
array.dasm16
358
0

array.dasm16
359
1
2869
1801
    set a, i
array.dasm16
360
1
286a
2002
    add a, [a]        ; *tail1
array.dasm16
361
0
    
array.dasm16
362
2
286b
54e1
286c
000b
    set j, [z+11]    ; struct handle *list2
array.dasm16
363
1
286d
3ce1
    set j, [j]        ; struct list *list2
array.dasm16
364
0

array.dasm16
365
1
286e
1c3e
    sti b, j        ; i: *head1, j: *head2
array.dasm16
366
1
286f
2422
    add b, [b]        ; *tail2
array.dasm16
367
0

array.dasm16
368
0
:array_cmp_loop
array.dasm16
369
1
2870
00d4
    ifg i, a
array.dasm16
370
2
2871
7f81
2872
287f
        set pc, array_cmp_break__left
array.dasm16
371
1
2873
04f4
    ifg j, b
array.dasm16
372
2
2874
7f81
2875
2884
        set pc, array_cmp_break__right
array.dasm16
373
0

array.dasm16
374
1
2876
3b01
    set push, [i]
array.dasm16
375
1
2877
3f01
    set push, [j]
array.dasm16
376
2
2878
5420
2879
000a
    jsr [z+10]
array.dasm16
377
0

array.dasm16
378
1
287a
8472
    ife x, 0
array.dasm16
379
2
287b
7f9e
287c
2870
        sti pc, array_cmp_loop
array.dasm16
380
0

array.dasm16
381
2
287d
7c20
287e
2026
    jsr postamble
array.dasm16
382
0

array.dasm16
383
0
:array_cmp_break__left
array.dasm16
384
1
287f
8061
    set x, -1
array.dasm16
385
1
2880
04f4
    ifg j, b
array.dasm16
386
1
2881
8461
        set x, 0
array.dasm16
387
0

array.dasm16
388
2
2882
7c20
2883
2026
    jsr postamble
array.dasm16
389
0

array.dasm16
390
0
:array_cmp_break__right
array.dasm16
391
1
2884
8861
    set x, 1
array.dasm16
392
0

array.dasm16
393
2
2885
7c20
2886
2026
    jsr postamble
array.dasm16
394
0

array.dasm16
395
0
;----------------------------------------------------------------
array.dasm16
396
0
; struct handle *array_repeat(struct handle *array, struct handle *int_times)
array.dasm16
397
0
;----------------------------------------------------------------
array.dasm16
398
0
:array_repeat
array.dasm16
399
1
2887
8f01
    set push, 2
array.dasm16
400
1
2888
8701
    set push, 0
array.dasm16
401
2
2889
7c20
288a
2039
    jsr preamble
array.dasm16
402
0
    
array.dasm16
403
2
288b
5701
288c
000a
    set push, [z+10]        ; struct handle *int
array.dasm16
404
2
288d
7c20
288e
22bc
    jsr int_to_int16
array.dasm16
405
0

array.dasm16
406
1
288f
0c41
    set c, x            ; store multiplier
array.dasm16
407
2
2890
7c50
2891
8000
    ifb c, 0x8000
array.dasm16
408
1
2892
8441
        set c, 0
array.dasm16
409
0

array.dasm16
410
2
2893
5401
2894
000b
    set a, [z+11]            ; struct handle *
array.dasm16
411
1
2895
2021
    set b, [a]            ; struct list *
array.dasm16
412
0

array.dasm16
413
1
2896
2481
    set y, [b]            ; list size
array.dasm16
414
1
2897
0884
    mul y, c            ; space required
array.dasm16
415
0

array.dasm16
416
1
2898
1301
    set push, y
array.dasm16
417
2
2899
4301
289a
0001
    set push, [a + HANDLE_TYPE]
array.dasm16
418
2
289b
7c20
289c
2770
    jsr array_create
array.dasm16
419
0

array.dasm16
420
1
289d
2ce1
    set j, [x]
array.dasm16
421
1
289e
3ce2
    add j, [j]            ; last item
array.dasm16
422
0

array.dasm16
423
1
289f
20c1
    set i, [a]
array.dasm16
424
0

array.dasm16
425
0
:array_repeat_loop
array.dasm16
426
1
28a0
2cf2
    ife j, [x]
array.dasm16
427
2
28a1
7c20
28a2
2026
        jsr postamble
array.dasm16
428
1
28a3
20d2
    ife i, [a]
array.dasm16
429
1
28a4
38c2
        add i, [i]
array.dasm16
430
1
28a5
39ff
    std [j], [i]    
array.dasm16
431
2
28a6
7f81
28a7
28a0
    set pc, array_repeat_loop
array.dasm16
432
0

array.dasm16
433
0
;----------------------------------------------------------------
array.dasm16
434
0
; void array_sort(struct handle *array, uint16 *comparator_func)
array.dasm16
435
0
; comparator_func(a,b) return TRUE if a is before b
array.dasm16
436
0
;----------------------------------------------------------------
array.dasm16
437
0
:array_sort
array.dasm16
438
1
28a8
8f01
    set push, 2
array.dasm16
439
1
28a9
8701
    set push, 0
array.dasm16
440
2
28aa
7c20
28ab
2039
    jsr preamble    
array.dasm16
441
0

array.dasm16
442
2
28ac
5401
28ad
000b
    set a, [z+11]
array.dasm16
443
2
28ae
5421
28af
000a
    set b, [z+10]
array.dasm16
444
0

array.dasm16
445
1
28b0
2001
    set a, [a]    ; struct handle **i
array.dasm16
446
0

array.dasm16
447
1
28b1
0041
    set c, a
array.dasm16
448
1
28b2
2042
    add c, [a]    ; struct handle **last
array.dasm16
449
0

array.dasm16
450
0

array.dasm16
451
0
:array_sort_outer
array.dasm16
452
1
28b3
8802
    add a, 1    ; struct handle **first
array.dasm16
453
1
28b4
0812
    ife a, c
array.dasm16
454
2
28b5
7c20
28b6
2026
        jsr postamble
array.dasm16
455
0

array.dasm16
456
1
28b7
0081
    set y, a    ; struct handle **min
array.dasm16
457
0

array.dasm16
458
1
28b8
00fe
    sti j, a    ; 
array.dasm16
459
0

array.dasm16
460
0
:array_sort_inner
array.dasm16
461
1
28b9
08f4
    ifg j, c
array.dasm16
462
2
28ba
7f81
28bb
28c5
        set pc, array_finish_inner
array.dasm16
463
0

array.dasm16
464
1
28bc
3f01
    set push, [j]
array.dasm16
465
1
28bd
3301
    set push, [y]
array.dasm16
466
1
28be
0420
    jsr b
array.dasm16
467
0

array.dasm16
468
1
28bf
8472
    ife x, FALSE
array.dasm16
469
2
28c0
7f9e
28c1
28b9
        sti pc, array_sort_inner
array.dasm16
470
0

array.dasm16
471
1
28c2
1c81
    set y, j
array.dasm16
472
2
28c3
7f9e
28c4
28b9
    sti pc, array_sort_inner
array.dasm16
473
0
    
array.dasm16
474
0
:array_finish_inner
array.dasm16
475
1
28c5
3061
    set x, [y]
array.dasm16
476
1
28c6
2181
    set [y], [a]
array.dasm16
477
1
28c7
0d01
    set [a], x
array.dasm16
478
0

array.dasm16
479
2
28c8
7f9e
28c9
28b3
    sti pc, array_sort_outer
array.dasm16
480
0
    
array.dasm16
481
0
;----------------------------------------------------------------
array.dasm16
482
0
; struct handle *array_clone(struct handle *original)
array.dasm16
483
0
;----------------------------------------------------------------
array.dasm16
484
0
:array_clone
array.dasm16
485
1
28ca
0301
    set push, a
array.dasm16
486
1
28cb
1b01
    set push, i
array.dasm16
487
1
28cc
1f01
    set push, j
array.dasm16
488
0

array.dasm16
489
0
; [SP + 4] ARG0
array.dasm16
490
0
; [SP + 3] RTS
array.dasm16
491
0
; [SP + 2] A
array.dasm16
492
0
; [SP + 1] I
array.dasm16
493
0
; [SP + 0] J
array.dasm16
494
0

array.dasm16
495
2
28cd
6801
28ce
0004
    set a, [sp + 4]
array.dasm16
496
1
28cf
2061
    set x, [a]
array.dasm16
497
0

array.dasm16
498
1
28d0
2f01
    set push, [x]
array.dasm16
499
2
28d1
4301
28d2
0001
    set push, [a + HANDLE_TYPE]
array.dasm16
500
2
28d3
7c20
28d4
2770
    jsr array_create
array.dasm16
501
0

array.dasm16
502
1
28d5
2ce1
    set j, [x]
array.dasm16
503
0
    
array.dasm16
504
1
28d6
20de
    sti i, [a]
array.dasm16
505
1
28d7
2001
    set a, [a]
array.dasm16
506
1
28d8
2002
    add a, [a]
array.dasm16
507
0
    
array.dasm16
508
0
:array_clone_loop
array.dasm16
509
1
28d9
00d4
    ifg i, a
array.dasm16
510
2
28da
7f81
28db
28df
        set pc, array_clone_finish
array.dasm16
511
0
        
array.dasm16
512
1
28dc
39e1
    set [j], [i]
array.dasm16
513
2
28dd
7f9e
28de
28d9
    sti pc, array_clone_loop
array.dasm16
514
0

array.dasm16
515
0
:array_clone_finish
array.dasm16
516
1
28df
60e1
    set j, pop
array.dasm16
517
1
28e0
60c1
    set i, pop
array.dasm16
518
1
28e1
6001
    set a, pop
array.dasm16
519
1
28e2
6321
    set [sp], pop
array.dasm16
520
1
28e3
6381
    set pc, pop
array.dasm16
521
0
;----------------------------------------------------------------
array.dasm16
522
0
; void array_map(struct handle *array, *function map)
array.dasm16
523
0
;----------------------------------------------------------------
array.dasm16
524
0
; [sp + 4] array
array.dasm16
525
0
; [sp + 3] func
array.dasm16
526
0
; [sp + 2] RTS
array.dasm16
527
0
; [sp + 1] a
array.dasm16
528
0
; [sp + 0] b
array.dasm16
529
0
:array_map
array.dasm16
530
1
28e4
0301
    set push, a
array.dasm16
531
1
28e5
0701
    set push, b
array.dasm16
532
0

array.dasm16
533
2
28e6
6801
28e7
0004
    set a, [sp + 4]
array.dasm16
534
1
28e8
2001
    set a, [a]
array.dasm16
535
0

array.dasm16
536
1
28e9
0021
    set b, a
array.dasm16
537
1
28ea
2002
    add a, [a]
array.dasm16
538
0
    
array.dasm16
539
0
:array_map__loop
array.dasm16
540
1
28eb
8822
    add b, 1
array.dasm16
541
1
28ec
0034
    ifg b, a
array.dasm16
542
2
28ed
7f81
28ee
28f4
        set pc, array_map__finish
array.dasm16
543
0

array.dasm16
544
1
28ef
2701
    set push, [b]
array.dasm16
545
2
28f0
6820
28f1
0004
    jsr [sp + 4]
array.dasm16
546
0
    
array.dasm16
547
2
28f2
7f81
28f3
28eb
    set pc, array_map__loop
array.dasm16
548
0

array.dasm16
549
0
:array_map__finish
array.dasm16
550
1
28f4
6021
    set b, pop
array.dasm16
551
1
28f5
6001
    set a, pop
array.dasm16
552
1
28f6
6321
    set [sp], pop
array.dasm16
553
1
28f7
6321
    set [sp], pop
array.dasm16
554
1
28f8
6381
    set pc, pop
array.dasm16
555
0

array.dasm16
556
0
;----------------------------------------------------------------
array.dasm16
557
0
; void array_find(struct handle *array, void item)
array.dasm16
558
0
;----------------------------------------------------------------
array.dasm16
559
0
:array_find
array.dasm16
560
1
28f9
8f01
    set push, 2
array.dasm16
561
1
28fa
8701
    set push, 0
array.dasm16
562
2
28fb
7c20
28fc
2039
    jsr preamble
array.dasm16
563
0
    
array.dasm16
564
2
28fd
5401
28fe
000b
    set a, [z + 11]                ; struct handle *array
array.dasm16
565
2
28ff
5421
2900
000a
    set b, [z + 10]                ; item
array.dasm16
566
0

array.dasm16
567
1
2901
2081
    set y, [a]                    ; struct array *
array.dasm16
568
1
2902
10fe
    sti j, y                    ; ptr to current item
array.dasm16
569
0
    
array.dasm16
570
1
2903
3082
    add y, [y]                    ; ptr to last item
array.dasm16
571
0

array.dasm16
572
1
2904
84c1
    set i, 0                    ; index
array.dasm16
573
0

array.dasm16
574
0
:array_find__loop
array.dasm16
575
1
2905
8061
    set x, -1
array.dasm16
576
1
2906
10f4
    ifg j, y
array.dasm16
577
2
2907
7f81
2908
2026
        set pc, postamble
array.dasm16
578
0

array.dasm16
579
1
2909
3f01
    set push, [j]
array.dasm16
580
1
290a
0701
    set push, b
array.dasm16
581
2
290b
7c20
290c
1dc0
    jsr val_cmp
array.dasm16
582
0
    
array.dasm16
583
1
290d
8473
    ifn x, 0
array.dasm16
584
2
290e
7f9e
290f
2905
        sti pc, array_find__loop
array.dasm16
585
0

array.dasm16
586
1
2910
1861
    set x, i
array.dasm16
587
2
2911
7c20
2912
2026
    jsr postamble
list.dasm16
0
0
;----------------------------------------------------------------
list.dasm16
1
0
; struct handle *list_get(struct handle *list, struct handle *index)
list.dasm16
2
0
;----------------------------------------------------------------
list.dasm16
3
0
:list_get
list.dasm16
4
1
2913
8f01
    set push, 2        ; sizeof(args)
list.dasm16
5
1
2914
8701
    set push, 0        ; sizeof(refs)
list.dasm16
6
2
2915
7c20
2916
2039
    jsr preamble
list.dasm16
7
0

list.dasm16
8
2
2917
5401
2918
000b
    set a, [z+11]        ; struct handle *list
list.dasm16
9
0

list.dasm16
10
2
2919
5701
291a
000a
    set push, [z+10]        ; struct handle *int
list.dasm16
11
2
291b
7c20
291c
22bc
    jsr int_to_int16
list.dasm16
12
1
291d
0c21
    set b, x
list.dasm16
13
0

list.dasm16
14
2
291e
7c20
291f
277f
    jsr array__get
list.dasm16
15
0

list.dasm16
16
2
2920
7c20
2921
2026
    jsr postamble
list.dasm16
17
0
    
list.dasm16
18
0
;----------------------------------------------------------------
list.dasm16
19
0
; void list_set(struct handle *list, struct handle *index, struct handle *item)
list.dasm16
20
0
;----------------------------------------------------------------
list.dasm16
21
0
:list_set
list.dasm16
22
1
2922
9301
    set push, 3        ; sizeof(args)
list.dasm16
23
1
2923
8701
    set push, 0        ; sizeof(vars)
list.dasm16
24
2
2924
7c20
2925
2039
    jsr preamble
list.dasm16
25
0

list.dasm16
26
2
2926
5401
2927
000c
    set a, [z+12]        ; struct handle *list
list.dasm16
27
0

list.dasm16
28
2
2928
5701
2929
000b
    set push, [z+11]        ; struct handle *int
list.dasm16
29
2
292a
7c20
292b
22bc
    jsr int_to_int16
list.dasm16
30
1
292c
0c21
    set b, x
list.dasm16
31
0
    
list.dasm16
32
2
292d
5441
292e
000a
    set c, [z+10]
list.dasm16
33
2
292f
7c20
2930
2784
    jsr array__set
list.dasm16
34
0

list.dasm16
35
2
2931
7c20
2932
2026
    jsr postamble
list.dasm16
36
0

list.dasm16
37
0
;----------------------------------------------------------------
list.dasm16
38
0
; void list_del(struct handle *list, struct handle *index)
list.dasm16
39
0
;----------------------------------------------------------------
list.dasm16
40
0
:list_del
list.dasm16
41
1
2933
8f01
    set push, 2        ; sizeof(args)
list.dasm16
42
1
2934
8701
    set push, 0        ; sizeof(refs)
list.dasm16
43
2
2935
7c20
2936
2039
    jsr preamble
list.dasm16
44
0

list.dasm16
45
2
2937
5401
2938
000b
    set a, [z+11]        ; struct handle *list
list.dasm16
46
2
2939
8e11
293a
0001
    ifc [a + HANDLE_TYPE], TYPE_LIST
list.dasm16
47
2
293b
7c20
293c
00c6
        jsr recover
list.dasm16
48
0

list.dasm16
49
2
293d
5701
293e
000a
    set push, [z+10]    ; struct handle *int
list.dasm16
50
2
293f
7c20
2940
22bc
    jsr int_to_int16
list.dasm16
51
1
2941
0c21
    set b, x
list.dasm16
52
0

list.dasm16
53
2
2942
7c20
2943
278b
    jsr array__del
list.dasm16
54
0

list.dasm16
55
2
2944
7c20
2945
2026
    jsr postamble
list.dasm16
56
0
    
list.dasm16
57
0
;----------------------------------------------------------------
list.dasm16
58
0
; uint list_cmp(struct handle *left, struct handle *right)
list.dasm16
59
0
;----------------------------------------------------------------
list.dasm16
60
0
:list_cmp
list.dasm16
61
1
2946
6701
    set push, [sp]
list.dasm16
62
3
2947
7f41
2948
1dc0
2949
0001
    set [sp + 1], val_cmp
list.dasm16
63
2
294a
7f81
294b
2862
    set pc, array_cmp
list.dasm16
64
0

list.dasm16
65
0
;----------------------------------------------------------------
list.dasm16
66
0
; struct handle *list_repr(struct handle *list)
list.dasm16
67
0
;----------------------------------------------------------------
list.dasm16
68
0
:list_repr
list.dasm16
69
1
294c
8b01
    set push, 1
list.dasm16
70
1
294d
8f01
    set push, 2
list.dasm16
71
2
294e
7c20
294f
2039
    jsr preamble
list.dasm16
72
0
    
list.dasm16
73
2
2950
5481
2951
000a
    set y, [z+10]
list.dasm16
74
0
    
list.dasm16
75
1
2952
af01
    set push, 10
list.dasm16
76
1
2953
a701
    set push, TYPE_STR
list.dasm16
77
2
2954
7c20
2955
21d3
    jsr alloc
list.dasm16
78
2
2956
0ea1
2957
ffff
    set [z-1], x
list.dasm16
79
0

list.dasm16
80
1
2958
0f01
    set push, x
list.dasm16
81
2
2959
9692
295a
0001
    ife [y + HANDLE_TYPE], TYPE_TUPLE
list.dasm16
82
2
295b
7f01
295c
0028
        set push, '('
list.dasm16
83
2
295d
8e92
295e
0001
    ife [y + HANDLE_TYPE], TYPE_LIST
list.dasm16
84
2
295f
7f01
2960
005b
        set push, '['
list.dasm16
85
2
2961
7c20
2962
27d8
    jsr array__append
list.dasm16
86
0

list.dasm16
87
1
2963
84c1
    set i, 0                    ; index
list.dasm16
88
1
2964
3021
    set b, [y]                    ; struct list *
list.dasm16
89
1
2965
2421
    set b, [b]                    ; list.size
list.dasm16
90
0

list.dasm16
91
0
:list_repr_loop
list.dasm16
92
1
2966
04d2
    ife i, b
list.dasm16
93
2
2967
7f81
2968
2984
        set pc, list_repr_finish
list.dasm16
94
0

list.dasm16
95
1
2969
84d2
    ife i, 0
list.dasm16
96
2
296a
7f81
296b
2972
        set pc, list_repr_skip_comma
list.dasm16
97
0

list.dasm16
98
2
296c
5701
296d
ffff
    set push, [z-1]                    ; struct handle *str
list.dasm16
99
2
296e
7f01
296f
002c
    set push, ','
list.dasm16
100
2
2970
7c20
2971
27d8
    jsr array__append
list.dasm16
101
0

list.dasm16
102
0
:list_repr_skip_comma
list.dasm16
103
1
2972
3061
    set x, [y]                ; struct list *
list.dasm16
104
1
2973
1862
    add x, i                ; current item
list.dasm16
105
0
    
list.dasm16
106
2
2974
4f01
2975
0001
    set push, [x+1]            ; get repr of next item
list.dasm16
107
2
2976
7c20
2977
2086
    jsr repr
list.dasm16
108
2
2978
0ea1
2979
fffe
    set [z-2], x
list.dasm16
109
0
    
list.dasm16
110
2
297a
5701
297b
ffff
    set push, [z-1]
list.dasm16
111
2
297c
5701
297d
fffe
    set push, [z-2]
list.dasm16
112
2
297e
7c20
297f
283b
    jsr array_merge
list.dasm16
113
2
2980
0ea1
2981
ffff
    set [z-1], x
list.dasm16
114
0

list.dasm16
115
2
2982
7f9e
2983
2966
    sti pc, list_repr_loop
list.dasm16
116
0
        
list.dasm16
117
0
:list_repr_finish
list.dasm16
118
2
2984
5701
2985
ffff
    set push, [z-1]
list.dasm16
119
2
2986
9692
2987
0001
    ife [y + HANDLE_TYPE], TYPE_TUPLE
list.dasm16
120
2
2988
7f01
2989
0029
        set push, ')'
list.dasm16
121
2
298a
8e92
298b
0001
    ife [y + HANDLE_TYPE], TYPE_LIST
list.dasm16
122
2
298c
7f01
298d
005d
        set push, ']'
list.dasm16
123
2
298e
7c20
298f
27d8
    jsr array__append
list.dasm16
124
0

list.dasm16
125
2
2990
5461
2991
ffff
    set x, [z-1]
list.dasm16
126
2
2992
7c20
2993
2026
    jsr postamble
string2.dasm16
0
0
;----------------------------------------------------------------
string2.dasm16
1
0
; uint str_cmp(struct handle *left, struct handle *right)
string2.dasm16
2
0
;----------------------------------------------------------------
string2.dasm16
3
0
:str_cmp
string2.dasm16
4
1
2994
6701
    set push, [sp]
string2.dasm16
5
3
2995
7f41
2996
299a
2997
0001
    set [sp + 1], str_comparator
string2.dasm16
6
2
2998
7f81
2999
2862
    set pc, array_cmp
string2.dasm16
7
0

string2.dasm16
8
0
:str_comparator
string2.dasm16
9
1
299a
8461
    set x, 0
string2.dasm16
10
3
299b
6b56
299c
0001
299d
0002
    ifl [sp+2], [sp+1]
string2.dasm16
11
1
299e
8061
        set x, -1
string2.dasm16
12
3
299f
6b54
29a0
0001
29a1
0002
    ifg [sp+2], [sp+1]
string2.dasm16
13
1
29a2
8861
        set x, 1
string2.dasm16
14
0

string2.dasm16
15
1
29a3
6321
    set [sp], pop
string2.dasm16
16
1
29a4
6321
    set [sp], pop
string2.dasm16
17
0

string2.dasm16
18
1
29a5
6381
    set pc, pop
string2.dasm16
19
0
;----------------------------------------------------------------
string2.dasm16
20
0
; uint str_cmp_ignore_case(struct handle *str, struct handle *str)
string2.dasm16
21
0
;----------------------------------------------------------------
string2.dasm16
22
0
:str_cmp_ignore_case
string2.dasm16
23
1
29a6
6701
    set push, [sp]
string2.dasm16
24
3
29a7
7f41
29a8
29ac
29a9
0001
    set [sp + 1], str_comparator__ignore_case
string2.dasm16
25
2
29aa
7f81
29ab
2862
    set pc, array_cmp
string2.dasm16
26
0

string2.dasm16
27
0
:str_comparator__ignore_case
string2.dasm16
28
0
    ; convert upper case letter to lower case
string2.dasm16
29
0

string2.dasm16
30
0
    ; x = toLower(x)
string2.dasm16
31
3
29ac
7f54
29ad
0040
29ae
0002
    ifg [sp+2], 'A'-1
string2.dasm16
32
3
29af
7f56
29b0
005b
29b1
0002
        ifl [sp+2], 'Z'+1
string2.dasm16
33
3
29b2
7f42
29b3
0020
29b4
0002
            add [sp+2], 'a' - 'A'
string2.dasm16
34
0

string2.dasm16
35
0
    ; y = toLower(y)
string2.dasm16
36
3
29b5
7f54
29b6
0040
29b7
0001
    ifg [sp+1], 'A'-1
string2.dasm16
37
3
29b8
7f56
29b9
005b
29ba
0001
        ifl [sp+1], 'Z'+1
string2.dasm16
38
3
29bb
7f42
29bc
0020
29bd
0001
            add [sp+1], 'a' - 'A'
string2.dasm16
39
0

string2.dasm16
40
2
29be
7f81
29bf
299a
    set pc, str_comparator
string2.dasm16
41
0

string2.dasm16
42
0
;----------------------------------------------------------------
string2.dasm16
43
0
; uint str_search_3(struct handle *haystack, struct handle *needle, uint16 start, uint16 end)
string2.dasm16
44
0
;----------------------------------------------------------------
string2.dasm16
45
0
:str_search_3
string2.dasm16
46
1
29c0
9701
    set push, 4
string2.dasm16
47
1
29c1
8701
    set push, 0
string2.dasm16
48
2
29c2
7c20
29c3
2039
    jsr preamble
string2.dasm16
49
0

string2.dasm16
50
2
29c4
5401
29c5
000d
    set a, [z+13]    ; struct handle *haystack    
string2.dasm16
51
1
29c6
2001
    set a, [a]
string2.dasm16
52
0

string2.dasm16
53
2
29c7
5461
29c8
000b
    set x, [z+11]
string2.dasm16
54
1
29c9
8477
    ifu x, 0
string2.dasm16
55
1
29ca
2062
        add x, [a]
string2.dasm16
56
1
29cb
8477
    ifu x, 0
string2.dasm16
57
1
29cc
0c63
        sub x, x
string2.dasm16
58
1
29cd
2075
    ifa x, [a]
string2.dasm16
59
1
29ce
2061
        set x, [a]
string2.dasm16
60
0
        
string2.dasm16
61
2
29cf
5701
29d0
000a
    set push, [z+10]
string2.dasm16
62
1
29d1
8737
    ifu [sp], 0
string2.dasm16
63
1
29d2
2322
        add [sp], [a]
string2.dasm16
64
1
29d3
8737
    ifu [sp], 0
string2.dasm16
65
1
29d4
6723
        sub [sp], [sp]
string2.dasm16
66
1
29d5
2335
    ifa [sp], [a]
string2.dasm16
67
1
29d6
2321
        set [sp], [a]
string2.dasm16
68
0
    
string2.dasm16
69
2
29d7
5421
29d8
000c
    set b, [z+12]    ; struct handle *needle
string2.dasm16
70
1
29d9
2421
    set b, [b]
string2.dasm16
71
0

string2.dasm16
72
1
29da
0481
    set y, b    ; needle last char *
string2.dasm16
73
1
29db
2482
    add y, [b]
string2.dasm16
74
0

string2.dasm16
75
2
29dc
7f81
29dd
29ec
    set pc, str_search_outer_loop
string2.dasm16
76
0

string2.dasm16
77
0
;----------------------------------------------------------------
string2.dasm16
78
0
; uint str_cmp(struct handle *haystack, struct handle *needle)
string2.dasm16
79
0
;----------------------------------------------------------------
string2.dasm16
80
0
:str_search
string2.dasm16
81
1
29de
8f01
    set push, 2
string2.dasm16
82
1
29df
8701
    set push, 0
string2.dasm16
83
2
29e0
7c20
29e1
2039
    jsr preamble
string2.dasm16
84
0

string2.dasm16
85
1
29e2
8461
    set x, 0    ; haystack walker
string2.dasm16
86
0

string2.dasm16
87
2
29e3
5401
29e4
000b
    set a, [z+11]    ; struct handle *haystack    
string2.dasm16
88
1
29e5
2001
    set a, [a]
string2.dasm16
89
1
29e6
2301
    set push, [a]
string2.dasm16
90
0

string2.dasm16
91
2
29e7
5421
29e8
000a
    set b, [z+10]    ; struct handle *needle
string2.dasm16
92
1
29e9
2421
    set b, [b]
string2.dasm16
93
0

string2.dasm16
94
1
29ea
0481
    set y, b    ; needle last char *
string2.dasm16
95
1
29eb
2482
    add y, [b]
string2.dasm16
96
0

string2.dasm16
97
0
:str_search_outer_loop
string2.dasm16
98
1
29ec
0c41
    set c, x    ; haystack_walker + needle_len <= haystack_len
string2.dasm16
99
1
29ed
2442
    add c, [b]
string2.dasm16
100
1
29ee
6454
    ifg c, [sp]
string2.dasm16
101
2
29ef
7f81
29f0
2a00
        set pc, str_search_no_match
string2.dasm16
102
0

string2.dasm16
103
1
29f1
00c1
    set i, a    ; target[i+j]
string2.dasm16
104
1
29f2
0cc2
    add i, x
string2.dasm16
105
0

string2.dasm16
106
1
29f3
04e1
    set j, b    ; query[j]
string2.dasm16
107
0

string2.dasm16
108
0
:str_search_inner_loop
string2.dasm16
109
3
29f4
5ed2
29f5
0001
29f6
0001
    ife [i+1], [j+1]    ; target[i+j]==query[j]
string2.dasm16
110
1
29f7
10f6
        ifl j, y    ; j < queryLen
string2.dasm16
111
2
29f8
7f9e
29f9
29f4
            sti pc, str_search_inner_loop    ; j++
string2.dasm16
112
0

string2.dasm16
113
1
29fa
10f2
    ife j, y
string2.dasm16
114
2
29fb
7c20
29fc
2026
        jsr postamble
string2.dasm16
115
0

string2.dasm16
116
1
29fd
8862
    add x, 1
string2.dasm16
117
2
29fe
7f81
29ff
29ec
    set pc, str_search_outer_loop
string2.dasm16
118
0

string2.dasm16
119
0
:str_search_no_match
string2.dasm16
120
1
2a00
8061
    set x, -1
string2.dasm16
121
2
2a01
7c20
2a02
2026
    jsr postamble
string2.dasm16
122
0

string2.dasm16
123
0
;----------------------------------------------------------------
string2.dasm16
124
0
:built_in__str_isalpha
string2.dasm16
125
0
;----------------------------------------------------------------
string2.dasm16
126
2
2a03
7c20
2a04
10e2
    jsr built_in__object_method__init
string2.dasm16
127
0

string2.dasm16
128
1
2a05
84d3
    ifn i, 0
string2.dasm16
129
2
2a06
7c20
2a07
00c6
        jsr recover
string2.dasm16
130
0

string2.dasm16
131
1
2a08
20c1
    set i, [a]
string2.dasm16
132
0

string2.dasm16
133
1
2a09
85d2
    ife [i], 0
string2.dasm16
134
2
2a0a
7f81
2a0b
2181
        set pc, return_false
string2.dasm16
135
0

string2.dasm16
136
1
2a0c
38c2
    add i, [i]
string2.dasm16
137
0

string2.dasm16
138
0
:built_in__str_isalpha_loop
string2.dasm16
139
1
2a0d
20d2
    ife i, [a]
string2.dasm16
140
2
2a0e
7f81
2a0f
217d
        set pc, return_true
string2.dasm16
141
0

string2.dasm16
142
2
2a10
7dd4
2a11
0040
    ifg [i], 'A'-1
string2.dasm16
143
2
2a12
7dd6
2a13
005b
        ifl [i], 'Z'+1
string2.dasm16
144
2
2a14
7f9f
2a15
2a0d
            std pc, built_in__str_isalpha_loop
string2.dasm16
145
0

string2.dasm16
146
2
2a16
7dd4
2a17
0060
    ifg [i], 'a'-1
string2.dasm16
147
2
2a18
7dd6
2a19
007b
        ifl [i], 'z'+1
string2.dasm16
148
2
2a1a
7f9f
2a1b
2a0d
            std pc, built_in__str_isalpha_loop
string2.dasm16
149
0

string2.dasm16
150
2
2a1c
7f81
2a1d
2181
    set pc, return_false
string2.dasm16
151
0

string2.dasm16
152
0
;----------------------------------------------------------------
string2.dasm16
153
0
:built_in__str_isdigit
string2.dasm16
154
0
;----------------------------------------------------------------
string2.dasm16
155
2
2a1e
7c20
2a1f
10e2
    jsr built_in__object_method__init
string2.dasm16
156
0

string2.dasm16
157
1
2a20
84d3
    ifn i, 0
string2.dasm16
158
2
2a21
7c20
2a22
00c6
        jsr recover
string2.dasm16
159
0

string2.dasm16
160
1
2a23
20c1
    set i, [a]
string2.dasm16
161
0
    
string2.dasm16
162
1
2a24
85d2
    ife [i], 0
string2.dasm16
163
2
2a25
7f81
2a26
2181
        set pc, return_false
string2.dasm16
164
0
    
string2.dasm16
165
1
2a27
38c2
    add i, [i]
string2.dasm16
166
0

string2.dasm16
167
0
:built_in__str_isdigit_loop
string2.dasm16
168
1
2a28
20d2
    ife i, [a]
string2.dasm16
169
2
2a29
7f81
2a2a
217d
        set pc, return_true
string2.dasm16
170
0
        
string2.dasm16
171
2
2a2b
7dd4
2a2c
002f
    ifg [i], '0'-1
string2.dasm16
172
2
2a2d
7dd6
2a2e
003a
        ifl [i], '9'+1
string2.dasm16
173
2
2a2f
7f9f
2a30
2a28
            std pc, built_in__str_isdigit_loop
string2.dasm16
174
0
        
string2.dasm16
175
2
2a31
7f81
2a32
2181
    set pc, return_false
string2.dasm16
176
0

string2.dasm16
177
0
;----------------------------------------------------------------
string2.dasm16
178
0
:built_in__str_lower
string2.dasm16
179
0
;----------------------------------------------------------------
string2.dasm16
180
2
2a33
7c20
2a34
10e2
    jsr built_in__object_method__init
string2.dasm16
181
0

string2.dasm16
182
1
2a35
84d3
    ifn i, 0
string2.dasm16
183
2
2a36
7c20
2a37
00c6
        jsr recover
string2.dasm16
184
0

string2.dasm16
185
1
2a38
0301
    set push, a
string2.dasm16
186
2
2a39
7c20
2a3a
28ca
    jsr array_clone
string2.dasm16
187
0
    
string2.dasm16
188
1
2a3b
2cc1
    set i, [x]
string2.dasm16
189
1
2a3c
38c2
    add i, [i]
string2.dasm16
190
0

string2.dasm16
191
0
:built_in__str_lower_loop
string2.dasm16
192
1
2a3d
2cd2
    ife i, [x]
string2.dasm16
193
2
2a3e
7f81
2a3f
2026
        set pc, postamble
string2.dasm16
194
0

string2.dasm16
195
2
2a40
7dd4
2a41
0040
    ifg [i], 'A'-1
string2.dasm16
196
2
2a42
7dd6
2a43
005b
        ifl [i], 'Z'+1
string2.dasm16
197
2
2a44
7dc2
2a45
0020
            add [i], ('a'-'A')
string2.dasm16
198
0

string2.dasm16
199
2
2a46
7f9f
2a47
2a3d
    std pc, built_in__str_lower_loop
string2.dasm16
200
0
    
string2.dasm16
201
2
2a48
7f81
2a49
2026
    set pc, postamble
string2.dasm16
202
0

string2.dasm16
203
0
;----------------------------------------------------------------
string2.dasm16
204
0
:built_in__str_upper
string2.dasm16
205
0
;----------------------------------------------------------------
string2.dasm16
206
2
2a4a
7c20
2a4b
10e2
    jsr built_in__object_method__init
string2.dasm16
207
0

string2.dasm16
208
1
2a4c
84d3
    ifn i, 0
string2.dasm16
209
2
2a4d
7c20
2a4e
00c6
        jsr recover
string2.dasm16
210
0

string2.dasm16
211
1
2a4f
0301
    set push, a
string2.dasm16
212
2
2a50
7c20
2a51
28ca
    jsr array_clone
string2.dasm16
213
0
    
string2.dasm16
214
1
2a52
2cc1
    set i, [x]
string2.dasm16
215
1
2a53
38c2
    add i, [i]
string2.dasm16
216
0

string2.dasm16
217
0
:built_in__str_upper_loop
string2.dasm16
218
1
2a54
2cd2
    ife i, [x]
string2.dasm16
219
2
2a55
7f81
2a56
2026
        set pc, postamble
string2.dasm16
220
0

string2.dasm16
221
2
2a57
7dd4
2a58
0060
    ifg [i], 'a'-1
string2.dasm16
222
2
2a59
7dd6
2a5a
007b
        ifl [i], 'z'+1
string2.dasm16
223
2
2a5b
7dc3
2a5c
0020
            sub [i], ('a'-'A')
string2.dasm16
224
0

string2.dasm16
225
2
2a5d
7f9f
2a5e
2a54
    std pc, built_in__str_upper_loop
string2.dasm16
226
0

string2.dasm16
227
0
;----------------------------------------------------------------
string2.dasm16
228
0
:built_in__str_find
string2.dasm16
229
0
;----------------------------------------------------------------
string2.dasm16
230
2
2a5f
7c20
2a60
10e2
    jsr built_in__object_method__init
string2.dasm16
231
0

string2.dasm16
232
1
2a61
0301
    set push, a
string2.dasm16
233
1
2a62
2001
    set a, [a]
string2.dasm16
234
0

string2.dasm16
235
1
2a63
84d2
    ife i, 0
string2.dasm16
236
2
2a64
7c20
2a65
00c6
        jsr recover
string2.dasm16
237
0
        
string2.dasm16
238
1
2a66
90d4
    ifg i, 3
string2.dasm16
239
2
2a67
7c20
2a68
00c6
        jsr recover
string2.dasm16
240
0

string2.dasm16
241
2
2a69
5461
2a6a
ffff
    set x, [z-1]
string2.dasm16
242
2
2a6b
a673
2a6c
0001
    ifn [x + HANDLE_TYPE], TYPE_STR
string2.dasm16
243
2
2a6d
7c20
2a6e
00c6
        jsr recover
string2.dasm16
244
0

string2.dasm16
245
1
2a6f
0f01
    set push, x
string2.dasm16
246
0
        
string2.dasm16
247
1
2a70
88d2
    ife i, 1
string2.dasm16
248
2
2a71
7f81
2a72
2a8e
        set pc, built_in__str_find__no_start
string2.dasm16
249
0

string2.dasm16
250
2
2a73
5461
2a74
fffe
    set x, [z-2]
string2.dasm16
251
3
2a75
7e73
2a76
0020
2a77
0001
    ifn [x + HANDLE_TYPE], TYPE_INT
string2.dasm16
252
2
2a78
7c20
2a79
00c6
        jsr recover
string2.dasm16
253
0
        
string2.dasm16
254
1
2a7a
0f01
    set push, x
string2.dasm16
255
2
2a7b
7c20
2a7c
22bc
    jsr int_to_int16
string2.dasm16
256
1
2a7d
0f01
    set push, x
string2.dasm16
257
0
    
string2.dasm16
258
1
2a7e
8cd2
    ife i, 2
string2.dasm16
259
2
2a7f
7f81
2a80
2a8f
        set pc, built_in__str_find__no_end
string2.dasm16
260
0

string2.dasm16
261
2
2a81
5461
2a82
fffd
    set x, [z-3]
string2.dasm16
262
3
2a83
7e73
2a84
0020
2a85
0001
    ifn [x + HANDLE_TYPE], TYPE_INT
string2.dasm16
263
2
2a86
7c20
2a87
00c6
        jsr recover
string2.dasm16
264
0
        
string2.dasm16
265
1
2a88
0f01
    set push, x
string2.dasm16
266
2
2a89
7c20
2a8a
22bc
    jsr int_to_int16
string2.dasm16
267
1
2a8b
0f01
    set push, x
string2.dasm16
268
0
    
string2.dasm16
269
2
2a8c
7f81
2a8d
2a90
    set pc, built_in__str_find__finish
string2.dasm16
270
0

string2.dasm16
271
0
:built_in__str_find__no_start
string2.dasm16
272
1
2a8e
8701
    set push, 0
string2.dasm16
273
0

string2.dasm16
274
0
:built_in__str_find__no_end
string2.dasm16
275
1
2a8f
2301
    set push, [a]
string2.dasm16
276
0
    
string2.dasm16
277
0
:built_in__str_find__finish
string2.dasm16
278
2
2a90
7c20
2a91
29c0
    jsr str_search_3
string2.dasm16
279
0
    
string2.dasm16
280
1
2a92
0f01
    set push, x
string2.dasm16
281
2
2a93
7c61
2a94
029f
    set x, INT_N1
string2.dasm16
282
0

string2.dasm16
283
2
2a95
7f31
2a96
8000
    ifc peek, 0x8000
string2.dasm16
284
2
2a97
7c20
2a98
22a2
        jsr uint16_to_int
string2.dasm16
285
0
    
string2.dasm16
286
2
2a99
7f81
2a9a
2026
    set pc, postamble    
string2.dasm16
287
0

string2.dasm16
288
0
;----------------------------------------------------------------
string2.dasm16
289
0
:built_in__str_endswith
string2.dasm16
290
0
;----------------------------------------------------------------
string2.dasm16
291
2
2a9b
7c81
2a9c
2acf
    set y, built_in__str_endswith__cmp 
string2.dasm16
292
2
2a9d
7f81
2a9e
2aa1
    set pc, built_in__str_xwith
string2.dasm16
293
0

string2.dasm16
294
0
;----------------------------------------------------------------
string2.dasm16
295
0
:built_in__str_startswith
string2.dasm16
296
0
;----------------------------------------------------------------
string2.dasm16
297
2
2a9f
7c81
2aa0
2ac3
    set y, built_in__str_startswith__cmp 
string2.dasm16
298
0

string2.dasm16
299
0
:built_in__str_xwith
string2.dasm16
300
2
2aa1
7c20
2aa2
10e2
    jsr built_in__object_method__init
string2.dasm16
301
0
    
string2.dasm16
302
1
2aa3
88d3
    ifn i, 1
string2.dasm16
303
2
2aa4
7c20
2aa5
00c6
        jsr recover
string2.dasm16
304
0
    
string2.dasm16
305
2
2aa6
5421
2aa7
ffff
    set b, [z-1]
string2.dasm16
306
2
2aa8
a630
2aa9
0001
    ifb [b + HANDLE_TYPE], TYPE_STR
string2.dasm16
307
2
2aaa
7f81
2aab
2ac0
        set pc, built_in__str_xwith__str
string2.dasm16
308
0

string2.dasm16
309
2
2aac
9e30
2aad
0001
    ifb [b + HANDLE_TYPE], TYPE_TUPLE + TYPE_LIST
string2.dasm16
310
2
2aae
7f81
2aaf
2ab2
        set pc, built_in__str_xwith__array
string2.dasm16
311
0

string2.dasm16
312
2
2ab0
7c20
2ab1
00c6
    jsr recover
string2.dasm16
313
0

string2.dasm16
314
0
:built_in__str_xwith__array
string2.dasm16
315
1
2ab2
2441
    set c, [b]
string2.dasm16
316
1
2ab3
08c1
    set i, c
string2.dasm16
317
1
2ab4
38c2
    add i, [i]
string2.dasm16
318
0

string2.dasm16
319
0
:built_in__str_xwith__array_loop
string2.dasm16
320
1
2ab5
08d2
    ife i, c
string2.dasm16
321
2
2ab6
7f81
2ab7
2181
        set pc, return_false
string2.dasm16
322
0
    
string2.dasm16
323
1
2ab8
3821
    set b, [i]
string2.dasm16
324
2
2ab9
a633
2aba
0001
    ifn [b + HANDLE_TYPE], TYPE_STR
string2.dasm16
325
2
2abb
7c20
2abc
00c6
        jsr recover
string2.dasm16
326
0
        
string2.dasm16
327
1
2abd
1020
    jsr y
string2.dasm16
328
0

string2.dasm16
329
2
2abe
7f9f
2abf
2ab5
    std pc, built_in__str_xwith__array_loop
string2.dasm16
330
0
    
string2.dasm16
331
0
:built_in__str_xwith__str
string2.dasm16
332
1
2ac0
1020
    jsr y
string2.dasm16
333
0

string2.dasm16
334
2
2ac1
7f81
2ac2
2181
    set pc, return_false
string2.dasm16
335
0
    
string2.dasm16
336
0
:built_in__str_startswith__cmp
string2.dasm16
337
1
2ac3
0301
    set push, a
string2.dasm16
338
1
2ac4
0701
    set push, b
string2.dasm16
339
1
2ac5
8701
    set push, 0
string2.dasm16
340
0

string2.dasm16
341
1
2ac6
2461
    set x, [b]
string2.dasm16
342
1
2ac7
2f01
    set push, [x]
string2.dasm16
343
2
2ac8
7c20
2ac9
29c0
    jsr str_search_3
string2.dasm16
344
1
2aca
8472
    ife x, 0
string2.dasm16
345
2
2acb
7f81
2acc
217d
        set pc, return_true
string2.dasm16
346
0
    
string2.dasm16
347
1
2acd
8461
    set x, FALSE
string2.dasm16
348
1
2ace
6381
    set pc, pop
string2.dasm16
349
0

string2.dasm16
350
0
:built_in__str_endswith__cmp
string2.dasm16
351
1
2acf
0301
    set push, a
string2.dasm16
352
1
2ad0
0701
    set push, b
string2.dasm16
353
0

string2.dasm16
354
1
2ad1
2461
    set x, [b]
string2.dasm16
355
1
2ad2
2f01
    set push, [x]
string2.dasm16
356
1
2ad3
832c
    xor [sp], 0xffff
string2.dasm16
357
1
2ad4
8b22
    add [sp], 1    
string2.dasm16
358
0
    
string2.dasm16
359
2
2ad5
7f01
2ad6
7fff
    set push, 0x7fff
string2.dasm16
360
2
2ad7
7c20
2ad8
29c0
    jsr str_search_3
string2.dasm16
361
1
2ad9
8073
    ifn x, -1
string2.dasm16
362
2
2ada
7f81
2adb
217d
        set pc, return_true
string2.dasm16
363
0
    
string2.dasm16
364
1
2adc
8461
    set x, FALSE
string2.dasm16
365
1
2add
6381
    set pc, pop
string2.dasm16
366
0

string2.dasm16
367
0
;----------------------------------------------------------------
string2.dasm16
368
0
:built_in__str_decrypt
string2.dasm16
369
0
;----------------------------------------------------------------
string2.dasm16
370
2
2ade
7c20
2adf
10e2
    jsr built_in__object_method__init
string2.dasm16
371
0
    
string2.dasm16
372
1
2ae0
88d3
    ifn i, 1
string2.dasm16
373
2
2ae1
7c20
2ae2
00c6
        jsr recover
string2.dasm16
374
0
    
string2.dasm16
375
1
2ae3
0301
    set push, a
string2.dasm16
376
2
2ae4
7c20
2ae5
28ca
    jsr array_clone
string2.dasm16
377
2
2ae6
0ea1
2ae7
fffe
    set [z-2], x
string2.dasm16
378
0

string2.dasm16
379
2
2ae8
7c81
2ae9
32dd
    set y, crypt__Decrypt
string2.dasm16
380
0
    
string2.dasm16
381
2
2aea
7f81
2aeb
2b05
    set pc, built_in__str_crypt
string2.dasm16
382
0

string2.dasm16
383
0
;----------------------------------------------------------------
string2.dasm16
384
0
:built_in__str_encrypt
string2.dasm16
385
0
;----------------------------------------------------------------
string2.dasm16
386
2
2aec
7c20
2aed
10e2
    jsr built_in__object_method__init
string2.dasm16
387
0
    
string2.dasm16
388
1
2aee
88d3
    ifn i, 1
string2.dasm16
389
2
2aef
7c20
2af0
00c6
        jsr recover
string2.dasm16
390
0
    
string2.dasm16
391
1
2af1
0301
    set push, a
string2.dasm16
392
2
2af2
7c20
2af3
28ca
    jsr array_clone
string2.dasm16
393
2
2af4
0ea1
2af5
fffe
    set [z-2], x
string2.dasm16
394
0

string2.dasm16
395
2
2af6
7801
2af7
0255
    set a, [heap_handle_start]
string2.dasm16
396
1
2af8
0021
    set b, a
string2.dasm16
397
1
2af9
c422
    add b, 16
string2.dasm16
398
0
    
string2.dasm16
399
0
    :built_in__str_encrypt__iv_loop    
string2.dasm16
400
1
2afa
9423
        sub b, 4
string2.dasm16
401
0
    
string2.dasm16
402
2
2afb
5701
2afc
fffe
        set push, [z-2]
string2.dasm16
403
1
2afd
2701
        set push, [b]
string2.dasm16
404
2
2afe
7c20
2aff
27d8
        jsr array__append    
string2.dasm16
405
0
    
string2.dasm16
406
1
2b00
0034
        ifg b, a
string2.dasm16
407
2
2b01
7f81
2b02
2afa
            set pc, built_in__str_encrypt__iv_loop
string2.dasm16
408
0

string2.dasm16
409
2
2b03
7c81
2b04
3281
    set y, crypt__Encrypt
string2.dasm16
410
0

string2.dasm16
411
0
:built_in__str_crypt
string2.dasm16
412
0
    ; IV    
string2.dasm16
413
2
2b05
5401
2b06
fffe
    set a, [z-2]
string2.dasm16
414
1
2b07
2001
    set a, [a]
string2.dasm16
415
0

string2.dasm16
416
1
2b08
9503
    sub [a], 4            ; cut IV [:-4]
string2.dasm16
417
1
2b09
2301
    set push, [a]        ; msg.len    
string2.dasm16
418
0
    
string2.dasm16
419
1
2b0a
2002
    add a, [a]
string2.dasm16
420
1
2b0b
8802
    add a, 1            ; IV[0]
string2.dasm16
421
0

string2.dasm16
422
0
    ; msg
string2.dasm16
423
2
2b0c
5441
2b0d
fffe
    set c, [z-2]
string2.dasm16
424
1
2b0e
2841
    set c, [c]
string2.dasm16
425
1
2b0f
8842
    add c, 1            ; msg[0]
string2.dasm16
426
0

string2.dasm16
427
0
    ; key
string2.dasm16
428
2
2b10
5421
2b11
ffff
    set b, [z-1]
string2.dasm16
429
1
2b12
2421
    set b, [b]
string2.dasm16
430
0
    
string2.dasm16
431
1
2b13
a533
    ifn [b], 8
string2.dasm16
432
2
2b14
7c20
2b15
00c6
        jsr recover
string2.dasm16
433
0
        
string2.dasm16
434
1
2b16
8822
    add b, 1            ; key[0]
string2.dasm16
435
0
    
string2.dasm16
436
1
2b17
1020
    jsr y
string2.dasm16
437
0

string2.dasm16
438
2
2b18
5461
2b19
fffe
    set x, [z-2]
string2.dasm16
439
2
2b1a
7c92
2b1b
32dd
    ife y, crypt__Decrypt
string2.dasm16
440
2
2b1c
7f81
2b1d
2026
        set pc, postamble    
string2.dasm16
441
0

string2.dasm16
442
1
2b1e
2c01
    set a, [x]
string2.dasm16
443
1
2b1f
9502
    add [a], 4
string2.dasm16
444
0
    
string2.dasm16
445
2
2b20
7f81
2b21
2026
    set pc, postamble    
string2.dasm16
446
0

string2.dasm16
447
0
;----------------------------------------------------------------
string2.dasm16
448
0
:built_in__str_replace
string2.dasm16
449
0
;----------------------------------------------------------------
string2.dasm16
450
2
2b22
7c20
2b23
10e2
    jsr built_in__object_method__init
string2.dasm16
451
1
2b24
8cd3
    ifn i, 2
string2.dasm16
452
2
2b25
7c20
2b26
00c6
        jsr recover
string2.dasm16
453
0

string2.dasm16
454
2
2b27
5461
2b28
ffff
    set x, [z-1]            ; search str
string2.dasm16
455
2
2b29
a671
2b2a
0001
    ifc [x + HANDLE_TYPE], TYPE_STR
string2.dasm16
456
2
2b2b
7c20
2b2c
00c6
        jsr recover
string2.dasm16
457
0

string2.dasm16
458
1
2b2d
2c41
    set c, [x]
string2.dasm16
459
1
2b2e
2841
    set c, [c]
string2.dasm16
460
0

string2.dasm16
461
2
2b2f
5461
2b30
fffe
    set x, [z-2]            ; replace str
string2.dasm16
462
2
2b31
a671
2b32
0001
    ifc [x + HANDLE_TYPE], TYPE_STR
string2.dasm16
463
2
2b33
7c20
2b34
00c6
        jsr recover
string2.dasm16
464
0
        
string2.dasm16
465
2
2b35
02a1
2b36
fffd
    set [z-3], a            ; src str
string2.dasm16
466
0

string2.dasm16
467
2
2b37
4301
2b38
0002
    set push, [a + HANDLE_SIZE]
string2.dasm16
468
1
2b39
a701
    set push, TYPE_STR
string2.dasm16
469
2
2b3a
7c20
2b3b
21d3
    jsr alloc
string2.dasm16
470
2
2b3c
0ea1
2b3d
fffc
    set [z-4], x            ; dst str
string2.dasm16
471
0

string2.dasm16
472
0
    ; [z-1] old
string2.dasm16
473
0
    ; [z-2] new
string2.dasm16
474
0
    ; [z-3] src
string2.dasm16
475
0
    ; [z-4] dst
string2.dasm16
476
0

string2.dasm16
477
1
2b3e
84c1
    set i, 0                ; cpos
string2.dasm16
478
0

string2.dasm16
479
0
:built_in__str_replace__loop_restart
string2.dasm16
480
2
2b3f
5701
2b40
fffd
    set push, [z-3]            ; src
string2.dasm16
481
2
2b41
5701
2b42
ffff
    set push, [z-1]            ; search
string2.dasm16
482
1
2b43
1b01
    set push, i
string2.dasm16
483
2
2b44
7f01
2b45
7fff
    set push, 0x7fff
string2.dasm16
484
2
2b46
7c20
2b47
29c0
    jsr str_search_3
string2.dasm16
485
1
2b48
0ce1
    set j, x                ; npos
string2.dasm16
486
0

string2.dasm16
487
0
:built_in__str_replace__loop
string2.dasm16
488
1
2b49
1cd2
    ife i, j
string2.dasm16
489
2
2b4a
7f81
2b4b
2b5c
        set pc, built_in__str_replace__do_replace
string2.dasm16
490
0

string2.dasm16
491
0
    ; copy char from src to dst
string2.dasm16
492
2
2b4c
5401
2b4d
fffd
    set a, [z-3]
string2.dasm16
493
1
2b4e
1821
    set b, i
string2.dasm16
494
2
2b4f
7c20
2b50
277f
    jsr array__get
string2.dasm16
495
1
2b51
8472
    ife x, 0
string2.dasm16
496
2
2b52
7f81
2b53
2b65
        set pc, built_in__str_replace__finish
string2.dasm16
497
0

string2.dasm16
498
2
2b54
5701
2b55
fffc
    set push, [z-4]
string2.dasm16
499
1
2b56
0f01
    set push, x
string2.dasm16
500
2
2b57
7c20
2b58
27d8
    jsr array__append
string2.dasm16
501
0
    
string2.dasm16
502
1
2b59
88c2
    add i, 1
string2.dasm16
503
2
2b5a
7f81
2b5b
2b49
    set pc, built_in__str_replace__loop
string2.dasm16
504
0

string2.dasm16
505
0
:built_in__str_replace__do_replace
string2.dasm16
506
2
2b5c
5701
2b5d
fffc
    set push, [z-4]
string2.dasm16
507
2
2b5e
5701
2b5f
fffe
    set push, [z-2]
string2.dasm16
508
2
2b60
7c20
2b61
27e7
    jsr array__append_array
string2.dasm16
509
0

string2.dasm16
510
1
2b62
08c2
    add i, c
string2.dasm16
511
0

string2.dasm16
512
2
2b63
7f81
2b64
2b3f
    set pc, built_in__str_replace__loop_restart
string2.dasm16
513
0

string2.dasm16
514
0
:built_in__str_replace__finish    
string2.dasm16
515
2
2b65
5461
2b66
fffc
    set x, [z-4]
string2.dasm16
516
2
2b67
7f81
2b68
2026
    set pc, postamble    
string2.dasm16
517
0

string2.dasm16
518
0
;----------------------------------------------------------------
string2.dasm16
519
0
:built_in__str_split
string2.dasm16
520
0
;----------------------------------------------------------------
string2.dasm16
521
2
2b69
7c20
2b6a
10e2
    jsr built_in__object_method__init
string2.dasm16
522
0

string2.dasm16
523
2
2b6b
02a1
2b6c
fffe
    set [z-2], a
string2.dasm16
524
0

string2.dasm16
525
1
2b6d
af01
    set push, 10
string2.dasm16
526
1
2b6e
8f01
    set push, TYPE_LIST
string2.dasm16
527
2
2b6f
7c20
2b70
21d3
    jsr alloc
string2.dasm16
528
2
2b71
0ea1
2b72
fffd
    set [z-3], x            ; return list
string2.dasm16
529
0

string2.dasm16
530
1
2b73
8421
    set b, 0                ; cpos
string2.dasm16
531
0

string2.dasm16
532
1
2b74
84d2
    ife i, 0
string2.dasm16
533
2
2b75
7f81
2b76
2ba6
        set pc, built_in__str_split__ws
string2.dasm16
534
1
2b77
88d3
    ifn i, 1
string2.dasm16
535
2
2b78
7c20
2b79
00c6
        jsr recover
string2.dasm16
536
0

string2.dasm16
537
0
    ; str split with defined separator
string2.dasm16
538
2
2b7a
5461
2b7b
ffff
    set x, [z-1]            ; sep str
string2.dasm16
539
2
2b7c
a671
2b7d
0001
    ifc [x + HANDLE_TYPE], TYPE_STR
string2.dasm16
540
2
2b7e
7c20
2b7f
00c6
        jsr recover
string2.dasm16
541
0

string2.dasm16
542
1
2b80
2c41
    set c, [x]
string2.dasm16
543
1
2b81
2841
    set c, [c]                ; sep.len
string2.dasm16
544
0

string2.dasm16
545
0
:built_in__str_split__loop
string2.dasm16
546
2
2b82
5701
2b83
fffe
    set push, [z-2]
string2.dasm16
547
2
2b84
5701
2b85
ffff
    set push, [z-1]
string2.dasm16
548
1
2b86
0701
    set push, b
string2.dasm16
549
2
2b87
7f01
2b88
7fff
    set push, 0x7fff
string2.dasm16
550
2
2b89
7c20
2b8a
29c0
    jsr str_search_3
string2.dasm16
551
1
2b8b
0ce1
    set j, x                ; npos
string2.dasm16
552
0

string2.dasm16
553
1
2b8c
80f2
    ife j, -1
string2.dasm16
554
2
2b8d
7ce1
2b8e
7fff
        set j, 0x7fff
string2.dasm16
555
0

string2.dasm16
556
2
2b8f
5701
2b90
fffe
    set push, [z-2]
string2.dasm16
557
1
2b91
0701
    set push, b
string2.dasm16
558
1
2b92
1f01
    set push, j
string2.dasm16
559
2
2b93
7c20
2b94
280e
    jsr array_split
string2.dasm16
560
2
2b95
0ea1
2b96
fffc
    set [z-4], x
string2.dasm16
561
0
    
string2.dasm16
562
1
2b97
1c21
    set b, j
string2.dasm16
563
0
    
string2.dasm16
564
2
2b98
5701
2b99
fffd
    set push, [z-3]
string2.dasm16
565
1
2b9a
0f01
    set push, x
string2.dasm16
566
2
2b9b
7c20
2b9c
27d8
    jsr array__append
string2.dasm16
567
0

string2.dasm16
568
2
2b9d
5461
2b9e
fffd
    set x, [z-3]
string2.dasm16
569
2
2b9f
7cf2
2ba0
7fff
    ife j, 0x7fff
string2.dasm16
570
2
2ba1
7f81
2ba2
2026
        set pc, postamble    
string2.dasm16
571
0

string2.dasm16
572
1
2ba3
0822
    add b, c
string2.dasm16
573
2
2ba4
7f81
2ba5
2b82
    set pc, built_in__str_split__loop
string2.dasm16
574
0

string2.dasm16
575
0
:built_in__str_split__ws
string2.dasm16
576
0
    ; [z-1] is used as str nursery
string2.dasm16
577
0
    ; [z-2] original str
string2.dasm16
578
0
    ; [z-3] list
string2.dasm16
579
2
2ba6
7c20
2ba7
277f
    jsr array__get
string2.dasm16
580
0
    
string2.dasm16
581
1
2ba8
8822
    add b, 1
string2.dasm16
582
0
    
string2.dasm16
583
1
2ba9
8472
    ife x, 0
string2.dasm16
584
2
2baa
7f81
2bab
2bd3
        set pc, built_in__str_split__ws_finish
string2.dasm16
585
0

string2.dasm16
586
2
2bac
7c72
2bad
0020
    ife x, ' '
string2.dasm16
587
2
2bae
7f81
2baf
2bc5
        set pc, built_in__str_split__ws__handle_ws
string2.dasm16
588
1
2bb0
c872
    ife x, 0x11
string2.dasm16
589
2
2bb1
7f81
2bb2
2bc5
        set pc, built_in__str_split__ws__handle_ws
string2.dasm16
590
0
        
string2.dasm16
591
0
    ; handle text
string2.dasm16
592
1
2bb3
0c41
    set c, x
string2.dasm16
593
2
2bb4
86b3
2bb5
ffff
    ifn [z-1], 0
string2.dasm16
594
2
2bb6
7f81
2bb7
2bbe
        set pc, built_in__str_split__ws__add_char
string2.dasm16
595
0

string2.dasm16
596
1
2bb8
9f01
    set push, 6
string2.dasm16
597
1
2bb9
a701
    set push, TYPE_STR
string2.dasm16
598
2
2bba
7c20
2bbb
21d3
    jsr alloc
string2.dasm16
599
2
2bbc
0ea1
2bbd
ffff
    set [z-1], x
string2.dasm16
600
0

string2.dasm16
601
0
:built_in__str_split__ws__add_char
string2.dasm16
602
2
2bbe
5701
2bbf
ffff
    set push, [z-1]
string2.dasm16
603
1
2bc0
0b01
    set push, c
string2.dasm16
604
2
2bc1
7c20
2bc2
27d8
    jsr array__append
string2.dasm16
605
2
2bc3
7f81
2bc4
2ba6
    set pc, built_in__str_split__ws
string2.dasm16
606
0

string2.dasm16
607
0
:built_in__str_split__ws__handle_ws
string2.dasm16
608
2
2bc5
86b2
2bc6
ffff
    ife [z-1], 0
string2.dasm16
609
2
2bc7
7f81
2bc8
2ba6
        set pc, built_in__str_split__ws
string2.dasm16
610
0

string2.dasm16
611
2
2bc9
5701
2bca
fffd
    set push, [z-3]
string2.dasm16
612
2
2bcb
5701
2bcc
ffff
    set push, [z-1]
string2.dasm16
613
2
2bcd
7c20
2bce
27d8
    jsr array__append
string2.dasm16
614
0
    
string2.dasm16
615
2
2bcf
86a1
2bd0
ffff
    set [z-1], 0
string2.dasm16
616
0

string2.dasm16
617
2
2bd1
7f81
2bd2
2ba6
    set pc, built_in__str_split__ws
string2.dasm16
618
0

string2.dasm16
619
0
:built_in__str_split__ws_finish
string2.dasm16
620
2
2bd3
86b2
2bd4
ffff
    ife [z-1], 0
string2.dasm16
621
2
2bd5
7f81
2bd6
2bdd
        set pc, built_in__str_split__ws_exit
string2.dasm16
622
0

string2.dasm16
623
2
2bd7
5701
2bd8
fffd
    set push, [z-3]
string2.dasm16
624
2
2bd9
5701
2bda
ffff
    set push, [z-1]
string2.dasm16
625
2
2bdb
7c20
2bdc
27d8
    jsr array__append
string2.dasm16
626
0

string2.dasm16
627
0
:built_in__str_split__ws_exit
string2.dasm16
628
2
2bdd
5461
2bde
fffd
    set x, [z-3]
string2.dasm16
629
2
2bdf
7f81
2be0
2026
    set pc, postamble
string2.dasm16
630
0
    
string2.dasm16
631
0

edit.dasm16
0
0
;----------------------------------------------------------------
edit.dasm16
1
0
; extern struct handle *edit_main(struct handle *str)
edit.dasm16
2
0
:edit_main
edit.dasm16
3
0
;----------------------------------------------------------------
edit.dasm16
4
1
2be1
8b01
    set push, 1
edit.dasm16
5
1
2be2
8b01
    set push, 1
edit.dasm16
6
2
2be3
7c20
2be4
2039
    jsr preamble
edit.dasm16
7
0

edit.dasm16
8
0
    ; initialize cursor to top left corner
edit.dasm16
9
0
    ; these are screen coordinates (not column or line in text) as 
edit.dasm16
10
0
    ; screen scrolls in both axis
edit.dasm16
11
2
2be5
87c1
2be6
0267
    set [cur_x], 0
edit.dasm16
12
2
2be7
87c1
2be8
0268
    set [cur_y], 0
edit.dasm16
13
0

edit.dasm16
14
0
    ; prev_char is a hack used to test with continuous cursor
edit.dasm16
15
0
    ; movement while keeping button down - no luck
edit.dasm16
16
2
2be9
87c1
2bea
0269
    set [prev_char], 0
edit.dasm16
17
0

edit.dasm16
18
0
    ; initialize next screen
edit.dasm16
19
2
2beb
7c20
2bec
2e10
    jsr screen_next
edit.dasm16
20
2
2bed
7c20
2bee
2ee2
    jsr screen_clear
edit.dasm16
21
0

edit.dasm16
22
0
    ; reserve space for editing text as string (not _really_ correct)
edit.dasm16
23
2
2bef
7f01
2bf0
0400
    set push, EDIT_BUFFER_SIZE
edit.dasm16
24
1
2bf1
a701
    set push, TYPE_STR
edit.dasm16
25
2
2bf2
7c20
2bf3
21d3
    jsr alloc
edit.dasm16
26
2
2bf4
0ea1
2bf5
ffff
    set [z-1], x
edit.dasm16
27
0

edit.dasm16
28
1
2bf6
2c61
    set x, [x]            ; x: struct string *
edit.dasm16
29
0

edit.dasm16
30
2
2bf7
0fc1
2bf8
025f
    set [buf_start], x
edit.dasm16
31
2
2bf9
0fc1
2bfa
0261
    set [gap_start], x
edit.dasm16
32
2
2bfb
0fc1
2bfc
0265
    set [cur_pos], x
edit.dasm16
33
2
2bfd
0fc1
2bfe
0263
    set [win_start], x
edit.dasm16
34
2
2bff
0fc1
2c00
0266
    set [cur_line], x
edit.dasm16
35
0

edit.dasm16
36
2
2c01
7c62
2c02
0400
    add x, EDIT_BUFFER_SIZE
edit.dasm16
37
2
2c03
0fc1
2c04
0260
    set [buf_end], x
edit.dasm16
38
2
2c05
0fc1
2c06
0262
    set [gap_end], x
edit.dasm16
39
0

edit.dasm16
40
2
2c07
5461
2c08
000a
    set x, [z+10]
edit.dasm16
41
1
2c09
2c61
    set x, [x]
edit.dasm16
42
1
2c0a
0c81
    set y, x
edit.dasm16
43
1
2c0b
8882
    add y, 1
edit.dasm16
44
1
2c0c
2c62
    add x, [x]
edit.dasm16
45
0

edit.dasm16
46
0
:edit_copy_arg_to_buffer
edit.dasm16
47
1
2c0d
0c94
    ifg y, x
edit.dasm16
48
2
2c0e
7f81
2c0f
2c16
        set pc, edit_main_loop
edit.dasm16
49
0

edit.dasm16
50
1
2c10
3041
    set c, [y]
edit.dasm16
51
2
2c11
7c20
2c12
2d43
    jsr edit_insert_char
edit.dasm16
52
1
2c13
8882
    add y, 1
edit.dasm16
53
2
2c14
7f81
2c15
2c0d
    set pc, edit_copy_arg_to_buffer
edit.dasm16
54
0

edit.dasm16
55
0
:edit_main_loop    
edit.dasm16
56
2
2c16
7c20
2c17
2db5
    jsr win_normalize
edit.dasm16
57
2
2c18
7c20
2c19
2ce6
    jsr edit_win_draw
edit.dasm16
58
0

edit.dasm16
59
2
2c1a
7b01
2c1b
0267
    set push, [cur_x]
edit.dasm16
60
2
2c1c
7b01
2c1d
0268
    set push, [cur_y]
edit.dasm16
61
2
2c1e
7c20
2c1f
2e28
    jsr screen_move_cursor
edit.dasm16
62
0

edit.dasm16
63
2
2c20
7841
2c21
0269
    set c, [prev_char]
edit.dasm16
64
0

edit.dasm16
65
2
2c22
7c20
2c23
2e21
    jsr screen_toggle_cursor
edit.dasm16
66
2
2c24
7c20
2c25
2103
    jsr win_getchar
edit.dasm16
67
2
2c26
7c20
2c27
2e21
    jsr screen_toggle_cursor
edit.dasm16
68
0

edit.dasm16
69
2
2c28
0bc1
2c29
0269
    set [prev_char], c
edit.dasm16
70
0

edit.dasm16
71
2
2c2a
7c52
2c2b
0080
    ife c, KEY_UP
edit.dasm16
72
2
2c2c
7f81
2c2d
2c74
        set pc, edit_key_up
edit.dasm16
73
2
2c2e
7c52
2c2f
0081
    ife c, KEY_DOWN
edit.dasm16
74
2
2c30
7f81
2c31
2c84
        set pc, edit_key_down
edit.dasm16
75
2
2c32
7c52
2c33
0082
    ife c, KEY_LEFT
edit.dasm16
76
2
2c34
7f81
2c35
2c9c
        set pc, edit_key_left
edit.dasm16
77
2
2c36
7c52
2c37
0083
    ife c, KEY_RIGHT
edit.dasm16
78
2
2c38
7f81
2c39
2ca9
        set pc, edit_key_right
edit.dasm16
79
1
2c3a
d052
    ife c, KEY_DEL
edit.dasm16
80
2
2c3b
7f81
2c3c
2cbc
        set pc, edit_key_del
edit.dasm16
81
1
2c3d
c452
    ife c, KEY_BS
edit.dasm16
82
2
2c3e
7f81
2c3f
2cc3
        set pc, edit_key_bs
edit.dasm16
83
1
2c40
c852
    ife c, KEY_NEWLINE
edit.dasm16
84
2
2c41
7f81
2c42
2cd8
        set pc, edit_key_newline
edit.dasm16
85
2
2c43
7c52
2c44
8058
    ife c, KEY_CTRL_X
edit.dasm16
86
2
2c45
7f81
2c46
2c52
        set pc, edit_main_finish
edit.dasm16
87
2
2c47
7c52
2c48
8043
    ife c, KEY_CTRL_C
edit.dasm16
88
2
2c49
7f81
2c4a
2c52
        set pc, edit_main_finish
edit.dasm16
89
1
2c4b
e854
    ifg c, 0x19
edit.dasm16
90
2
2c4c
7c56
2c4d
007f
        ifl c, 0x7f
edit.dasm16
91
2
2c4e
7f81
2c4f
2cd4
            set pc, edit_key_character
edit.dasm16
92
0

edit.dasm16
93
2
2c50
7f81
2c51
2c16
    set pc, edit_main_loop
edit.dasm16
94
0

edit.dasm16
95
0
:edit_main_finish
edit.dasm16
96
2
2c52
7c20
2c53
2e08
    jsr screen_prev
edit.dasm16
97
0

edit.dasm16
98
2
2c54
5461
2c55
000a
    set x, [z+10]
edit.dasm16
99
2
2c56
7c52
2c57
8043
    ife c, KEY_CTRL_C
edit.dasm16
100
2
2c58
7f81
2c59
2026
        set pc, postamble
edit.dasm16
101
0

edit.dasm16
102
2
2c5a
7841
2c5b
0260
    set c, [buf_end]
edit.dasm16
103
2
2c5c
7843
2c5d
025f
    sub c, [buf_start]
edit.dasm16
104
2
2c5e
7842
2c5f
0261
    add c, [gap_start]
edit.dasm16
105
2
2c60
7843
2c61
0262
    sub c, [gap_end]
edit.dasm16
106
0
    
edit.dasm16
107
1
2c62
0b01
    set push, c
edit.dasm16
108
1
2c63
a701
    set push, TYPE_STR
edit.dasm16
109
2
2c64
7c20
2c65
2770
    jsr array_create
edit.dasm16
110
0

edit.dasm16
111
1
2c66
2cfe
    sti j, [x]    
edit.dasm16
112
2
2c67
78c1
2c68
025f
    set i, [buf_start]
edit.dasm16
113
0

edit.dasm16
114
0
:edit_copy_buffer_to_result
edit.dasm16
115
2
2c69
78d2
2c6a
0261
    ife i, [gap_start]
edit.dasm16
116
2
2c6b
78c1
2c6c
0262
        set i, [gap_end]
edit.dasm16
117
2
2c6d
78d2
2c6e
0260
    ife i, [buf_end]
edit.dasm16
118
2
2c6f
7f81
2c70
2026
        set pc, postamble    
edit.dasm16
119
1
2c71
39fe
    sti [j], [i]
edit.dasm16
120
2
2c72
7f81
2c73
2c69
    set pc, edit_copy_buffer_to_result
edit.dasm16
121
0

edit.dasm16
122
0
;----------------------------------------------------------------
edit.dasm16
123
0
:edit_key_up
edit.dasm16
124
0
;----------------------------------------------------------------
edit.dasm16
125
2
2c74
7801
2c75
0266
    set a, [cur_line]
edit.dasm16
126
2
2c76
7c20
2c77
2d82
    jsr prevline
edit.dasm16
127
2
2c78
03c1
2c79
0266
    set [cur_line], a
edit.dasm16
128
0
    
edit.dasm16
129
2
2c7a
7821
2c7b
0267
    set b, [cur_x]
edit.dasm16
130
2
2c7c
7822
2c7d
0264
    add b, [win_shift]
edit.dasm16
131
2
2c7e
7c20
2c7f
2d99
    jsr pos_x
edit.dasm16
132
2
2c80
03c1
2c81
0265
    set [cur_pos], a
edit.dasm16
133
0
    
edit.dasm16
134
2
2c82
7f81
2c83
2c16
    set pc, edit_main_loop
edit.dasm16
135
0

edit.dasm16
136
0
    ; void k_up (void) {
edit.dasm16
137
0
    ;    cur_line = prevline (cur_line);
edit.dasm16
138
0
    ;    cur_pos = pos_x (cur_line, cur_x + win_shift);
edit.dasm16
139
0
    ; }
edit.dasm16
140
0

edit.dasm16
141
0
;----------------------------------------------------------------
edit.dasm16
142
0
:edit_key_down
edit.dasm16
143
0
;----------------------------------------------------------------
edit.dasm16
144
2
2c84
7801
2c85
0265
    set a, [cur_pos]
edit.dasm16
145
2
2c86
7c20
2c87
2d72
    jsr eol
edit.dasm16
146
2
2c88
7812
2c89
0260
    ife a, [buf_end]
edit.dasm16
147
2
2c8a
7f81
2c8b
2c16
        set pc, edit_main_loop
edit.dasm16
148
0

edit.dasm16
149
2
2c8c
7801
2c8d
0266
    set a, [cur_line]
edit.dasm16
150
2
2c8e
7c20
2c8f
2d8f
    jsr nextline
edit.dasm16
151
2
2c90
03c1
2c91
0266
    set [cur_line], a
edit.dasm16
152
0
    
edit.dasm16
153
2
2c92
7821
2c93
0267
    set b, [cur_x]
edit.dasm16
154
2
2c94
7822
2c95
0264
    add b, [win_shift]
edit.dasm16
155
2
2c96
7c20
2c97
2d99
    jsr pos_x
edit.dasm16
156
2
2c98
03c1
2c99
0265
    set [cur_pos], a
edit.dasm16
157
0
    
edit.dasm16
158
2
2c9a
7f81
2c9b
2c16
    set pc, edit_main_loop
edit.dasm16
159
0

edit.dasm16
160
0
    ; void k_down (void) {
edit.dasm16
161
0
    ;    if (eol (cur_pos) < eof_pos) {
edit.dasm16
162
0
    ;        cur_line = nextline (cur_line);
edit.dasm16
163
0
    ;        cur_pos = pos_x (cur_line, cur_x + win_shift);
edit.dasm16
164
0
    ;    }
edit.dasm16
165
0
    ; }
edit.dasm16
166
0
;----------------------------------------------------------------
edit.dasm16
167
0
:edit_key_left
edit.dasm16
168
0
;----------------------------------------------------------------
edit.dasm16
169
3
2c9c
7bd2
2c9d
0262
2c9e
0265
    ife [cur_pos], [gap_end]
edit.dasm16
170
3
2c9f
7bc1
2ca0
0261
2ca1
0265
        set [cur_pos], [gap_start]
edit.dasm16
171
3
2ca2
7bd4
2ca3
025f
2ca4
0265
    ifg [cur_pos], [buf_start]
edit.dasm16
172
2
2ca5
8bc3
2ca6
0265
        sub [cur_pos], 1
edit.dasm16
173
2
2ca7
7f81
2ca8
2c16
    set pc, edit_main_loop
edit.dasm16
174
0
;----------------------------------------------------------------
edit.dasm16
175
0
:edit_key_right
edit.dasm16
176
0
;----------------------------------------------------------------
edit.dasm16
177
3
2ca9
7bd2
2caa
0261
2cab
0265
    ife [cur_pos], [gap_start]
edit.dasm16
178
3
2cac
7bc1
2cad
0262
2cae
0265
        set [cur_pos], [gap_end]
edit.dasm16
179
3
2caf
7bd6
2cb0
0260
2cb1
0265
    ifl [cur_pos], [buf_end]
edit.dasm16
180
2
2cb2
8bc2
2cb3
0265
        add [cur_pos], 1
edit.dasm16
181
3
2cb4
7bd2
2cb5
0261
2cb6
0265
    ife [cur_pos], [gap_start]
edit.dasm16
182
3
2cb7
7bc1
2cb8
0262
2cb9
0265
        set [cur_pos], [gap_end]
edit.dasm16
183
2
2cba
7f81
2cbb
2c16
    set pc, edit_main_loop
edit.dasm16
184
0
;----------------------------------------------------------------
edit.dasm16
185
0
:edit_key_del
edit.dasm16
186
0
;----------------------------------------------------------------
edit.dasm16
187
3
2cbc
7bd6
2cbd
0260
2cbe
0265
    ifl [cur_pos], [buf_end]
edit.dasm16
188
2
2cbf
7c20
2cc0
2d4f
        jsr edit_remove_char
edit.dasm16
189
2
2cc1
7f81
2cc2
2c16
    set pc, edit_main_loop
edit.dasm16
190
0
;----------------------------------------------------------------
edit.dasm16
191
0
:edit_key_bs
edit.dasm16
192
0
;----------------------------------------------------------------
edit.dasm16
193
3
2cc3
7bd2
2cc4
0262
2cc5
0265
    ife [cur_pos], [gap_end]
edit.dasm16
194
3
2cc6
7bc1
2cc7
0261
2cc8
0265
        set [cur_pos], [gap_start]
edit.dasm16
195
3
2cc9
7bd2
2cca
025f
2ccb
0265
    ife [cur_pos], [buf_start]
edit.dasm16
196
2
2ccc
7f81
2ccd
2c16
        set pc, edit_main_loop
edit.dasm16
197
2
2cce
8bc3
2ccf
0265
    sub [cur_pos], 1
edit.dasm16
198
2
2cd0
7c20
2cd1
2d4f
    jsr edit_remove_char
edit.dasm16
199
2
2cd2
7f81
2cd3
2c16
    set pc, edit_main_loop
edit.dasm16
200
0
;----------------------------------------------------------------
edit.dasm16
201
0
;:edit_key_newline
edit.dasm16
202
0
:edit_key_character
edit.dasm16
203
0
;----------------------------------------------------------------
edit.dasm16
204
2
2cd4
7c20
2cd5
2d43
    jsr edit_insert_char
edit.dasm16
205
0
    
edit.dasm16
206
0
    ; void ins_ch (char ch) {
edit.dasm16
207
0
    ;    if (ins_mem (1))
edit.dasm16
208
0
    ;        text[cur_pos++] = ch;
edit.dasm16
209
0
    ; }
edit.dasm16
210
0

edit.dasm16
211
2
2cd6
7f81
2cd7
2c16
    set pc, edit_main_loop
edit.dasm16
212
0

edit.dasm16
213
0
:edit_key_newline
edit.dasm16
214
2
2cd8
7c20
2cd9
2d43
    jsr edit_insert_char
edit.dasm16
215
0

edit.dasm16
216
2
2cda
7821
2cdb
0266
    set b, [cur_line]    
edit.dasm16
217
2
2cdc
7c41
2cdd
0020
    set c, ' '
edit.dasm16
218
0
:edit_key_newline_loop
edit.dasm16
219
1
2cde
0933
    ifn [b], c
edit.dasm16
220
2
2cdf
7f81
2ce0
2c16
        set pc, edit_main_loop
edit.dasm16
221
2
2ce1
7c20
2ce2
2d43
    jsr edit_insert_char
edit.dasm16
222
1
2ce3
8822
    add b, 1
edit.dasm16
223
2
2ce4
7f81
2ce5
2cde
    set pc, edit_key_newline_loop
edit.dasm16
224
0

edit.dasm16
225
0
;----------------------------------------------------------------
edit.dasm16
226
0
:edit_win_draw
edit.dasm16
227
0
;----------------------------------------------------------------    
edit.dasm16
228
2
2ce6
7801
2ce7
023a
    set a, [current_screen]
edit.dasm16
229
2
2ce8
78c1
2ce9
0263
    set i, [win_start]
edit.dasm16
230
1
2cea
20e1
    set j, [a + SCREEN__START]
edit.dasm16
231
0

edit.dasm16
232
0
:edit_win_draw_loop
edit.dasm16
233
2
2ceb
7c20
2cec
2cf2
    jsr edit_line_draw
edit.dasm16
234
0

edit.dasm16
235
2
2ced
40f6
2cee
0001
    ifl j, [a + SCREEN__END]
edit.dasm16
236
2
2cef
7f81
2cf0
2ceb
        set pc, edit_win_draw_loop
edit.dasm16
237
0

edit.dasm16
238
1
2cf1
6381
    set pc, pop
edit.dasm16
239
0
;----------------------------------------------------------------
edit.dasm16
240
0
:edit_line_draw
edit.dasm16
241
0
; fastcall
edit.dasm16
242
0
;   i: buffer pointer to beginning of line
edit.dasm16
243
0
;   j: screen pointer to beginning of line
edit.dasm16
244
0
; return
edit.dasm16
245
0
;   i: pointer to beginning of next line in buffer or buf_end
edit.dasm16
246
0
;   j: pointer to beginning of next line in window of SCREEN_END
edit.dasm16
247
0
;----------------------------------------------------------------
edit.dasm16
248
1
2cf2
8441
    set c, 0
edit.dasm16
249
0
:edit_line_skip_start
edit.dasm16
250
2
2cf3
78d2
2cf4
0261
    ife i, [gap_start]
edit.dasm16
251
2
2cf5
78c1
2cf6
0262
        set i, [gap_end]
edit.dasm16
252
2
2cf7
7852
2cf8
0264
    ife c, [win_shift]
edit.dasm16
253
2
2cf9
7f81
2cfa
2d06
        set pc, edit_line_chars
edit.dasm16
254
2
2cfb
78d2
2cfc
0260
    ife i, [buf_end]
edit.dasm16
255
2
2cfd
7f81
2cfe
2d06
        set pc, edit_line_chars
edit.dasm16
256
1
2cff
c9d2
    ife [i], KEY_NEWLINE
edit.dasm16
257
2
2d00
7f81
2d01
2d06
        set pc, edit_line_chars
edit.dasm16
258
0

edit.dasm16
259
1
2d02
88c2
    add i, 1
edit.dasm16
260
1
2d03
8842
    add c, 1
edit.dasm16
261
0

edit.dasm16
262
2
2d04
7f81
2d05
2cf3
    set pc, edit_line_skip_start
edit.dasm16
263
0
    
edit.dasm16
264
0
:edit_line_chars
edit.dasm16
265
1
2d06
1c41
    set c, j
edit.dasm16
266
2
2d07
7c42
2d08
0020
    add c, SCREEN_COLS
edit.dasm16
267
0

edit.dasm16
268
0
:edit_line_chars_loop
edit.dasm16
269
1
2d09
85e1
    set [j], 0
edit.dasm16
270
2
2d0a
78d2
2d0b
0260
    ife i, [buf_end]
edit.dasm16
271
2
2d0c
7f81
2d0d
2d19
        set pc, edit_line_chars_loop_1
edit.dasm16
272
1
2d0e
c9d2
    ife [i], KEY_NEWLINE
edit.dasm16
273
2
2d0f
7f81
2d10
2d19
        set pc, edit_line_chars_loop_1
edit.dasm16
274
0

edit.dasm16
275
1
2d11
39e1
    set [j], [i]
edit.dasm16
276
2
2d12
7deb
2d13
7000
    bor [j], FONT_COLOR
edit.dasm16
277
0

edit.dasm16
278
0
    
edit.dasm16
279
1
2d14
88c2
    add i, 1
edit.dasm16
280
2
2d15
78d2
2d16
0261
    ife i, [gap_start]
edit.dasm16
281
2
2d17
78c1
2d18
0262
        set i, [gap_end]
edit.dasm16
282
0
    
edit.dasm16
283
0
:edit_line_chars_loop_1
edit.dasm16
284
1
2d19
88e2
    add j, 1
edit.dasm16
285
1
2d1a
08f6
    ifl j, c
edit.dasm16
286
2
2d1b
7f81
2d1c
2d09
        set pc, edit_line_chars_loop
edit.dasm16
287
0

edit.dasm16
288
2
2d1d
7c41
2d1e
2d1f
    set c, edit_line_skip_end
edit.dasm16
289
0
:edit_line_skip_end
edit.dasm16
290
2
2d1f
78d2
2d20
0260
    ife i, [buf_end]
edit.dasm16
291
1
2d21
6381
        set pc, pop
edit.dasm16
292
1
2d22
c9d2
    ife [i], KEY_NEWLINE
edit.dasm16
293
1
2d23
6041
        set c, pop
edit.dasm16
294
0

edit.dasm16
295
1
2d24
88c2
    add i, 1
edit.dasm16
296
2
2d25
78d2
2d26
0261
    ife i, [gap_start]
edit.dasm16
297
2
2d27
78c1
2d28
0262
        set i, [gap_end]
edit.dasm16
298
0
        
edit.dasm16
299
1
2d29
0b81
    set pc, c
edit.dasm16
300
0

edit.dasm16
301
0
;----------------------------------------------------------------
edit.dasm16
302
0
:edit_gap_move
edit.dasm16
303
0
;----------------------------------------------------------------
edit.dasm16
304
2
2d2a
78c1
2d2b
0261
    set i, [gap_start]
edit.dasm16
305
2
2d2c
78e1
2d2d
0262
    set j, [gap_end]
edit.dasm16
306
0
    
edit.dasm16
307
0
:edit_gap_move_loop
edit.dasm16
308
2
2d2e
78f6
2d2f
0265
    ifl j, [cur_pos]
edit.dasm16
309
1
2d30
3dde
        sti [i], [j]
edit.dasm16
310
2
2d31
78d4
2d32
0265
    ifg i, [cur_pos]
edit.dasm16
311
3
2d33
5aff
2d34
ffff
2d35
ffff
        std [j-1], [i-1]
edit.dasm16
312
2
2d36
78d3
2d37
0265
    ifn i, [cur_pos]
edit.dasm16
313
2
2d38
78f3
2d39
0265
        ifn j, [cur_pos]
edit.dasm16
314
2
2d3a
7f81
2d3b
2d2e
            set pc, edit_gap_move_loop
edit.dasm16
315
0

edit.dasm16
316
2
2d3c
1bc1
2d3d
0261
    set [gap_start], i
edit.dasm16
317
2
2d3e
1fc1
2d3f
0262
    set [gap_end], j
edit.dasm16
318
0

edit.dasm16
319
2
2d40
1fc1
2d41
0265
    set [cur_pos], j
edit.dasm16
320
1
2d42
6381
    set pc, pop
edit.dasm16
321
0

edit.dasm16
322
0
;----------------------------------------------------------------
edit.dasm16
323
0
:edit_insert_char
edit.dasm16
324
0
;----------------------------------------------------------------
edit.dasm16
325
3
2d43
7bd2
2d44
0262
2d45
0261
    ife [gap_start], [gap_end]
edit.dasm16
326
1
2d46
6381
        set pc, pop
edit.dasm16
327
0

edit.dasm16
328
2
2d47
7c20
2d48
2d2a
    jsr edit_gap_move    
edit.dasm16
329
0

edit.dasm16
330
2
2d49
7801
2d4a
0261
    set a, [gap_start]
edit.dasm16
331
1
2d4b
0901
    set [a], c
edit.dasm16
332
2
2d4c
8bc2
2d4d
0261
    add [gap_start], 1
edit.dasm16
333
1
2d4e
6381
    set pc, pop
edit.dasm16
334
0

edit.dasm16
335
0
;----------------------------------------------------------------
edit.dasm16
336
0
:edit_remove_char
edit.dasm16
337
0
;----------------------------------------------------------------
edit.dasm16
338
3
2d4f
7bd2
2d50
0260
2d51
0265
    ife [cur_pos], [buf_end]
edit.dasm16
339
1
2d52
6381
        set pc, pop
edit.dasm16
340
3
2d53
7bd2
2d54
025f
2d55
0261
    ife [gap_start], [buf_start]
edit.dasm16
341
3
2d56
7bd2
2d57
0260
2d58
0262
        ife [gap_end], [buf_end]
edit.dasm16
342
1
2d59
6381
            set pc, pop
edit.dasm16
343
0

edit.dasm16
344
2
2d5a
7c20
2d5b
2d2a
    jsr edit_gap_move    
edit.dasm16
345
0

edit.dasm16
346
2
2d5c
8bc2
2d5d
0262
    add [gap_end], 1
edit.dasm16
347
2
2d5e
8bc2
2d5f
0265
    add [cur_pos], 1
edit.dasm16
348
1
2d60
6381
    set pc, pop
edit.dasm16
349
0
;----------------------------------------------------------------
edit.dasm16
350
0
:bol
edit.dasm16
351
0
; fastcall
edit.dasm16
352
0
;     a: pos
edit.dasm16
353
0
; return
edit.dasm16
354
0
;   a: beginning of line pointer
edit.dasm16
355
0
;----------------------------------------------------------------
edit.dasm16
356
2
2d61
7812
2d62
0262
    ife a, [gap_end]
edit.dasm16
357
2
2d63
7801
2d64
0261
        set a, [gap_start]
edit.dasm16
358
0

edit.dasm16
359
2
2d65
7812
2d66
025f
    ife a, [buf_start]
edit.dasm16
360
1
2d67
6381
        set pc, pop
edit.dasm16
361
0
        
edit.dasm16
362
1
2d68
8803
    sub a, 1
edit.dasm16
363
0
    
edit.dasm16
364
1
2d69
c913
    ifn [a], KEY_NEWLINE
edit.dasm16
365
2
2d6a
7f81
2d6b
2d61
        set pc, bol        
edit.dasm16
366
0

edit.dasm16
367
1
2d6c
8802
    add a, 1
edit.dasm16
368
2
2d6d
7812
2d6e
0261
    ife a, [gap_start]
edit.dasm16
369
2
2d6f
7801
2d70
0262
        set a, [gap_end]
edit.dasm16
370
0

edit.dasm16
371
1
2d71
6381
    set pc, pop    
edit.dasm16
372
0

edit.dasm16
373
0
    ; int bol (int pos) {
edit.dasm16
374
0
    ;    while (pos && text[pos - 1] != '\n')
edit.dasm16
375
0
    ;        pos--;
edit.dasm16
376
0
    ;    return pos;
edit.dasm16
377
0
    ; }
edit.dasm16
378
0
;----------------------------------------------------------------
edit.dasm16
379
0
:eol
edit.dasm16
380
0
; fastcall
edit.dasm16
381
0
;     a: pos
edit.dasm16
382
0
; return
edit.dasm16
383
0
;   a: pointer to next newline or buf_end
edit.dasm16
384
0
;----------------------------------------------------------------
edit.dasm16
385
2
2d72
7812
2d73
0261
    ife a, [gap_start]
edit.dasm16
386
2
2d74
7801
2d75
0262
        set a, [gap_end]
edit.dasm16
387
0

edit.dasm16
388
2
2d76
7812
2d77
0260
    ife a, [buf_end]
edit.dasm16
389
1
2d78
6381
        set pc, pop
edit.dasm16
390
0

edit.dasm16
391
1
2d79
c912
    ife [a], KEY_NEWLINE
edit.dasm16
392
1
2d7a
6381
        set pc, pop        
edit.dasm16
393
0

edit.dasm16
394
1
2d7b
8802
    add a, 1
edit.dasm16
395
2
2d7c
7812
2d7d
0261
    ife a, [gap_start]
edit.dasm16
396
2
2d7e
7801
2d7f
0262
        set a, [gap_end]
edit.dasm16
397
0

edit.dasm16
398
2
2d80
7f81
2d81
2d72
    set pc, eol
edit.dasm16
399
0

edit.dasm16
400
0
    ; int eol (int pos) {
edit.dasm16
401
0
    ;    while (pos < eof_pos && text[pos] != '\n')
edit.dasm16
402
0
    ;        pos++;
edit.dasm16
403
0
    ;    return pos;
edit.dasm16
404
0
    ; }
edit.dasm16
405
0
;----------------------------------------------------------------
edit.dasm16
406
0
:prevline
edit.dasm16
407
0
; fastcall
edit.dasm16
408
0
;     a: pos
edit.dasm16
409
0
; return
edit.dasm16
410
0
;   a: beginning of previous line
edit.dasm16
411
0
;----------------------------------------------------------------
edit.dasm16
412
2
2d82
7c20
2d83
2d61
    jsr bol
edit.dasm16
413
2
2d84
7812
2d85
025f
    ife a, [buf_start]
edit.dasm16
414
1
2d86
6381
        set pc, pop
edit.dasm16
415
0

edit.dasm16
416
2
2d87
7812
2d88
0262
    ife a, [gap_end]
edit.dasm16
417
2
2d89
7801
2d8a
0261
        set a, [gap_start]
edit.dasm16
418
1
2d8b
8803
    sub a, 1
edit.dasm16
419
0
        
edit.dasm16
420
2
2d8c
7c20
2d8d
2d61
    jsr bol
edit.dasm16
421
1
2d8e
6381
    set pc, pop
edit.dasm16
422
0

edit.dasm16
423
0
    ; int prevline (int pos) {
edit.dasm16
424
0
    ;    pos = bol (pos);
edit.dasm16
425
0
    ;    return pos ? bol (pos - 1) : 0;
edit.dasm16
426
0
    ; }
edit.dasm16
427
0

edit.dasm16
428
0
;----------------------------------------------------------------
edit.dasm16
429
0
:nextline
edit.dasm16
430
0
; fastcall
edit.dasm16
431
0
;     a: pos
edit.dasm16
432
0
; return
edit.dasm16
433
0
;   a: beginning of next line
edit.dasm16
434
0
;----------------------------------------------------------------
edit.dasm16
435
2
2d8f
7c20
2d90
2d72
    jsr eol
edit.dasm16
436
2
2d91
7816
2d92
0260
    ifl a, [buf_end]
edit.dasm16
437
1
2d93
8802
        add a, 1
edit.dasm16
438
0

edit.dasm16
439
2
2d94
7812
2d95
0261
    ife a, [gap_start]
edit.dasm16
440
2
2d96
7801
2d97
0262
        set a, [gap_end]
edit.dasm16
441
0

edit.dasm16
442
1
2d98
6381
    set pc, pop
edit.dasm16
443
0

edit.dasm16
444
0
    ; int nextline (int pos) {
edit.dasm16
445
0
    ;    pos = eol (pos);
edit.dasm16
446
0
    ;    return pos < eof_pos ? pos + 1 : pos;
edit.dasm16
447
0
    ; }
edit.dasm16
448
0

edit.dasm16
449
0
;----------------------------------------------------------------
edit.dasm16
450
0
:pos_x
edit.dasm16
451
0
; convert column to pointer
edit.dasm16
452
0
; fastcall
edit.dasm16
453
0
;   a: line beginning pointer
edit.dasm16
454
0
;   b: column
edit.dasm16
455
0
; return
edit.dasm16
456
0
;   a: pointer to char in buf 
edit.dasm16
457
0
;----------------------------------------------------------------
edit.dasm16
458
1
2d99
8432
    ife b, 0
edit.dasm16
459
1
2d9a
6381
        set pc, pop
edit.dasm16
460
2
2d9b
7812
2d9c
0260
    ife a, [buf_end]
edit.dasm16
461
1
2d9d
6381
        set pc, pop
edit.dasm16
462
1
2d9e
c912
    ife [a], KEY_NEWLINE
edit.dasm16
463
1
2d9f
6381
        set pc, pop
edit.dasm16
464
0

edit.dasm16
465
1
2da0
8823
    sub b, 1
edit.dasm16
466
1
2da1
8802
    add a, 1
edit.dasm16
467
2
2da2
7812
2da3
0261
    ife a, [gap_start]
edit.dasm16
468
2
2da4
7801
2da5
0262
        set a, [gap_end]
edit.dasm16
469
0
        
edit.dasm16
470
2
2da6
7f81
2da7
2d99
    set pc, pos_x
edit.dasm16
471
0

edit.dasm16
472
0
    ; int pos_x (int line, int xx) {
edit.dasm16
473
0
    ;    int    i, x = 0;
edit.dasm16
474
0
    ;
edit.dasm16
475
0
    ;    for (i = line; i < eof_pos && x < xx; i++)
edit.dasm16
476
0
    ;        if (text[i] == '\n')
edit.dasm16
477
0
    ;            break;
edit.dasm16
478
0
    ;        else
edit.dasm16
479
0
    ;            x++;
edit.dasm16
480
0
    ;    return i;
edit.dasm16
481
0
    ; }
edit.dasm16
482
0

edit.dasm16
483
0

edit.dasm16
484
0

edit.dasm16
485
0

edit.dasm16
486
0

edit.dasm16
487
0

edit.dasm16
488
0

edit.dasm16
489
0
;----------------------------------------------------------------
edit.dasm16
490
0
:win_x
edit.dasm16
491
0
; fastcall
edit.dasm16
492
0
;   a: line beginning pointer
edit.dasm16
493
0
;   b: pointer to char in buf
edit.dasm16
494
0
; return
edit.dasm16
495
0
;   c: column
edit.dasm16
496
0
;----------------------------------------------------------------
edit.dasm16
497
1
2da8
8441
    set c, 0
edit.dasm16
498
0

edit.dasm16
499
1
2da9
0412
    ife a, b
edit.dasm16
500
1
2daa
6381
        set pc, pop
edit.dasm16
501
0
:win_x_loop
edit.dasm16
502
2
2dab
7812
2dac
0261
    ife a, [gap_start]
edit.dasm16
503
2
2dad
7801
2dae
0262
        set a, [gap_end]
edit.dasm16
504
0

edit.dasm16
505
1
2daf
0412
    ife a, b
edit.dasm16
506
1
2db0
6381
        set pc, pop
edit.dasm16
507
0

edit.dasm16
508
1
2db1
8842
    add c, 1
edit.dasm16
509
1
2db2
8802
    add a, 1
edit.dasm16
510
0

edit.dasm16
511
2
2db3
7f81
2db4
2dab
    set pc, win_x_loop
edit.dasm16
512
0

edit.dasm16
513
0
    ; int win_x (int line, int xx) {
edit.dasm16
514
0
    ;    int    i, x = 0;
edit.dasm16
515
0
    ;    for (i = line; i < eof_pos && i < line + xx; i++)
edit.dasm16
516
0
    ;        if (text[i] == '\n')
edit.dasm16
517
0
    ;            break;
edit.dasm16
518
0
    ;        else
edit.dasm16
519
0
    ;            x++;
edit.dasm16
520
0
    ;    return x;
edit.dasm16
521
0
    ; }
edit.dasm16
522
0

edit.dasm16
523
0

edit.dasm16
524
0

edit.dasm16
525
0

edit.dasm16
526
0
:win_normalize
edit.dasm16
527
0
    ; cur_line = bol (cur_pos);
edit.dasm16
528
2
2db5
7801
2db6
0265
    set a, [cur_pos]
edit.dasm16
529
2
2db7
7c20
2db8
2d61
    jsr bol
edit.dasm16
530
2
2db9
03c1
2dba
0266
    set [cur_line], a
edit.dasm16
531
0

edit.dasm16
532
0
    ; while (cur_line < bow_line)
edit.dasm16
533
0
    ;    bow_line = prevline (bow_line);
edit.dasm16
534
0
:win_normalize_2
edit.dasm16
535
3
2dbb
7bd2
2dbc
0263
2dbd
0266
    ife [cur_line], [win_start]
edit.dasm16
536
2
2dbe
7f81
2dbf
2dcd
        set pc, win_normalize_1
edit.dasm16
537
3
2dc0
7bd4
2dc1
0263
2dc2
0266
    ifg [cur_line], [win_start]
edit.dasm16
538
2
2dc3
7f81
2dc4
2dcd
        set pc, win_normalize_1
edit.dasm16
539
0
    
edit.dasm16
540
2
2dc5
7801
2dc6
0263
    set a, [win_start]
edit.dasm16
541
2
2dc7
7c20
2dc8
2d82
    jsr prevline
edit.dasm16
542
2
2dc9
03c1
2dca
0263
    set [win_start], a
edit.dasm16
543
0

edit.dasm16
544
2
2dcb
7f81
2dcc
2dbb
    set pc, win_normalize_2
edit.dasm16
545
0

edit.dasm16
546
0
:win_normalize_1
edit.dasm16
547
0
    ; cur_y = 0;
edit.dasm16
548
2
2dcd
87c1
2dce
0268
    set [cur_y], 0
edit.dasm16
549
0

edit.dasm16
550
0
    ; for (i = bow_line; i < cur_line; i = nextline (i))
edit.dasm16
551
0
    ;    cur_y++;
edit.dasm16
552
0

edit.dasm16
553
2
2dcf
7801
2dd0
0263
    set a, [win_start]                ; i = bow_line
edit.dasm16
554
0
:win_normalize_4
edit.dasm16
555
2
2dd1
7812
2dd2
0266
    ife a, [cur_line]                ; i < cur_line
edit.dasm16
556
2
2dd3
7f81
2dd4
2ddb
        set pc, win_normalize_3
edit.dasm16
557
0

edit.dasm16
558
2
2dd5
7c20
2dd6
2d8f
    jsr nextline                    ; i = nextline(i)
edit.dasm16
559
0

edit.dasm16
560
2
2dd7
8bc2
2dd8
0268
    add [cur_y], 1                    ; cur_y++
edit.dasm16
561
0
    
edit.dasm16
562
2
2dd9
7f81
2dda
2dd1
    set pc, win_normalize_4
edit.dasm16
563
0

edit.dasm16
564
0
    ; for (; cur_y >= LINES; cur_y--)
edit.dasm16
565
0
:win_normalize_3
edit.dasm16
566
2
2ddb
7801
2ddc
0263
    set a, [win_start]
edit.dasm16
567
0

edit.dasm16
568
0
:win_normalize_6
edit.dasm16
569
2
2ddd
b7d6
2dde
0268
    ifl [cur_y], SCREEN_ROWS                ; cur_y >= LINES
edit.dasm16
570
2
2ddf
7f81
2de0
2de7
        set pc, win_normalize_5
edit.dasm16
571
0

edit.dasm16
572
0
    ; bow_line = nextline (bow_line);
edit.dasm16
573
2
2de1
7c20
2de2
2d8f
    jsr nextline                    
edit.dasm16
574
0

edit.dasm16
575
2
2de3
8bc3
2de4
0268
    sub [cur_y], 1                    ; cur_y--
edit.dasm16
576
2
2de5
7f81
2de6
2ddd
    set pc, win_normalize_6
edit.dasm16
577
0

edit.dasm16
578
0
:win_normalize_5
edit.dasm16
579
2
2de7
03c1
2de8
0263
    set [win_start], a        
edit.dasm16
580
0
;---
edit.dasm16
581
2
2de9
7801
2dea
0266
    set a, [cur_line]
edit.dasm16
582
2
2deb
7821
2dec
0265
    set b, [cur_pos]
edit.dasm16
583
2
2ded
7c20
2dee
2da8
    jsr win_x
edit.dasm16
584
2
2def
7843
2df0
0264
    sub c, [win_shift]
edit.dasm16
585
2
2df1
0bc1
2df2
0267
    set [cur_x], c
edit.dasm16
586
0
    
edit.dasm16
587
0
:win_normalize_8
edit.dasm16
588
3
2df3
7fd1
2df4
8000
2df5
0267
    ifc [cur_x], 0x8000
edit.dasm16
589
2
2df6
7f81
2df7
2dfe
        set pc, win_normalize_7
edit.dasm16
590
0
            
edit.dasm16
591
2
2df8
a7c2
2df9
0267
    add [cur_x], 8
edit.dasm16
592
2
2dfa
a7c3
2dfb
0264
    sub [win_shift], 8
edit.dasm16
593
0
    
edit.dasm16
594
2
2dfc
7f81
2dfd
2df3
    set pc, win_normalize_8
edit.dasm16
595
0
    
edit.dasm16
596
0
:win_normalize_7
edit.dasm16
597
3
2dfe
7fd6
2dff
0020
2e00
0267
    ifl [cur_x], SCREEN_COLS
edit.dasm16
598
1
2e01
6381
        set pc, pop
edit.dasm16
599
0
    
edit.dasm16
600
2
2e02
a7c3
2e03
0267
    sub [cur_x], 8
edit.dasm16
601
2
2e04
a7c2
2e05
0264
    add [win_shift], 8
edit.dasm16
602
0
    
edit.dasm16
603
2
2e06
7f81
2e07
2dfe
    set pc, win_normalize_7
screen.dasm16
0
0
; This file represent my first tests to utilize new style of assembler.
screen.dasm16
1
0
; I try to minimize register usage here
screen.dasm16
2
0

screen.dasm16
3
0
;----------------------------------------------------------------
screen.dasm16
4
0
:screen_prev
screen.dasm16
5
0
; fastcall
screen.dasm16
6
0
;----------------------------------------------------------------
screen.dasm16
7
3
2e08
7fd2
2e09
023b
2e0a
023a
    ife [current_screen], screen_first
screen.dasm16
8
1
2e0b
6381
        set pc, pop
screen.dasm16
9
2
2e0c
93c3
2e0d
023a
    sub [current_screen], SIZEOF_SCREEN
screen.dasm16
10
2
2e0e
7f81
2e0f
2e16
    set pc, screen_select
screen.dasm16
11
0
;----------------------------------------------------------------
screen.dasm16
12
0
:screen_next
screen.dasm16
13
0
; fastcall
screen.dasm16
14
0
;----------------------------------------------------------------
screen.dasm16
15
3
2e10
7fd2
2e11
0241
2e12
023a
    ife [current_screen], screen_last
screen.dasm16
16
1
2e13
6381
        set pc, pop
screen.dasm16
17
2
2e14
93c2
2e15
023a
    add [current_screen], SIZEOF_SCREEN
screen.dasm16
18
0

screen.dasm16
19
0
;----------------------------------------------------------------
screen.dasm16
20
0
:screen_select
screen.dasm16
21
0
; fastcall
screen.dasm16
22
0
;----------------------------------------------------------------
screen.dasm16
23
1
2e16
0301
    set push, a
screen.dasm16
24
1
2e17
0701
    set push, b
screen.dasm16
25
0
    
screen.dasm16
26
1
2e18
8401
    set a, 0
screen.dasm16
27
2
2e19
7821
2e1a
023a
    set b, [current_screen]
screen.dasm16
28
1
2e1b
2421
    set b, [b]
screen.dasm16
29
2
2e1c
7a40
2e1d
0250
    hwi [monitor]
screen.dasm16
30
0
    
screen.dasm16
31
1
2e1e
6021
    set b, pop
screen.dasm16
32
1
2e1f
6001
    set a, pop
screen.dasm16
33
0
    
screen.dasm16
34
1
2e20
6381
    set pc, pop
screen.dasm16
35
0
     
screen.dasm16
36
0
;----------------------------------------------------------------
screen.dasm16
37
0
:screen_toggle_cursor
screen.dasm16
38
0
; fastcall
screen.dasm16
39
0
;----------------------------------------------------------------
screen.dasm16
40
2
2e21
7861
2e22
023a
    set x, [current_screen]                ; struct screen *cur
screen.dasm16
41
2
2e23
4c61
2e24
0002
    set x, [x + SCREEN__CURSOR]    
screen.dasm16
42
2
2e25
7d6c
2e26
ff80
    xor [x], 0xff80                        ; change colors
screen.dasm16
43
1
2e27
6381
    set pc, pop
screen.dasm16
44
0

screen.dasm16
45
0
;----------------------------------------------------------------
screen.dasm16
46
0
:screen_move_cursor
screen.dasm16
47
0
; fastcall
screen.dasm16
48
0
;  x [sp+2]
screen.dasm16
49
0
;  y [sp+1]
screen.dasm16
50
0
;----------------------------------------------------------------
screen.dasm16
51
2
2e28
7861
2e29
023a
    set x, [current_screen]
screen.dasm16
52
2
2e2a
2e61
2e2b
0002
    set [x+SCREEN__CURSOR], [x+SCREEN__START]
screen.dasm16
53
0
    
screen.dasm16
54
3
2e2c
7f44
2e2d
0020
2e2e
0001
    mul [sp+1], SCREEN_COLS
screen.dasm16
55
3
2e2f
6a62
2e30
0001
2e31
0002
    add [x+SCREEN__CURSOR], [sp+1]
screen.dasm16
56
3
2e32
6a62
2e33
0002
2e34
0002
    add [x+SCREEN__CURSOR], [sp+2]
screen.dasm16
57
0

screen.dasm16
58
1
2e35
6321
    set [sp], pop    ; remove y
screen.dasm16
59
1
2e36
6321
    set [sp], pop    ; remove x
screen.dasm16
60
1
2e37
6381
    set pc, pop
screen.dasm16
61
0

screen.dasm16
62
0
;----------------------------------------------------------------
screen.dasm16
63
0
; void screen__scroll(int16 dx, int16 dy)
screen.dasm16
64
0
;----------------------------------------------------------------
screen.dasm16
65
0
:screen__scroll
screen.dasm16
66
1
2e38
8f01
    set push, 2
screen.dasm16
67
1
2e39
8701
    set push, 0
screen.dasm16
68
2
2e3a
7c20
2e3b
2039
    jsr preamble
screen.dasm16
69
0

screen.dasm16
70
0
    ; exit if no scroll
screen.dasm16
71
2
2e3c
86b2
2e3d
000a
    ife [z+10], 0
screen.dasm16
72
2
2e3e
86b2
2e3f
000b
        ife [z+11], 0
screen.dasm16
73
2
2e40
7f81
2e41
2026
            set pc, postamble
screen.dasm16
74
0

screen.dasm16
75
0
    ; limit scrolling amount
screen.dasm16
76
3
2e42
7eb5
2e43
0020
2e44
000b
    ifa [z+11], SCREEN_COLS
screen.dasm16
77
3
2e45
7ea1
2e46
0020
2e47
000b
        set [z+11], SCREEN_COLS
screen.dasm16
78
3
2e48
7eb7
2e49
ffe0
2e4a
000b
    ifu [z+11], -SCREEN_COLS
screen.dasm16
79
3
2e4b
7ea1
2e4c
ffe0
2e4d
000b
        set [z+11], -SCREEN_COLS
screen.dasm16
80
0

screen.dasm16
81
2
2e4e
b6b5
2e4f
000a
    ifa [z+10], SCREEN_ROWS
screen.dasm16
82
2
2e50
b6a1
2e51
000a
        set [z+10], SCREEN_ROWS
screen.dasm16
83
3
2e52
7eb7
2e53
fff4
2e54
000a
    ifu [z+10], -SCREEN_ROWS
screen.dasm16
84
3
2e55
7ea1
2e56
fff4
2e57
000a
        set [z+10], -SCREEN_ROWS
screen.dasm16
85
0

screen.dasm16
86
0
    ; deduct the memory move direction +1 or -1
screen.dasm16
87
1
2e58
8821
    set b, 1
screen.dasm16
88
2
2e59
86b5
2e5a
000a
    ifa [z+10], 0
screen.dasm16
89
1
2e5b
8021
        set b, -1
screen.dasm16
90
2
2e5c
86b2
2e5d
000a
    ife [z+10], 0
screen.dasm16
91
2
2e5e
86b5
2e5f
000b
        ifa [z+11], 0
screen.dasm16
92
1
2e60
8021
            set b, -1    
screen.dasm16
93
0

screen.dasm16
94
0
    ; x = -dx
screen.dasm16
95
1
2e61
0c63
    sub x, x
screen.dasm16
96
2
2e62
5463
2e63
000b
    sub x, [z+11]
screen.dasm16
97
0

screen.dasm16
98
0
    ; y = -dy
screen.dasm16
99
1
2e64
1083
    sub y, y
screen.dasm16
100
2
2e65
5483
2e66
000a
    sub y, [z+10]    
screen.dasm16
101
0

screen.dasm16
102
0
    ; reset count
screen.dasm16
103
1
2e67
0843
    sub c, c
screen.dasm16
104
0

screen.dasm16
105
2
2e68
7801
2e69
023a
    set a, [current_screen]
screen.dasm16
106
0

screen.dasm16
107
0
    ; destination memory addr
screen.dasm16
108
1
2e6a
20c1
    set i, [a + SCREEN__START]
screen.dasm16
109
0

screen.dasm16
110
0
    ; source memory addr
screen.dasm16
111
1
2e6b
10e1
    set j, y
screen.dasm16
112
2
2e6c
7ce5
2e6d
0020
    mli j, SCREEN_COLS
screen.dasm16
113
1
2e6e
0ce2
    add j, x
screen.dasm16
114
1
2e6f
18e2
    add j, i
screen.dasm16
115
0

screen.dasm16
116
1
2e70
8832
    ife b, 1
screen.dasm16
117
2
2e71
7f81
2e72
2e7a
        set pc, screen__scroll__loop
screen.dasm16
118
0

screen.dasm16
119
2
2e73
7cc2
2e74
017f
    add i, 0x17f
screen.dasm16
120
2
2e75
7ce2
2e76
017f
    add j, 0x17f
screen.dasm16
121
2
2e77
7c62
2e78
001f
    add x, SCREEN_COLS-1
screen.dasm16
122
1
2e79
b082
    add y, SCREEN_ROWS-1
screen.dasm16
123
0

screen.dasm16
124
0
:screen__scroll__loop
screen.dasm16
125
0
    ; a: temp variable
screen.dasm16
126
0
    ; b: direction -1 or +1 (signed)
screen.dasm16
127
0
    ; c: number of processed memory locations (unsigned)
screen.dasm16
128
0
    ; x: current source column (signed)
screen.dasm16
129
0
    ; y: current source line (signed)
screen.dasm16
130
0
    ; i: current destination memory location (unsigned)
screen.dasm16
131
0
    ; j: current source memory location (unsigned)
screen.dasm16
132
0

screen.dasm16
133
0
    ; clear or copy
screen.dasm16
134
1
2e7a
8401
    set a, 0
screen.dasm16
135
1
2e7b
8075
    ifa x, -1
screen.dasm16
136
2
2e7c
7c77
2e7d
0020
        ifu x, SCREEN_COLS
screen.dasm16
137
1
2e7e
8095
            ifa y, -1
screen.dasm16
138
1
2e7f
b497
                ifu y, SCREEN_ROWS
screen.dasm16
139
1
2e80
3c01
                    set a, [j]
screen.dasm16
140
0

screen.dasm16
141
0
    ; set the current location
screen.dasm16
142
1
2e81
01c1
    set [i], a
screen.dasm16
143
0
    
screen.dasm16
144
0
    ; advance loop
screen.dasm16
145
1
2e82
0462
    add x, b
screen.dasm16
146
1
2e83
04c2
    add i, b
screen.dasm16
147
1
2e84
04e2
    add j, b
screen.dasm16
148
0
    
screen.dasm16
149
1
2e85
8842
    add c, 1
screen.dasm16
150
2
2e86
7c52
2e87
0180
    ife c, 0x180
screen.dasm16
151
2
2e88
7f81
2e89
2026
        set pc, postamble
screen.dasm16
152
0

screen.dasm16
153
1
2e8a
0801
    set a, c
screen.dasm16
154
2
2e8b
7c08
2e8c
0020
    mod a, SCREEN_COLS
screen.dasm16
155
1
2e8d
8413
    ifn a, 0
screen.dasm16
156
2
2e8e
7f81
2e8f
2e7a
        set pc, screen__scroll__loop
screen.dasm16
157
0

screen.dasm16
158
1
2e90
0482
    add y, b
screen.dasm16
159
0

screen.dasm16
160
1
2e91
0401
    set a, b
screen.dasm16
161
2
2e92
7c05
2e93
0020
    mli a, SCREEN_COLS
screen.dasm16
162
0

screen.dasm16
163
1
2e94
0063
    sub x, a
screen.dasm16
164
0

screen.dasm16
165
2
2e95
7f81
2e96
2e7a
    set pc, screen__scroll__loop
screen.dasm16
166
0
    
screen.dasm16
167
0
;----------------------------------------------------------------
screen.dasm16
168
0
; void screen__get(int16 x, int16 y)
screen.dasm16
169
0
;----------------------------------------------------------------
screen.dasm16
170
0
:screen__get
screen.dasm16
171
3
2e97
7f44
2e98
0020
2e99
0001
    mul [sp+1], SCREEN_COLS
screen.dasm16
172
3
2e9a
6b42
2e9b
0002
2e9c
0001
    add [sp+1], [sp+2]
screen.dasm16
173
0
    
screen.dasm16
174
2
2e9d
7861
2e9e
023a
    set x, [current_screen]
screen.dasm16
175
2
2e9f
2f42
2ea0
0001
    add [sp+1], [x + SCREEN__START]
screen.dasm16
176
0

screen.dasm16
177
2
2ea1
6861
2ea2
0001
    set x, [sp+1]
screen.dasm16
178
1
2ea3
2c61
    set x, [x]
screen.dasm16
179
2
2ea4
7c6a
2ea5
007f
    and x, 0x007f
screen.dasm16
180
0

screen.dasm16
181
1
2ea6
6321
    set [sp], pop
screen.dasm16
182
1
2ea7
6321
    set [sp], pop
screen.dasm16
183
1
2ea8
6381
    set pc, pop
screen.dasm16
184
0
    
screen.dasm16
185
0
;----------------------------------------------------------------
screen.dasm16
186
0
; void screen__set(int16 x, int16 y, uint16 char)
screen.dasm16
187
0
;----------------------------------------------------------------
screen.dasm16
188
0
:screen__set
screen.dasm16
189
3
2ea9
7f44
2eaa
0020
2eab
0002
    mul [sp+2], SCREEN_COLS
screen.dasm16
190
3
2eac
6b42
2ead
0003
2eae
0002
    add [sp+2], [sp+3]
screen.dasm16
191
0
    
screen.dasm16
192
2
2eaf
7861
2eb0
023a
    set x, [current_screen]
screen.dasm16
193
2
2eb1
2f42
2eb2
0002
    add [sp+2], [x + SCREEN__START]
screen.dasm16
194
0
    
screen.dasm16
195
3
2eb3
7f4b
2eb4
7000
2eb5
0001
    bor [sp+1], FONT_COLOR
screen.dasm16
196
0
    
screen.dasm16
197
2
2eb6
6861
2eb7
0002
    set x, [sp+2]
screen.dasm16
198
2
2eb8
6961
2eb9
0001
    set [x], [sp+1]        ; set new content
screen.dasm16
199
0

screen.dasm16
200
1
2eba
6321
    set [sp], pop
screen.dasm16
201
1
2ebb
6321
    set [sp], pop
screen.dasm16
202
1
2ebc
6321
    set [sp], pop
screen.dasm16
203
1
2ebd
6381
    set pc, pop
screen.dasm16
204
0
    
screen.dasm16
205
0
;----------------------------------------------------------------
screen.dasm16
206
0
; struct handle *screen__get_cursor()
screen.dasm16
207
0
;----------------------------------------------------------------
screen.dasm16
208
0
:screen__get_cursor
screen.dasm16
209
1
2ebe
8701
    set push, 0
screen.dasm16
210
1
2ebf
8b01
    set push, 1
screen.dasm16
211
2
2ec0
7c20
2ec1
2039
    jsr preamble
screen.dasm16
212
0

screen.dasm16
213
2
2ec2
7821
2ec3
023a
    set b, [current_screen]
screen.dasm16
214
2
2ec4
4401
2ec5
0002
    set a, [b + SCREEN__CURSOR]
screen.dasm16
215
1
2ec6
2403
    sub a, [b + SCREEN__START]
screen.dasm16
216
0

screen.dasm16
217
1
2ec7
8f01
    set push, 2
screen.dasm16
218
1
2ec8
9701
    set push, TYPE_TUPLE
screen.dasm16
219
2
2ec9
7c20
2eca
2770
    jsr array_create
screen.dasm16
220
2
2ecb
0ea1
2ecc
ffff
    set [z-1], x
screen.dasm16
221
1
2ecd
2c21
    set b, [x]
screen.dasm16
222
0
    
screen.dasm16
223
1
2ece
0041
    set c, a
screen.dasm16
224
2
2ecf
7c48
2ed0
0020
    mod c, SCREEN_COLS
screen.dasm16
225
0
    
screen.dasm16
226
1
2ed1
0b01
    set push, c
screen.dasm16
227
2
2ed2
7c20
2ed3
22a2
    jsr uint16_to_int
screen.dasm16
228
2
2ed4
0e21
2ed5
0001
    set [b+1], x
screen.dasm16
229
0

screen.dasm16
230
1
2ed6
0041
    set c, a
screen.dasm16
231
2
2ed7
7c46
2ed8
0020
    div c, SCREEN_COLS
screen.dasm16
232
0
    
screen.dasm16
233
1
2ed9
0b01
    set push, c
screen.dasm16
234
2
2eda
7c20
2edb
22a2
    jsr uint16_to_int
screen.dasm16
235
2
2edc
0e21
2edd
0002
    set [b+2], x
screen.dasm16
236
0

screen.dasm16
237
2
2ede
5461
2edf
ffff
    set x, [z-1]
screen.dasm16
238
2
2ee0
7f81
2ee1
2026
    set pc, postamble
screen.dasm16
239
0

screen.dasm16
240
0
;----------------------------------------------------------------
screen.dasm16
241
0
; void cls(void)
screen.dasm16
242
0
;----------------------------------------------------------------
screen.dasm16
243
0
:screen_clear
screen.dasm16
244
1
2ee2
0301
    set push, a
screen.dasm16
245
1
2ee3
1b01
    set push, i
screen.dasm16
246
1
2ee4
1f01
    set push, j
screen.dasm16
247
0

screen.dasm16
248
2
2ee5
7801
2ee6
023a
    set a, [current_screen]
screen.dasm16
249
2
2ee7
2201
2ee8
0002
    set [a + SCREEN__CURSOR], [a + SCREEN__START]
screen.dasm16
250
0

screen.dasm16
251
1
2ee9
20c1
    set i, [a + SCREEN__START]
screen.dasm16
252
2
2eea
4001
2eeb
0001
    set a, [a + SCREEN__END]
screen.dasm16
253
0
    
screen.dasm16
254
0
:screen_clear_loop
screen.dasm16
255
1
2eec
85c1
    set [i], 0
screen.dasm16
256
1
2eed
00d6
    ifl i, a
screen.dasm16
257
2
2eee
7f9e
2eef
2eec
        sti pc, screen_clear_loop
screen.dasm16
258
0

screen.dasm16
259
0
:screen_clear_finish
screen.dasm16
260
1
2ef0
60e1
    set j, pop
screen.dasm16
261
1
2ef1
60c1
    set i, pop
screen.dasm16
262
1
2ef2
6001
    set a, pop
screen.dasm16
263
0

screen.dasm16
264
1
2ef3
6381
    set pc, pop
screen.dasm16
265
0

screen.dasm16
266
0
;----------------------------------------------------------------
screen.dasm16
267
0
:screen_add_char
screen.dasm16
268
0
; fastcall
screen.dasm16
269
0
; c: character
screen.dasm16
270
0
;----------------------------------------------------------------
screen.dasm16
271
1
2ef4
0301
    set push, a
screen.dasm16
272
1
2ef5
1b01
    set push, i
screen.dasm16
273
1
2ef6
1f01
    set push, j
screen.dasm16
274
0
    
screen.dasm16
275
0
    ;set x, 0
screen.dasm16
276
0

screen.dasm16
277
2
2ef7
7801
2ef8
023a
    set a, [current_screen]
screen.dasm16
278
2
2ef9
40c1
2efa
0002
    set i, [a + SCREEN__CURSOR]
screen.dasm16
279
0

screen.dasm16
280
3
2efb
7e52
2efc
1bcc
2efd
0721
    ife [c + lexer_table], lexer_char_newline
screen.dasm16
281
2
2efe
7f81
2eff
2f08
        set pc, add_char_newline
screen.dasm16
282
0
    
screen.dasm16
283
1
2f00
c452
    ife c, KEY_BS
screen.dasm16
284
2
2f01
7f81
2f02
2f27
        set pc, add_char_backspace
screen.dasm16
285
0

screen.dasm16
286
1
2f03
09c1
    set [i], c
screen.dasm16
287
2
2f04
7dcb
2f05
7000
    bor [i], FONT_COLOR
screen.dasm16
288
2
2f06
7f9e
2f07
2f0c
    sti pc, add_char_scroll
screen.dasm16
289
0
    
screen.dasm16
290
0
:add_char_newline
screen.dasm16
291
2
2f08
7cca
2f09
ffe0
    and i, 0xffe0
screen.dasm16
292
2
2f0a
7cc2
2f0b
0020
    add i, SCREEN_COLS
screen.dasm16
293
0
    
screen.dasm16
294
0
:add_char_scroll
screen.dasm16
295
2
2f0c
1a01
2f0d
0002
    set [a + SCREEN__CURSOR], i
screen.dasm16
296
0

screen.dasm16
297
2
2f0e
40d6
2f0f
0001
    ifl i, [a + SCREEN__END]
screen.dasm16
298
2
2f10
7f81
2f11
2f23
        set pc, add_char_finish
screen.dasm16
299
0

screen.dasm16
300
0
    ;set x, SCREEN_COLS
screen.dasm16
301
3
2f12
7e03
2f13
0020
2f14
0002
    sub [a + SCREEN__CURSOR], SCREEN_COLS
screen.dasm16
302
0
    
screen.dasm16
303
1
2f15
20c1
    set i, [a + SCREEN__START]
screen.dasm16
304
1
2f16
20e1
    set j, [a + SCREEN__START]
screen.dasm16
305
2
2f17
7ce2
2f18
0020
    add j, SCREEN_COLS
screen.dasm16
306
0
    
screen.dasm16
307
0
:add_char_copy
screen.dasm16
308
1
2f19
3dde
    sti [i], [j]
screen.dasm16
309
2
2f1a
40f6
2f1b
0001
    ifl j, [a + SCREEN__END]
screen.dasm16
310
2
2f1c
7f81
2f1d
2f19
        set pc, add_char_copy
screen.dasm16
311
0
    
screen.dasm16
312
0
:add_char_clear
screen.dasm16
313
1
2f1e
85de
    sti [i], 0
screen.dasm16
314
2
2f1f
40d6
2f20
0001
    ifl i, [a + SCREEN__END]
screen.dasm16
315
2
2f21
7f81
2f22
2f1e
        set pc, add_char_clear
screen.dasm16
316
0
    
screen.dasm16
317
0
:add_char_finish
screen.dasm16
318
1
2f23
60e1
    set j, pop
screen.dasm16
319
1
2f24
60c1
    set i, pop
screen.dasm16
320
1
2f25
6001
    set a, pop
screen.dasm16
321
0
    
screen.dasm16
322
1
2f26
6381
    set pc, pop
screen.dasm16
323
0

screen.dasm16
324
0
:add_char_backspace
screen.dasm16
325
1
2f27
20d3
    ifn i, [a + SCREEN__START]
screen.dasm16
326
2
2f28
86df
2f29
ffff
        std [i-1], 0
screen.dasm16
327
0

screen.dasm16
328
2
2f2a
1a01
2f2b
0002
    set [a + SCREEN__CURSOR], i
screen.dasm16
329
2
2f2c
7f81
2f2d
2f23
    set pc, add_char_finish
dict2.dasm16
0
0
;----------------------------------------------------------------
dict2.dasm16
1
0
; struct handle *dict_get(struct handle *dict, struct handle *key)
dict2.dasm16
2
0
; return x: struct handle *value or 0
dict2.dasm16
3
0
;----------------------------------------------------------------
dict2.dasm16
4
0
:dict_get
dict2.dasm16
5
1
2f2e
8f01
    set push, 2
dict2.dasm16
6
1
2f2f
8f01
    set push, 2
dict2.dasm16
7
2
2f30
7c20
2f31
2039
    jsr preamble
dict2.dasm16
8
0

dict2.dasm16
9
3
2f32
56a1
2f33
000b
2f34
ffff
    set [z-1], [z+11]
dict2.dasm16
10
2
2f35
5461
2f36
000a
    set x, [z+10]
dict2.dasm16
11
2
2f37
0ea1
2f38
fffe
    set [z-2], x
dict2.dasm16
12
0

dict2.dasm16
13
2
2f39
4f01
2f3a
0001
    set push, [x + HANDLE_TYPE]
dict2.dasm16
14
2
2f3b
7f32
2f3c
0800
    ife peek, TYPE_NAME
dict2.dasm16
15
2
2f3d
a661
2f3e
0001
        set [x + HANDLE_TYPE], TYPE_STR
dict2.dasm16
16
0
    
dict2.dasm16
17
2
2f3f
7c21
2f40
026f
    set b, dict__get__finish
dict2.dasm16
18
2
2f41
7f81
2f42
2fad
    set pc, dict__bin_search
dict2.dasm16
19
0

dict2.dasm16
20
0
:dict__get__match
dict2.dasm16
21
2
2f43
5401
2f44
fffe
    set a, [z-2]
dict2.dasm16
22
2
2f45
6201
2f46
0001
    set [a + HANDLE_TYPE], pop    
dict2.dasm16
23
0

dict2.dasm16
24
0
    ; translate memory address to value
dict2.dasm16
25
1
2f47
2861
    set x, [c]        ; struct handle *tuple
dict2.dasm16
26
1
2f48
2c61
    set x, [x]        ; struct list *kv_tuple
dict2.dasm16
27
0

dict2.dasm16
28
2
2f49
4c61
2f4a
0002
    set x, [x + DICT_ITEM_VALUE]
dict2.dasm16
29
2
2f4b
7c20
2f4c
2026
    jsr postamble
dict2.dasm16
30
0

dict2.dasm16
31
0
:dict__del__no_match
dict2.dasm16
32
0
:dict__get__no_match
dict2.dasm16
33
2
2f4d
5401
2f4e
fffe
    set a, [z-2]
dict2.dasm16
34
2
2f4f
6201
2f50
0001
    set [a + HANDLE_TYPE], pop    
dict2.dasm16
35
0

dict2.dasm16
36
1
2f51
8461
    set x, 0        ; return none
dict2.dasm16
37
2
2f52
7f81
2f53
2026
    set pc, postamble
dict2.dasm16
38
0

dict2.dasm16
39
0
;----------------------------------------------------------------
dict2.dasm16
40
0
; struct handle *dict__bin_insert_sort(struct handle *dict, struct handle *key, struct handle *value)
dict2.dasm16
41
0
;----------------------------------------------------------------
dict2.dasm16
42
0
:dict__set
dict2.dasm16
43
1
2f54
9301
    set push, 3
dict2.dasm16
44
1
2f55
9301
    set push, 3
dict2.dasm16
45
2
2f56
7c20
2f57
2039
    jsr preamble
dict2.dasm16
46
0

dict2.dasm16
47
3
2f58
56a1
2f59
000c
2f5a
ffff
    set [z-1], [z+12]
dict2.dasm16
48
2
2f5b
5461
2f5c
000b
    set x, [z+11]
dict2.dasm16
49
2
2f5d
0ea1
2f5e
fffe
    set [z-2], x
dict2.dasm16
50
0

dict2.dasm16
51
3
2f5f
7e73
2f60
0800
2f61
0001
    ifn [x + HANDLE_TYPE], TYPE_NAME
dict2.dasm16
52
2
2f62
7f81
2f63
2f6b
        set pc, dict_set_skip
dict2.dasm16
53
0

dict2.dasm16
54
1
2f64
0f01
    set push, x
dict2.dasm16
55
2
2f65
7c20
2f66
28ca
    jsr array_clone
dict2.dasm16
56
2
2f67
a661
2f68
0001
    set [x + HANDLE_TYPE], TYPE_STR
dict2.dasm16
57
2
2f69
0ea1
2f6a
fffe
    set [z-2], x
dict2.dasm16
58
0

dict2.dasm16
59
0
:dict_set_skip
dict2.dasm16
60
0
    ; create item tuple
dict2.dasm16
61
1
2f6b
8f01
    set push, 2
dict2.dasm16
62
1
2f6c
9701
    set push, TYPE_TUPLE
dict2.dasm16
63
2
2f6d
7c20
2f6e
2770
    jsr array_create
dict2.dasm16
64
2
2f6f
0ea1
2f70
fffd
    set [z-3], x
dict2.dasm16
65
0

dict2.dasm16
66
1
2f71
2cde
    sti i, [x]
dict2.dasm16
67
0

dict2.dasm16
68
2
2f72
55de
2f73
fffe
    sti [i], [z-2]        ; add key to tuple
dict2.dasm16
69
2
2f74
55c1
2f75
000a
    set [i], [z+10]        ; add value to tuple
dict2.dasm16
70
0

dict2.dasm16
71
2
2f76
7c21
2f77
0271
    set b, dict__set__finish
dict2.dasm16
72
2
2f78
7f81
2f79
2fad
    set pc, dict__bin_search
dict2.dasm16
73
0

dict2.dasm16
74
0
:dict__set__match
dict2.dasm16
75
0
    ; translate memory address to array index
dict2.dasm16
76
2
2f7a
5541
2f7b
fffd
    set [c], [z - 3]
dict2.dasm16
77
2
2f7c
7f81
2f7d
2026
    set pc, postamble
dict2.dasm16
78
0

dict2.dasm16
79
0
:dict__set__no_match
dict2.dasm16
80
1
2f7e
00c3
    sub i, a            ; calculate index
dict2.dasm16
81
1
2f7f
88c3
    sub i, 1
dict2.dasm16
82
0

dict2.dasm16
83
2
2f80
5701
2f81
000c
    set push, [z+12]    ; dict
dict2.dasm16
84
1
2f82
1b01
    set push, i            ; index
dict2.dasm16
85
2
2f83
5701
2f84
fffd
    set push, [z-3]        ; tuple
dict2.dasm16
86
2
2f85
7c20
2f86
27b5
    jsr array__insert
dict2.dasm16
87
0

dict2.dasm16
88
2
2f87
7f81
2f88
2026
    set pc, postamble
dict2.dasm16
89
0

dict2.dasm16
90
0
;----------------------------------------------------------------
dict2.dasm16
91
0
; struct handle *dict_del(struct handle *dict, struct handle *key)
dict2.dasm16
92
0
; return x: struct handle *value or 0
dict2.dasm16
93
0
;----------------------------------------------------------------
dict2.dasm16
94
0
:dict_del
dict2.dasm16
95
1
2f89
8f01
    set push, 2
dict2.dasm16
96
1
2f8a
8f01
    set push, 2
dict2.dasm16
97
2
2f8b
7c20
2f8c
2039
    jsr preamble
dict2.dasm16
98
0

dict2.dasm16
99
3
2f8d
56a1
2f8e
000b
2f8f
ffff
    set [z-1], [z+11]
dict2.dasm16
100
2
2f90
5461
2f91
000a
    set x, [z+10]
dict2.dasm16
101
2
2f92
0ea1
2f93
fffe
    set [z-2], x
dict2.dasm16
102
0

dict2.dasm16
103
2
2f94
4f01
2f95
0001
    set push, [x + HANDLE_TYPE]
dict2.dasm16
104
2
2f96
7f32
2f97
0800
    ife peek, TYPE_NAME
dict2.dasm16
105
2
2f98
a661
2f99
0001
        set [x + HANDLE_TYPE], TYPE_STR
dict2.dasm16
106
0

dict2.dasm16
107
2
2f9a
7c21
2f9b
2f9e
    set b, dict__del__finish
dict2.dasm16
108
2
2f9c
7f81
2f9d
2fad
    set pc, dict__bin_search
dict2.dasm16
109
0

dict2.dasm16
110
0
:dict__del__finish
dict2.dasm16
111
1
2f9e
2fa0
    dat dict__del__match
dict2.dasm16
112
1
2f9f
2f4d
    dat dict__del__no_match
dict2.dasm16
113
0

dict2.dasm16
114
0
:dict__del__match
dict2.dasm16
115
2
2fa0
5421
2fa1
fffe
    set b, [z-2]
dict2.dasm16
116
2
2fa2
6221
2fa3
0001
    set [b + HANDLE_TYPE], pop    
dict2.dasm16
117
0

dict2.dasm16
118
1
2fa4
0043
    sub c, a
dict2.dasm16
119
1
2fa5
8843
    sub c, 1
dict2.dasm16
120
0

dict2.dasm16
121
2
2fa6
5401
2fa7
ffff
    set a, [z-1]
dict2.dasm16
122
1
2fa8
0821
    set b, c
dict2.dasm16
123
2
2fa9
7c20
2faa
278b
    jsr array__del
dict2.dasm16
124
0

dict2.dasm16
125
2
2fab
7c20
2fac
2026
    jsr postamble
dict2.dasm16
126
0

dict2.dasm16
127
0
;----------------------------------------------------------------
dict2.dasm16
128
0
:dict__bin_search
dict2.dasm16
129
0
; [z-1] struct handle *dict
dict2.dasm16
130
0
; [z-2] struct handle *key
dict2.dasm16
131
0
;----------------------------------------------------------------
dict2.dasm16
132
2
2fad
5401
2fae
ffff
    set a, [z-1]            ; struct handle *dict
dict2.dasm16
133
1
2faf
2001
    set a, [a]                ; struct dict *
dict2.dasm16
134
0

dict2.dasm16
135
1
2fb0
00de
    sti i, a                ; [0] item
dict2.dasm16
136
1
2fb1
00e1
    set j, a                ; [last] item
dict2.dasm16
137
1
2fb2
20e2
    add j, [a]
dict2.dasm16
138
0

dict2.dasm16
139
0
:dict__bin_search__loop
dict2.dasm16
140
1
2fb3
1cd4
    ifg i, j
dict2.dasm16
141
2
2fb4
4781
2fb5
0001
        set pc, [b + 1]
dict2.dasm16
142
0

dict2.dasm16
143
0
    ; calculate midpoint
dict2.dasm16
144
1
2fb6
1c41
    set c, j
dict2.dasm16
145
1
2fb7
1843
    sub c, i
dict2.dasm16
146
1
2fb8
8c46
    div c, 2
dict2.dasm16
147
1
2fb9
1842
    add c, i
dict2.dasm16
148
0

dict2.dasm16
149
1
2fba
2881
    set y, [c]                        ; struct handle *tuple
dict2.dasm16
150
1
2fbb
3081
    set y, [y]                        ; struct tuple *
dict2.dasm16
151
0
    
dict2.dasm16
152
2
2fbc
5701
2fbd
fffe
    set push, [z - 2]                ; search key
dict2.dasm16
153
2
2fbe
5301
2fbf
0001
    set push, [y + DICT_ITEM_KEY]    ; key in midpoint
dict2.dasm16
154
2
2fc0
7c20
2fc1
1dc0
    jsr val_cmp
dict2.dasm16
155
0
    
dict2.dasm16
156
1
2fc2
8872
    ife x, 1
dict2.dasm16
157
2
2fc3
7f81
2fc4
2fc9
        set pc, dict__bin_search__upper
dict2.dasm16
158
0

dict2.dasm16
159
1
2fc5
8072
    ife x, -1
dict2.dasm16
160
2
2fc6
7f81
2fc7
2fcd
        set pc, dict__bin_search__lower
dict2.dasm16
161
0

dict2.dasm16
162
1
2fc8
2781
    set pc, [b]
dict2.dasm16
163
0
    
dict2.dasm16
164
0
:dict__bin_search__upper
dict2.dasm16
165
1
2fc9
08c1
    set i, c
dict2.dasm16
166
1
2fca
88c2
    add i, 1
dict2.dasm16
167
2
2fcb
7f81
2fcc
2fb3
    set pc, dict__bin_search__loop
dict2.dasm16
168
0

dict2.dasm16
169
0
:dict__bin_search__lower
dict2.dasm16
170
1
2fcd
08e1
    set j, c
dict2.dasm16
171
1
2fce
88e3
    sub j, 1
dict2.dasm16
172
2
2fcf
7f81
2fd0
2fb3
    set pc, dict__bin_search__loop
dict2.dasm16
173
0

dict2.dasm16
174
0
;----------------------------------------------------------------
dict2.dasm16
175
0
; struct handle *dict_repr(struct handle *dict)
dict2.dasm16
176
0
;----------------------------------------------------------------
dict2.dasm16
177
0
:dict_repr
dict2.dasm16
178
1
2fd1
8b01
    set push, 1
dict2.dasm16
179
1
2fd2
8f01
    set push, 2
dict2.dasm16
180
2
2fd3
7c20
2fd4
2039
    jsr preamble
dict2.dasm16
181
0
    
dict2.dasm16
182
2
2fd5
5481
2fd6
000a
    set y, [z+10]
dict2.dasm16
183
0
    
dict2.dasm16
184
1
2fd7
af01
    set push, 10
dict2.dasm16
185
1
2fd8
a701
    set push, TYPE_STR
dict2.dasm16
186
2
2fd9
7c20
2fda
21d3
    jsr alloc
dict2.dasm16
187
2
2fdb
0ea1
2fdc
ffff
    set [z-1], x
dict2.dasm16
188
0

dict2.dasm16
189
1
2fdd
0f01
    set push, x
dict2.dasm16
190
2
2fde
7f01
2fdf
007b
    set push, '{'
dict2.dasm16
191
2
2fe0
7c20
2fe1
27d8
    jsr array__append
dict2.dasm16
192
0

dict2.dasm16
193
1
2fe2
84c1
    set i, 0                    ; index
dict2.dasm16
194
1
2fe3
3021
    set b, [y]                    ; struct list *
dict2.dasm16
195
1
2fe4
2421
    set b, [b]                    ; list.size
dict2.dasm16
196
0

dict2.dasm16
197
0
:dict_repr_loop
dict2.dasm16
198
1
2fe5
04d2
    ife i, b
dict2.dasm16
199
2
2fe6
7f81
2fe7
301e
        set pc, dict_repr_finish
dict2.dasm16
200
0

dict2.dasm16
201
1
2fe8
84d2
    ife i, 0
dict2.dasm16
202
2
2fe9
7f81
2fea
2ff1
        set pc, dict_repr_skip_comma
dict2.dasm16
203
0

dict2.dasm16
204
2
2feb
5701
2fec
ffff
    set push, [z-1]                    ; struct handle *str
dict2.dasm16
205
2
2fed
7f01
2fee
002c
    set push, ','
dict2.dasm16
206
2
2fef
7c20
2ff0
27d8
    jsr array__append
dict2.dasm16
207
0

dict2.dasm16
208
0
:dict_repr_skip_comma
dict2.dasm16
209
1
2ff1
3061
    set x, [y]                ; struct dict *
dict2.dasm16
210
1
2ff2
1862
    add x, i                ; current item
dict2.dasm16
211
0

dict2.dasm16
212
2
2ff3
4c41
2ff4
0001
    set c, [x+1]            ; struct handle *tuple
dict2.dasm16
213
1
2ff5
2861
    set x, [c]                ; struct tuple *
dict2.dasm16
214
2
2ff6
4c61
2ff7
0001
    set x, [x+1]            ; struct handle *key
dict2.dasm16
215
0

dict2.dasm16
216
1
2ff8
2861
    set x, [c]                ; struct tuple *
dict2.dasm16
217
2
2ff9
4f01
2ffa
0001
    set push, [x+1]
dict2.dasm16
218
2
2ffb
7c20
2ffc
2086
    jsr repr
dict2.dasm16
219
2
2ffd
0ea1
2ffe
fffe
    set [z-2], x
dict2.dasm16
220
0

dict2.dasm16
221
2
2fff
5701
3000
ffff
    set push, [z-1]
dict2.dasm16
222
2
3001
5701
3002
fffe
    set push, [z-2]
dict2.dasm16
223
2
3003
7c20
3004
283b
    jsr array_merge
dict2.dasm16
224
2
3005
0ea1
3006
ffff
    set [z-1], x
dict2.dasm16
225
0

dict2.dasm16
226
2
3007
5701
3008
ffff
    set push, [z-1]
dict2.dasm16
227
2
3009
7f01
300a
003a
    set push, ':'
dict2.dasm16
228
2
300b
7c20
300c
27d8
    jsr array__append
dict2.dasm16
229
0

dict2.dasm16
230
1
300d
2861
    set x, [c]                ; struct tuple *
dict2.dasm16
231
2
300e
4f01
300f
0002
    set push, [x+2]
dict2.dasm16
232
2
3010
7c20
3011
2086
    jsr repr
dict2.dasm16
233
2
3012
0ea1
3013
fffe
    set [z-2], x
dict2.dasm16
234
0

dict2.dasm16
235
2
3014
5701
3015
ffff
    set push, [z-1]
dict2.dasm16
236
2
3016
5701
3017
fffe
    set push, [z-2]
dict2.dasm16
237
2
3018
7c20
3019
283b
    jsr array_merge
dict2.dasm16
238
2
301a
0ea1
301b
ffff
    set [z-1], x
dict2.dasm16
239
0

dict2.dasm16
240
2
301c
7f9e
301d
2fe5
    sti pc, dict_repr_loop
dict2.dasm16
241
0
        
dict2.dasm16
242
0
:dict_repr_finish
dict2.dasm16
243
2
301e
5701
301f
ffff
    set push, [z-1]
dict2.dasm16
244
2
3020
7f01
3021
007d
    set push, '}'
dict2.dasm16
245
2
3022
7c20
3023
27d8
    jsr array__append
dict2.dasm16
246
0

dict2.dasm16
247
2
3024
5461
3025
ffff
    set x, [z-1]
dict2.dasm16
248
2
3026
7c20
3027
2026
    jsr postamble
floppy.dasm16
0
0
;----------------------------------------------------------------
floppy.dasm16
1
0
; admiral floppy functions
floppy.dasm16
2
0
;  void format(void)
floppy.dasm16
3
0
;  item dir(void)
floppy.dasm16
4
0
;  item load(filename)
floppy.dasm16
5
0
;  void save(filename, item)
floppy.dasm16
6
0
;  void del(filename)
floppy.dasm16
7
0
;  void read(sector)
floppy.dasm16
8
0
;  void write(sector)
floppy.dasm16
9
0
;----------------------------------------------------------------
floppy.dasm16
10
0
; SECTOR 0: MBR
floppy.dasm16
11
0
; 
floppy.dasm16
12
0
; SECTOR 0 always contains the following 4 words.
floppy.dasm16
13
0
; 
floppy.dasm16
14
0
; 0x0000 MBR_FREE_HEAD  The first sector in free-sectors-list (1-1439)
floppy.dasm16
15
0
; 0x0001 MBR_FREE_TAIL  The last sector in free-sectors-list (1-1439) 
floppy.dasm16
16
0
; 0x0002 MBR_DIR_HEAD   The first sector in directory-dict (1-1439)
floppy.dasm16
17
0
; 0x0003 MBR_DIR_TAIL   The last sector in directory-dict (1-1439)
floppy.dasm16
18
0
; 
floppy.dasm16
19
0
; SECTOR 1-1439: DATA
floppy.dasm16
20
0
; 
floppy.dasm16
21
0
; 0x0000 SECTOR_NEXT    Next data sector (1-1439)
floppy.dasm16
22
0
; 0x0001-0x01ff DATA    Serialized object data
floppy.dasm16
23
0
; 
floppy.dasm16
24
0
; Serialization Format
floppy.dasm16
25
0
; 
floppy.dasm16
26
0
; 0x0001 ID    (if 0 -> no more items in graph)
floppy.dasm16
27
0
; 0x0002 TYPE
floppy.dasm16
28
0
; 0x0003 SIZE
floppy.dasm16
29
0
;        DATA
floppy.dasm16
30
0
;----------------------------------------------------------------
floppy.dasm16
31
0

floppy.dasm16
32
0
;----------------------------------------------------------------
floppy.dasm16
33
0
; extern void file__format()
floppy.dasm16
34
0
;----------------------------------------------------------------
floppy.dasm16
35
0
:floppy__format
floppy.dasm16
36
1
3028
8701
    set push, 0
floppy.dasm16
37
1
3029
8b01
    set push, 1
floppy.dasm16
38
2
302a
7c20
302b
2039
    jsr preamble
floppy.dasm16
39
0

floppy.dasm16
40
1
302c
8401
    set a, 0
floppy.dasm16
41
2
302d
7a40
302e
0252
    hwi [floppy]
floppy.dasm16
42
0
    ;set b, FLOPPY__STATE__READY
floppy.dasm16
43
1
302f
8833
    ifn b, FLOPPY__STATE__READY
floppy.dasm16
44
2
3030
7c20
3031
00c6
        jsr recover
floppy.dasm16
45
0
    
floppy.dasm16
46
0
    ;---------------------------------------
floppy.dasm16
47
0
    ; initialize mbr
floppy.dasm16
48
0
    ;---------------------------------------
floppy.dasm16
49
2
3032
8bc1
3033
0246
    set [floppy__free__head], 1
floppy.dasm16
50
3
3034
7fc1
3035
059f
3036
0247
    set [floppy__free__tail], 1439
floppy.dasm16
51
2
3037
8bc1
3038
0248
    set [floppy__dir__head], 1
floppy.dasm16
52
2
3039
8bc1
303a
0249
    set [floppy__dir__tail], 1
floppy.dasm16
53
0
    
floppy.dasm16
54
0
    ;---------------------------------------
floppy.dasm16
55
0
    ; initialize data sectors
floppy.dasm16
56
0
    ;---------------------------------------
floppy.dasm16
57
1
303b
88c1
    set i, 1        ; current sector
floppy.dasm16
58
1
303c
8ce1
    set j, 2        ; next sector
floppy.dasm16
59
0
:floppy__format__next_sector
floppy.dasm16
60
2
303d
7cf2
303e
05a0
    ife j, 1440
floppy.dasm16
61
1
303f
84e1
        set j, 0
floppy.dasm16
62
0

floppy.dasm16
63
2
3040
1fc1
3041
d980
    set [FLOPPY__SECTOR__NEXT], j
floppy.dasm16
64
0
    
floppy.dasm16
65
1
3042
1b01
    set push, i
floppy.dasm16
66
2
3043
7c20
3044
311d
    jsr floppy__sector__write
floppy.dasm16
67
0

floppy.dasm16
68
1
3045
84f3
    ifn j, 0
floppy.dasm16
69
2
3046
7f9e
3047
303d
        sti pc, floppy__format__next_sector
floppy.dasm16
70
0

floppy.dasm16
71
0
    ;---------------------------------------
floppy.dasm16
72
0
    ; create empty dir
floppy.dasm16
73
0
    ;---------------------------------------
floppy.dasm16
74
1
3048
8701
    set push, 0
floppy.dasm16
75
1
3049
8b01
    set push, TYPE_DICT
floppy.dasm16
76
2
304a
7c20
304b
2770
    jsr array_create
floppy.dasm16
77
2
304c
0ea1
304d
ffff
    set [z-1], x
floppy.dasm16
78
0

floppy.dasm16
79
2
304e
5701
304f
ffff
    set push, [z-1]
floppy.dasm16
80
2
3050
7c20
3051
316e
    jsr floppy__item__write
floppy.dasm16
81
0

floppy.dasm16
82
2
3052
7c20
3053
310d
    jsr floppy__mbr__write
floppy.dasm16
83
0
    
floppy.dasm16
84
2
3054
5461
3055
ffff
    set x, [z-1]
floppy.dasm16
85
2
3056
7f81
3057
2026
    set pc, postamble
floppy.dasm16
86
0
    
floppy.dasm16
87
0
;----------------------------------------------------------------
floppy.dasm16
88
0
; extern struct handle *floppy__dir__read(void)
floppy.dasm16
89
0
;----------------------------------------------------------------
floppy.dasm16
90
0
:floppy__dir__read
floppy.dasm16
91
0
    ;---------------------------------------
floppy.dasm16
92
0
    ; read mbr
floppy.dasm16
93
0
    ;---------------------------------------
floppy.dasm16
94
2
3058
7c20
3059
30fd
    jsr floppy__mbr__read
floppy.dasm16
95
0

floppy.dasm16
96
0
    ;---------------------------------------
floppy.dasm16
97
0
    ; read directory
floppy.dasm16
98
0
    ;---------------------------------------
floppy.dasm16
99
2
305a
7b01
305b
0248
    set push, [floppy__dir__head]
floppy.dasm16
100
2
305c
7b01
305d
0249
    set push, [floppy__dir__tail]
floppy.dasm16
101
2
305e
7c20
305f
31d9
    jsr floppy__item__read
floppy.dasm16
102
0

floppy.dasm16
103
1
3060
6381
    set pc, pop
floppy.dasm16
104
0

floppy.dasm16
105
0
;----------------------------------------------------------------
floppy.dasm16
106
0
; extern struct handle *floppy__file__write(struct handle *filename, struct handle *item)
floppy.dasm16
107
0
;----------------------------------------------------------------
floppy.dasm16
108
0
:floppy__file__write
floppy.dasm16
109
1
3061
8f01
    set push, 2
floppy.dasm16
110
1
3062
8f01
    set push, 2
floppy.dasm16
111
2
3063
7c20
3064
2039
    jsr preamble
floppy.dasm16
112
0
    
floppy.dasm16
113
0
    ; read mbr
floppy.dasm16
114
2
3065
7c20
3066
30fd
    jsr floppy__mbr__read
floppy.dasm16
115
0

floppy.dasm16
116
0
    ; write item
floppy.dasm16
117
2
3067
5701
3068
000a
    set push, [z+10]
floppy.dasm16
118
2
3069
7c20
306a
316e
    jsr floppy__item__write
floppy.dasm16
119
2
306b
0ea1
306c
ffff
    set [z-1], x                ; struct handle *inode
floppy.dasm16
120
0

floppy.dasm16
121
0
    ; read directory
floppy.dasm16
122
2
306d
7b01
306e
0248
    set push, [floppy__dir__head]
floppy.dasm16
123
2
306f
7b01
3070
0249
    set push, [floppy__dir__tail]
floppy.dasm16
124
2
3071
7c20
3072
31d9
    jsr floppy__item__read
floppy.dasm16
125
2
3073
0ea1
3074
fffe
    set [z-2], x
floppy.dasm16
126
0

floppy.dasm16
127
0
    ; filename IN dir?
floppy.dasm16
128
1
3075
0f01
    set push, x
floppy.dasm16
129
2
3076
5701
3077
000b
    set push, [z+11]
floppy.dasm16
130
2
3078
7c20
3079
2f2e
    jsr dict_get
floppy.dasm16
131
0
    
floppy.dasm16
132
1
307a
8472
    ife x, 0
floppy.dasm16
133
2
307b
7f81
307c
3082
        set pc, floppy__file__write__update_dir
floppy.dasm16
134
0

floppy.dasm16
135
0
    ; free previous item
floppy.dasm16
136
1
307d
0f01
    set push, x
floppy.dasm16
137
2
307e
7f01
307f
315a
    set push, floppy__file__free
floppy.dasm16
138
2
3080
7c20
3081
3145
    jsr floppy__inode__wrapper
floppy.dasm16
139
0

floppy.dasm16
140
0
:floppy__file__write__update_dir
floppy.dasm16
141
0
    ; update dir
floppy.dasm16
142
2
3082
5701
3083
fffe
    set push, [z-2]
floppy.dasm16
143
2
3084
5701
3085
000b
    set push, [z+11]
floppy.dasm16
144
2
3086
5701
3087
ffff
    set push, [z-1]
floppy.dasm16
145
2
3088
7c20
3089
2f54
    jsr dict__set
floppy.dasm16
146
0

floppy.dasm16
147
0
    ; write updated dir
floppy.dasm16
148
2
308a
5701
308b
fffe
    set push, [z-2]
floppy.dasm16
149
2
308c
7c20
308d
30dc
    jsr floppy__dir__write
floppy.dasm16
150
0

floppy.dasm16
151
0
    ; store mbr
floppy.dasm16
152
2
308e
7c20
308f
310d
    jsr floppy__mbr__write
floppy.dasm16
153
0

floppy.dasm16
154
2
3090
5461
3091
ffff
    set x, [z-1]                    ; return inode for no reason
floppy.dasm16
155
2
3092
7f81
3093
2026
    set pc, postamble
floppy.dasm16
156
0

floppy.dasm16
157
0
;----------------------------------------------------------------
floppy.dasm16
158
0
; extern struct handle *floppy__file__read(struct handle *filename)
floppy.dasm16
159
0
;----------------------------------------------------------------
floppy.dasm16
160
0
:floppy__file__read
floppy.dasm16
161
1
3094
8b01
    set push, 1
floppy.dasm16
162
1
3095
8b01
    set push, 1
floppy.dasm16
163
2
3096
7c20
3097
2039
    jsr preamble
floppy.dasm16
164
0
    
floppy.dasm16
165
0
    ; read mbr
floppy.dasm16
166
2
3098
7c20
3099
30fd
    jsr floppy__mbr__read
floppy.dasm16
167
0

floppy.dasm16
168
0
    ; read directory
floppy.dasm16
169
2
309a
7b01
309b
0248
    set push, [floppy__dir__head]
floppy.dasm16
170
2
309c
7b01
309d
0249
    set push, [floppy__dir__tail]
floppy.dasm16
171
2
309e
7c20
309f
31d9
    jsr floppy__item__read
floppy.dasm16
172
2
30a0
0ea1
30a1
ffff
    set [z-1], x
floppy.dasm16
173
0
    
floppy.dasm16
174
0
    ; filename IN dir?
floppy.dasm16
175
1
30a2
0f01
    set push, x
floppy.dasm16
176
2
30a3
5701
30a4
000a
    set push, [z+10]
floppy.dasm16
177
2
30a5
7c20
30a6
2f2e
    jsr dict_get
floppy.dasm16
178
0
    
floppy.dasm16
179
1
30a7
8472
    ife x, 0
floppy.dasm16
180
2
30a8
7c20
30a9
00c6
        jsr recover
floppy.dasm16
181
0

floppy.dasm16
182
1
30aa
0f01
    set push, x
floppy.dasm16
183
2
30ab
7f01
30ac
31d9
    set push, floppy__item__read
floppy.dasm16
184
2
30ad
7c20
30ae
3145
    jsr floppy__inode__wrapper
floppy.dasm16
185
0

floppy.dasm16
186
2
30af
7f81
30b0
2026
    set pc, postamble
floppy.dasm16
187
0

floppy.dasm16
188
0
;----------------------------------------------------------------
floppy.dasm16
189
0
; extern void floppy__file__delete(struct handle *filename)
floppy.dasm16
190
0
;----------------------------------------------------------------
floppy.dasm16
191
0
:floppy__file__delete
floppy.dasm16
192
1
30b1
8b01
    set push, 1
floppy.dasm16
193
1
30b2
8f01
    set push, 2
floppy.dasm16
194
2
30b3
7c20
30b4
2039
    jsr preamble
floppy.dasm16
195
0
    
floppy.dasm16
196
0
    ; read mbr
floppy.dasm16
197
2
30b5
7c20
30b6
30fd
    jsr floppy__mbr__read
floppy.dasm16
198
0

floppy.dasm16
199
0
    ; read directory
floppy.dasm16
200
2
30b7
7b01
30b8
0248
    set push, [floppy__dir__head]
floppy.dasm16
201
2
30b9
7b01
30ba
0249
    set push, [floppy__dir__tail]
floppy.dasm16
202
2
30bb
7c20
30bc
31d9
    jsr floppy__item__read
floppy.dasm16
203
2
30bd
0ea1
30be
ffff
    set [z-1], x
floppy.dasm16
204
0
    
floppy.dasm16
205
0
    ; filename IN dir?
floppy.dasm16
206
1
30bf
0f01
    set push, x
floppy.dasm16
207
2
30c0
5701
30c1
000a
    set push, [z+10]
floppy.dasm16
208
2
30c2
7c20
30c3
2f2e
    jsr dict_get
floppy.dasm16
209
0

floppy.dasm16
210
1
30c4
8472
    ife x, 0
floppy.dasm16
211
2
30c5
7c20
30c6
00c6
        jsr recover
floppy.dasm16
212
0

floppy.dasm16
213
0
    ; free item
floppy.dasm16
214
1
30c7
0f01
    set push, x
floppy.dasm16
215
2
30c8
7f01
30c9
315a
    set push, floppy__file__free
floppy.dasm16
216
2
30ca
7c20
30cb
3145
    jsr floppy__inode__wrapper
floppy.dasm16
217
0
    
floppy.dasm16
218
0
    ; update dir
floppy.dasm16
219
2
30cc
5701
30cd
ffff
    set push, [z-1]
floppy.dasm16
220
2
30ce
5701
30cf
000a
    set push, [z+10]
floppy.dasm16
221
2
30d0
7c20
30d1
2f89
    jsr dict_del
floppy.dasm16
222
0

floppy.dasm16
223
0
    ; write updated dir
floppy.dasm16
224
2
30d2
5701
30d3
ffff
    set push, [z-1]
floppy.dasm16
225
2
30d4
7c20
30d5
30dc
    jsr floppy__dir__write
floppy.dasm16
226
0

floppy.dasm16
227
2
30d6
7c20
30d7
310d
    jsr floppy__mbr__write
floppy.dasm16
228
0

floppy.dasm16
229
2
30d8
5461
30d9
ffff
    set x, [z-1]
floppy.dasm16
230
2
30da
7f81
30db
2026
    set pc, postamble
floppy.dasm16
231
0

floppy.dasm16
232
0
;----------------------------------------------------------------
floppy.dasm16
233
0
; struct handle *floppy__dir__write(struct handle *dir)
floppy.dasm16
234
0
;  - modifies mbr data
floppy.dasm16
235
0
;----------------------------------------------------------------
floppy.dasm16
236
0
:floppy__dir__write
floppy.dasm16
237
1
30dc
8b01
    set push, 1
floppy.dasm16
238
1
30dd
8b01
    set push, 1
floppy.dasm16
239
2
30de
7c20
30df
2039
    jsr preamble
floppy.dasm16
240
0

floppy.dasm16
241
0
    ; write updated dir
floppy.dasm16
242
2
30e0
5701
30e1
000a
    set push, [z+10]
floppy.dasm16
243
2
30e2
7c20
30e3
316e
    jsr floppy__item__write
floppy.dasm16
244
2
30e4
0ea1
30e5
ffff
    set [z-1], x                    ; struct handle *inode
floppy.dasm16
245
1
30e6
2c81
    set y, [x]                        ; struct inode *
floppy.dasm16
246
0

floppy.dasm16
247
0
    ; free old dir
floppy.dasm16
248
2
30e7
7b01
30e8
0248
    set push, [floppy__dir__head]
floppy.dasm16
249
2
30e9
7b01
30ea
0249
    set push, [floppy__dir__tail]
floppy.dasm16
250
2
30eb
7c20
30ec
315a
    jsr floppy__file__free
floppy.dasm16
251
0

floppy.dasm16
252
0
    ; update dir pointers
floppy.dasm16
253
2
30ed
5301
30ee
0001
    set push, [y + INODE__SECTOR__HEAD]        ; struct handle *int
floppy.dasm16
254
2
30ef
7c20
30f0
22bc
    jsr int_to_int16
floppy.dasm16
255
2
30f1
0fc1
30f2
0248
    set [floppy__dir__head], x                ; uint16 dir_head
floppy.dasm16
256
0
    
floppy.dasm16
257
2
30f3
5301
30f4
0002
    set push, [y + INODE__SECTOR__TAIL]        ; struct handle *int
floppy.dasm16
258
2
30f5
7c20
30f6
22bc
    jsr int_to_int16
floppy.dasm16
259
2
30f7
0fc1
30f8
0249
    set [floppy__dir__tail], x                ; uint16 dir_head
floppy.dasm16
260
0

floppy.dasm16
261
2
30f9
5461
30fa
ffff
    set x, [z-1]
floppy.dasm16
262
2
30fb
7f81
30fc
2026
    set pc, postamble
floppy.dasm16
263
0

floppy.dasm16
264
0
;----------------------------------------------------------------
floppy.dasm16
265
0
:floppy__mbr__read
floppy.dasm16
266
0
;----------------------------------------------------------------
floppy.dasm16
267
1
30fd
8701
    set push, FLOPPY__MBR__SECTOR
floppy.dasm16
268
2
30fe
7c20
30ff
312c
    jsr floppy__sector__read
floppy.dasm16
269
0

floppy.dasm16
270
3
3100
7bc1
3101
d980
3102
0246
    set [floppy__free__head], [FLOPPY__MBR__FREE_HEAD]
floppy.dasm16
271
3
3103
7bc1
3104
d981
3105
0247
    set [floppy__free__tail], [FLOPPY__MBR__FREE_TAIL]
floppy.dasm16
272
3
3106
7bc1
3107
d982
3108
0248
    set [floppy__dir__head], [FLOPPY__MBR__DIR_HEAD]
floppy.dasm16
273
3
3109
7bc1
310a
d983
310b
0249
    set [floppy__dir__tail], [FLOPPY__MBR__DIR_TAIL]
floppy.dasm16
274
0

floppy.dasm16
275
1
310c
6381
    set pc, pop
floppy.dasm16
276
0

floppy.dasm16
277
0
;----------------------------------------------------------------
floppy.dasm16
278
0
:floppy__mbr__write
floppy.dasm16
279
0
;----------------------------------------------------------------
floppy.dasm16
280
3
310d
7bc1
310e
0246
310f
d980
    set [FLOPPY__MBR__FREE_HEAD], [floppy__free__head]
floppy.dasm16
281
3
3110
7bc1
3111
0247
3112
d981
    set [FLOPPY__MBR__FREE_TAIL], [floppy__free__tail]
floppy.dasm16
282
3
3113
7bc1
3114
0248
3115
d982
    set [FLOPPY__MBR__DIR_HEAD], [floppy__dir__head]
floppy.dasm16
283
3
3116
7bc1
3117
0249
3118
d983
    set [FLOPPY__MBR__DIR_TAIL], [floppy__dir__tail]
floppy.dasm16
284
0

floppy.dasm16
285
1
3119
8701
    set push, FLOPPY__MBR__SECTOR
floppy.dasm16
286
2
311a
7c20
311b
311d
    jsr floppy__sector__write
floppy.dasm16
287
0
    
floppy.dasm16
288
1
311c
6381
    set pc, pop
floppy.dasm16
289
0

floppy.dasm16
290
0
;----------------------------------------------------------------
floppy.dasm16
291
0
; void floppy__sector__write(uint16 sector)
floppy.dasm16
292
0
;----------------------------------------------------------------
floppy.dasm16
293
0
:floppy__sector__write
floppy.dasm16
294
1
311d
8b01
    set push, 1
floppy.dasm16
295
1
311e
8701
    set push, 0
floppy.dasm16
296
2
311f
7c20
3120
2039
    jsr preamble
floppy.dasm16
297
0

floppy.dasm16
298
0
    ;---------------------------------------
floppy.dasm16
299
0
    ; initiate write
floppy.dasm16
300
0
    ;---------------------------------------
floppy.dasm16
301
1
3121
9001
    set a, 3
floppy.dasm16
302
2
3122
5461
3123
000a
    set x, [z + 10]
floppy.dasm16
303
2
3124
7c81
3125
d980
    set y, MEM_FLOPPY_START
floppy.dasm16
304
2
3126
7a40
3127
0252
    hwi [floppy]
floppy.dasm16
305
0
    ;---------------------------------------
floppy.dasm16
306
2
3128
7c20
3129
313e
    jsr floppy__status__wait_ready
floppy.dasm16
307
0

floppy.dasm16
308
2
312a
7f81
312b
2026
    set pc, postamble
floppy.dasm16
309
0

floppy.dasm16
310
0
;----------------------------------------------------------------
floppy.dasm16
311
0
; void file__sector__read(uint16 _sector)
floppy.dasm16
312
0
;----------------------------------------------------------------
floppy.dasm16
313
0
:floppy__sector__read
floppy.dasm16
314
1
312c
8b01
    set push, 1
floppy.dasm16
315
1
312d
8701
    set push, 0
floppy.dasm16
316
2
312e
7c20
312f
2039
    jsr preamble
floppy.dasm16
317
0
    
floppy.dasm16
318
0
    ;---------------------------------------
floppy.dasm16
319
0
    ; initiate read
floppy.dasm16
320
0
    ;---------------------------------------
floppy.dasm16
321
1
3130
8c01
    set a, 2                    ; read from floppy
floppy.dasm16
322
2
3131
5461
3132
000a
    set x, [z + 10]                ; _sector
floppy.dasm16
323
2
3133
7c81
3134
d980
    set y, MEM_FLOPPY_START
floppy.dasm16
324
2
3135
7a40
3136
0252
    hwi [floppy]
floppy.dasm16
325
0
    ;---------------------------------------
floppy.dasm16
326
2
3137
7c20
3138
313e
    jsr floppy__status__wait_ready
floppy.dasm16
327
0

floppy.dasm16
328
0
    ; reset buffer pointer
floppy.dasm16
329
3
3139
7fc1
313a
d981
313b
0245
    set [floppy__buffer__position], FLOPPY__SECTOR__DATA
floppy.dasm16
330
0

floppy.dasm16
331
2
313c
7f81
313d
2026
    set pc, postamble
floppy.dasm16
332
0

floppy.dasm16
333
0
;----------------------------------------------------------------
floppy.dasm16
334
0
:floppy__status__wait_ready
floppy.dasm16
335
0
;----------------------------------------------------------------
floppy.dasm16
336
1
313e
8401
    set a, 0
floppy.dasm16
337
0
:floppy__status__wait_ready__loop
floppy.dasm16
338
2
313f
7a40
3140
0252
    hwi [floppy]
floppy.dasm16
339
0
    ;set b, FLOPPY__STATE__READY
floppy.dasm16
340
1
3141
9032
    ife b, FLOPPY__STATE__BUSY
floppy.dasm16
341
2
3142
7f81
3143
313f
        set pc, floppy__status__wait_ready__loop
floppy.dasm16
342
0

floppy.dasm16
343
1
3144
6381
    set pc, pop
floppy.dasm16
344
0

floppy.dasm16
345
0
;----------------------------------------------------------------
floppy.dasm16
346
0
; struct handle *floppy__inode__wrapper(struct handle *inode, uint16 *func)
floppy.dasm16
347
0
;----------------------------------------------------------------
floppy.dasm16
348
0
:floppy__inode__wrapper
floppy.dasm16
349
1
3145
8f01
    set push, 2
floppy.dasm16
350
1
3146
8701
    set push, 0
floppy.dasm16
351
2
3147
7c20
3148
2039
    jsr preamble
floppy.dasm16
352
0
    
floppy.dasm16
353
2
3149
5401
314a
000b
    set a, [z + 11]                            ; struct handle *inode
floppy.dasm16
354
1
314b
2001
    set a, [a]                                ; struct inode *
floppy.dasm16
355
0

floppy.dasm16
356
2
314c
4301
314d
0001
    set push, [a + INODE__SECTOR__HEAD]        ; struct handle *int
floppy.dasm16
357
2
314e
7c20
314f
22bc
    jsr int_to_int16
floppy.dasm16
358
1
3150
0f01
    set push, x                                ; uint16 sector_head
floppy.dasm16
359
0
    
floppy.dasm16
360
2
3151
4301
3152
0002
    set push, [a + INODE__SECTOR__TAIL]        ; struct handle *int
floppy.dasm16
361
2
3153
7c20
3154
22bc
    jsr int_to_int16
floppy.dasm16
362
1
3155
0f01
    set push, x                                ; uint16 sector_tail
floppy.dasm16
363
0

floppy.dasm16
364
2
3156
5420
3157
000a
    jsr [z+10]
floppy.dasm16
365
0

floppy.dasm16
366
2
3158
7f81
3159
2026
    set pc, postamble
floppy.dasm16
367
0

floppy.dasm16
368
0
;----------------------------------------------------------------
floppy.dasm16
369
0
; struct handle *floppy__file__free(uint16 sector_head, uint16 sector_tail)
floppy.dasm16
370
0
; - modifies mbr
floppy.dasm16
371
0
;----------------------------------------------------------------
floppy.dasm16
372
0
:floppy__file__free
floppy.dasm16
373
1
315a
8f01
    set push, 2
floppy.dasm16
374
1
315b
8701
    set push, 0
floppy.dasm16
375
2
315c
7c20
315d
2039
    jsr preamble
floppy.dasm16
376
0

floppy.dasm16
377
2
315e
7b01
315f
0247
    set push, [floppy__free__tail]
floppy.dasm16
378
2
3160
7c20
3161
312c
    jsr floppy__sector__read
floppy.dasm16
379
0

floppy.dasm16
380
3
3162
57c1
3163
000b
3164
d980
    set [FLOPPY__SECTOR__NEXT], [z + 11]
floppy.dasm16
381
0

floppy.dasm16
382
2
3165
7b01
3166
0247
    set push, [floppy__free__tail]
floppy.dasm16
383
2
3167
7c20
3168
311d
    jsr floppy__sector__write
floppy.dasm16
384
0

floppy.dasm16
385
3
3169
57c1
316a
000a
316b
0247
    set [floppy__free__tail], [z + 10]
floppy.dasm16
386
0

floppy.dasm16
387
2
316c
7f81
316d
2026
    set pc, postamble
floppy.dasm16
388
0

floppy.dasm16
389
0
;----------------------------------------------------------------
floppy.dasm16
390
0
; struct handle *floppy__item__write(struct handle *item)
floppy.dasm16
391
0
;----------------------------------------------------------------
floppy.dasm16
392
0
:floppy__item__write
floppy.dasm16
393
1
316e
8b01
    set push, 1
floppy.dasm16
394
1
316f
8b01
    set push, 1
floppy.dasm16
395
2
3170
7c20
3171
2039
    jsr preamble
floppy.dasm16
396
0

floppy.dasm16
397
0
    ;---------------------------------------
floppy.dasm16
398
0
    ; write file to free space
floppy.dasm16
399
0
    ;---------------------------------------
floppy.dasm16
400
2
3172
7801
3173
0246
    set a, [floppy__free__head]                ; inode.head
floppy.dasm16
401
0
    
floppy.dasm16
402
1
3174
0301
    set push, a
floppy.dasm16
403
2
3175
7c20
3176
3243
    jsr floppy__file__open
floppy.dasm16
404
0

floppy.dasm16
405
0
    ; serialize object
floppy.dasm16
406
2
3177
5701
3178
000a
    set push, [z+10]
floppy.dasm16
407
2
3179
7c20
317a
319b
    jsr floppy__item__serialize
floppy.dasm16
408
0

floppy.dasm16
409
2
317b
7821
317c
0246
    set b, [floppy__free__head]                ; inode.tail
floppy.dasm16
410
2
317d
7841
317e
0244
    set c, [floppy__file__position]            ; inode.size
floppy.dasm16
411
0

floppy.dasm16
412
0
    ;---------------------------------------
floppy.dasm16
413
0
    ; terminate file
floppy.dasm16
414
0
    ;---------------------------------------
floppy.dasm16
415
2
317f
7c20
3180
324b
    jsr floppy__file__close
floppy.dasm16
416
0
    
floppy.dasm16
417
0
    ;---------------------------------------
floppy.dasm16
418
0
    ; return struct handle *inode (sector, size)
floppy.dasm16
419
0
    ;---------------------------------------
floppy.dasm16
420
1
3181
9301
    set push, 3
floppy.dasm16
421
1
3182
9701
    set push, TYPE_TUPLE
floppy.dasm16
422
2
3183
7c20
3184
2770
    jsr array_create
floppy.dasm16
423
2
3185
0ea1
3186
ffff
    set [z-1], x
floppy.dasm16
424
0

floppy.dasm16
425
1
3187
2c81
    set y, [x]
floppy.dasm16
426
0

floppy.dasm16
427
1
3188
0301
    set push, a                    ; inode.head
floppy.dasm16
428
2
3189
7c20
318a
22a2
    jsr uint16_to_int
floppy.dasm16
429
2
318b
0e81
318c
0001
    set [y + INODE__SECTOR__HEAD], x
floppy.dasm16
430
0
    
floppy.dasm16
431
1
318d
0701
    set push, b                    ; inode.tail
floppy.dasm16
432
2
318e
7c20
318f
22a2
    jsr uint16_to_int
floppy.dasm16
433
2
3190
0e81
3191
0002
    set [y + INODE__SECTOR__TAIL], x
floppy.dasm16
434
0
    
floppy.dasm16
435
1
3192
0b01
    set push, c                    ; inode.size
floppy.dasm16
436
2
3193
7c20
3194
22a2
    jsr uint16_to_int
floppy.dasm16
437
2
3195
0e81
3196
0003
    set [y + INODE__SIZE], x
floppy.dasm16
438
0
    
floppy.dasm16
439
2
3197
5461
3198
ffff
    set x, [z-1]
floppy.dasm16
440
2
3199
7f81
319a
2026
    set pc, postamble
floppy.dasm16
441
0

floppy.dasm16
442
0
;----------------------------------------------------------------
floppy.dasm16
443
0
; struct handle *floppy__item__serialize(struct handle *item)
floppy.dasm16
444
0
;----------------------------------------------------------------
floppy.dasm16
445
0
:floppy__item__serialize
floppy.dasm16
446
1
319b
8b01
    set push, 1
floppy.dasm16
447
1
319c
8701
    set push, 0
floppy.dasm16
448
2
319d
7c20
319e
2039
    jsr preamble
floppy.dasm16
449
0
    
floppy.dasm16
450
1
319f
6c01
    set a, sp                    ; done.end
floppy.dasm16
451
1
31a0
6c21
    set b, sp
floppy.dasm16
452
0

floppy.dasm16
453
2
31a1
5701
31a2
000a
    set push, [z+10]            ; put root item to queue
floppy.dasm16
454
0

floppy.dasm16
455
0
:floppy__item__serialize__next_item
floppy.dasm16
456
1
31a3
8823
    sub b, 1                    ; take next item in fifo order
floppy.dasm16
457
0

floppy.dasm16
458
0
    ;---------------------------------------
floppy.dasm16
459
0
    ; write ID
floppy.dasm16
460
0
    ;---------------------------------------
floppy.dasm16
461
1
31a4
2481
    set y, [b]                    ; id == struct handle *
floppy.dasm16
462
1
31a5
1301
    set push, y
floppy.dasm16
463
2
31a6
7c20
31a7
3256
    jsr floppy__word__write
floppy.dasm16
464
0

floppy.dasm16
465
0
    ;---------------------------------------
floppy.dasm16
466
0
    ; write TYPE
floppy.dasm16
467
0
    ;---------------------------------------
floppy.dasm16
468
2
31a8
5041
31a9
0001
    set c, [y + HANDLE_TYPE]
floppy.dasm16
469
1
31aa
0b01
    set push, c                 ; type
floppy.dasm16
470
2
31ab
7c20
31ac
3256
    jsr floppy__word__write
floppy.dasm16
471
0

floppy.dasm16
472
0
    ;---------------------------------------
floppy.dasm16
473
0
    ; write SIZE (actual)
floppy.dasm16
474
0
    ;---------------------------------------
floppy.dasm16
475
1
31ad
3081
    set y, [y]                  ; move y to data
floppy.dasm16
476
0
 
floppy.dasm16
477
1
31ae
30e1
    set j, [y]                    ; array size
floppy.dasm16
478
1
31af
88e2
    add j, 1
floppy.dasm16
479
0

floppy.dasm16
480
2
31b0
7c50
31b1
0040
    ifb c, TYPE_FLOAT            ; if item is float
floppy.dasm16
481
1
31b2
94e1
        set j, SIZEOF_FLOAT        ; float size
floppy.dasm16
482
0

floppy.dasm16
483
1
31b3
1f01
    set push, j
floppy.dasm16
484
2
31b4
7c20
31b5
3256
    jsr floppy__word__write
floppy.dasm16
485
0

floppy.dasm16
486
0
    ;---------------------------------------
floppy.dasm16
487
0
    ; write DATA
floppy.dasm16
488
0
    ;---------------------------------------
floppy.dasm16
489
1
31b6
10c1
    set i, y
floppy.dasm16
490
2
31b7
7c51
31b8
0040
    ifc c, TYPE_FLOAT
floppy.dasm16
491
1
31b9
88c2
        add i, 1
floppy.dasm16
492
0
    
floppy.dasm16
493
1
31ba
1c82
    add y, j
floppy.dasm16
494
0

floppy.dasm16
495
0
:floppy__item__serialize__data__loop
floppy.dasm16
496
1
31bb
10d2
    ife i, y                    
floppy.dasm16
497
1
31bc
0776
        ifl sp, b
floppy.dasm16
498
2
31bd
7f81
31be
31a3
            set pc, floppy__item__serialize__next_item
floppy.dasm16
499
0

floppy.dasm16
500
1
31bf
10d2
    ife i, y
floppy.dasm16
501
2
31c0
7f81
31c1
31d4
        set pc, floppy__item__serialize__finish
floppy.dasm16
502
0

floppy.dasm16
503
1
31c2
3b01
    set push, [i]
floppy.dasm16
504
2
31c3
7c20
31c4
3256
    jsr floppy__word__write
floppy.dasm16
505
0

floppy.dasm16
506
2
31c5
7c51
31c6
2707
    ifc c, TYPE_GROUP_CONTAINER
floppy.dasm16
507
2
31c7
7f9e
31c8
31bb
        sti pc, floppy__item__serialize__data__loop
floppy.dasm16
508
0

floppy.dasm16
509
0
; here starts the todo insertion loop
floppy.dasm16
510
1
31c9
00e1
    set j, a
floppy.dasm16
511
0

floppy.dasm16
512
0
:floppy__item__serialize__search_item
floppy.dasm16
513
1
31ca
88e3
    sub j, 1
floppy.dasm16
514
1
31cb
39f2
    ife [j], [i]        ; match
floppy.dasm16
515
2
31cc
7f9e
31cd
31bb
        sti pc, floppy__item__serialize__data__loop
floppy.dasm16
516
0

floppy.dasm16
517
1
31ce
6cf4
    ifg j, sp
floppy.dasm16
518
2
31cf
7f81
31d0
31ca
        set pc, floppy__item__serialize__search_item    ; no match
floppy.dasm16
519
0

floppy.dasm16
520
0
    ; no match found
floppy.dasm16
521
1
31d1
3b01
    set push, [i]
floppy.dasm16
522
0
    
floppy.dasm16
523
2
31d2
7f9e
31d3
31bb
    sti pc, floppy__item__serialize__data__loop
floppy.dasm16
524
0

floppy.dasm16
525
0
:floppy__item__serialize__finish
floppy.dasm16
526
1
31d4
8701
    set push, 0
floppy.dasm16
527
2
31d5
7c20
31d6
3256
    jsr floppy__word__write
floppy.dasm16
528
0

floppy.dasm16
529
2
31d7
7f81
31d8
2026
    set pc, postamble
floppy.dasm16
530
0

floppy.dasm16
531
0
;----------------------------------------------------------------
floppy.dasm16
532
0
; extern struct handle *floppy__item__read(uint16 sector_head, uint16 sector_tail)
floppy.dasm16
533
0
;----------------------------------------------------------------
floppy.dasm16
534
0
:floppy__item__read
floppy.dasm16
535
1
31d9
8f01
    set push, 2
floppy.dasm16
536
1
31da
8b01
    set push, 1
floppy.dasm16
537
2
31db
7c20
31dc
2039
    jsr preamble
floppy.dasm16
538
0

floppy.dasm16
539
2
31dd
5701
31de
000b
    set push, [z+11]
floppy.dasm16
540
2
31df
7c20
31e0
3243
    jsr floppy__file__open
floppy.dasm16
541
0

floppy.dasm16
542
0
    ; deserialize object
floppy.dasm16
543
2
31e1
7c20
31e2
31e5
    jsr floppy__item__deserialize
floppy.dasm16
544
0

floppy.dasm16
545
2
31e3
7f81
31e4
2026
    set pc, postamble
floppy.dasm16
546
0

floppy.dasm16
547
0
;----------------------------------------------------------------
floppy.dasm16
548
0
; struct handle *file__deserialize(void)
floppy.dasm16
549
0
;----------------------------------------------------------------
floppy.dasm16
550
0
:floppy__item__deserialize
floppy.dasm16
551
1
31e5
8701
    set push, 0
floppy.dasm16
552
1
31e6
8b01
    set push, 1
floppy.dasm16
553
2
31e7
7c20
31e8
2039
    jsr preamble
floppy.dasm16
554
0

floppy.dasm16
555
0
    ; push sentinel to stack
floppy.dasm16
556
1
31e9
8701
    set push, 0
floppy.dasm16
557
0

floppy.dasm16
558
0
:floppy__item__deserialize__next_item
floppy.dasm16
559
0
    ; read root
floppy.dasm16
560
2
31ea
7c20
31eb
3270
    jsr floppy__word__read            ; id
floppy.dasm16
561
1
31ec
8472
    ife x, 0
floppy.dasm16
562
2
31ed
7f81
31ee
3236
        set pc, floppy__item__deserialize__finish
floppy.dasm16
563
0
    
floppy.dasm16
564
1
31ef
0c01
    set a, x    
floppy.dasm16
565
2
31f0
7c20
31f1
323a
    jsr floppy__item__deserialize_search
floppy.dasm16
566
0
    
floppy.dasm16
567
2
31f2
7c20
31f3
3270
    jsr floppy__word__read            ; type
floppy.dasm16
568
1
31f4
0c21
    set b, x
floppy.dasm16
569
2
31f5
7c20
31f6
3270
    jsr floppy__word__read            ; size
floppy.dasm16
570
1
31f7
0c41
    set c, x
floppy.dasm16
571
0

floppy.dasm16
572
1
31f8
85f3
    ifn [j], 0
floppy.dasm16
573
2
31f9
7f81
31fa
3205
        set pc, floppy__item__deserialize__known_item
floppy.dasm16
574
0

floppy.dasm16
575
0
    ; create item
floppy.dasm16
576
1
31fb
0b01
    set push, c
floppy.dasm16
577
1
31fc
0701
    set push, b
floppy.dasm16
578
2
31fd
7c20
31fe
21d3
    jsr alloc
floppy.dasm16
579
2
31ff
0ea1
3200
ffff
    set [z-1], x
floppy.dasm16
580
0

floppy.dasm16
581
0
    ; push root item to stack
floppy.dasm16
582
1
3201
0f01
    set push, x
floppy.dasm16
583
1
3202
0301
    set push, a
floppy.dasm16
584
0
    
floppy.dasm16
585
2
3203
7f81
3204
320c
    set pc, floppy__item__deserialize__data
floppy.dasm16
586
0

floppy.dasm16
587
0
:floppy__item__deserialize__known_item
floppy.dasm16
588
2
3205
5f01
3206
0001
    set push, [j+1]
floppy.dasm16
589
1
3207
0b01
    set push, c
floppy.dasm16
590
2
3208
7c20
3209
2185
    jsr realloc
floppy.dasm16
591
0

floppy.dasm16
592
2
320a
0661
320b
0001
    set [x + HANDLE_TYPE], b
floppy.dasm16
593
0

floppy.dasm16
594
0
:floppy__item__deserialize__data
floppy.dasm16
595
1
320c
2cc1
    set i, [x]                ; struct data *
floppy.dasm16
596
0

floppy.dasm16
597
2
320d
7c30
320e
0040
    ifb b, TYPE_FLOAT
floppy.dasm16
598
2
320f
7f81
3210
3214
        set pc, floppy__item__deserialize__skip_length
floppy.dasm16
599
0

floppy.dasm16
600
0
    ; set length
floppy.dasm16
601
1
3211
09c1
    set [i], c
floppy.dasm16
602
1
3212
89c3
    sub [i], 1
floppy.dasm16
603
1
3213
88c2
    add i, 1
floppy.dasm16
604
0

floppy.dasm16
605
0
:floppy__item__deserialize__skip_length
floppy.dasm16
606
1
3214
2c42
    add c, [x]
floppy.dasm16
607
0
    ; i points to next unset item
floppy.dasm16
608
0
    ; c points to one past arrays last item
floppy.dasm16
609
0
    ; b type
floppy.dasm16
610
0
    
floppy.dasm16
611
0
:floppy__item__deserialize__array_loop
floppy.dasm16
612
1
3215
08d2
    ife i, c
floppy.dasm16
613
2
3216
7f81
3217
31ea
        set pc, floppy__item__deserialize__next_item
floppy.dasm16
614
0

floppy.dasm16
615
2
3218
7c20
3219
3270
    jsr floppy__word__read            ; data
floppy.dasm16
616
2
321a
7c30
321b
2707
    ifb b, TYPE_GROUP_CONTAINER
floppy.dasm16
617
2
321c
7f81
321d
3221
        set pc, floppy__item__deserialize__add_item
floppy.dasm16
618
0

floppy.dasm16
619
1
321e
0dc1
    set [i], x
floppy.dasm16
620
0
    
floppy.dasm16
621
2
321f
7f9e
3220
3215
    sti pc, floppy__item__deserialize__array_loop
floppy.dasm16
622
0

floppy.dasm16
623
0
:floppy__item__deserialize__add_item
floppy.dasm16
624
2
3221
7c20
3222
323a
    jsr floppy__item__deserialize_search
floppy.dasm16
625
0

floppy.dasm16
626
1
3223
85f2
    ife [j], 0
floppy.dasm16
627
2
3224
7f81
3225
322a
        set pc, floppy__item__deserialize__new_item
floppy.dasm16
628
0

floppy.dasm16
629
0
    ; set known item id
floppy.dasm16
630
2
3226
5dc1
3227
0001
    set [i], [j+1]
floppy.dasm16
631
0
    
floppy.dasm16
632
2
3228
7f9e
3229
3215
    sti pc, floppy__item__deserialize__array_loop
floppy.dasm16
633
0

floppy.dasm16
634
0
:floppy__item__deserialize__new_item
floppy.dasm16
635
1
322a
8701
    set push, 0
floppy.dasm16
636
1
322b
0f01
    set push, x
floppy.dasm16
637
0
    
floppy.dasm16
638
1
322c
8701
    set push, 0
floppy.dasm16
639
2
322d
7f01
322e
0080
    set push, TYPE_NONE
floppy.dasm16
640
2
322f
7c20
3230
21d3
    jsr alloc
floppy.dasm16
641
0
    
floppy.dasm16
642
2
3231
0f41
3232
0001
    set [sp + 1], x
floppy.dasm16
643
0
    
floppy.dasm16
644
1
3233
0dc1
    set [i], x
floppy.dasm16
645
0
    
floppy.dasm16
646
2
3234
7f9e
3235
3215
    sti pc, floppy__item__deserialize__array_loop
floppy.dasm16
647
0

floppy.dasm16
648
0
:floppy__item__deserialize__finish
floppy.dasm16
649
2
3236
5461
3237
ffff
    set x, [z-1]
floppy.dasm16
650
2
3238
7f81
3239
2026
    set pc, postamble
floppy.dasm16
651
0

floppy.dasm16
652
0
;----------------------------------------------------------------
floppy.dasm16
653
0
:floppy__item__deserialize_search
floppy.dasm16
654
0
;----------------------------------------------------------------
floppy.dasm16
655
1
323a
6ce1
    set j, sp
floppy.dasm16
656
1
323b
88e3
    sub j, 1
floppy.dasm16
657
0

floppy.dasm16
658
0
:floppy__item__deserialize_search_loop
floppy.dasm16
659
1
323c
8ce2
    add j, 2
floppy.dasm16
660
0

floppy.dasm16
661
1
323d
85f2
    ife [j], 0
floppy.dasm16
662
1
323e
6381
        set pc, pop
floppy.dasm16
663
0

floppy.dasm16
664
1
323f
0df3
    ifn [j], x
floppy.dasm16
665
2
3240
7f81
3241
323c
        set pc, floppy__item__deserialize_search_loop
floppy.dasm16
666
0

floppy.dasm16
667
1
3242
6381
    set pc, pop
floppy.dasm16
668
0
;----------------------------------------------------------------
floppy.dasm16
669
0
; LOW LEVEL SUBROUTINES
floppy.dasm16
670
0
;----------------------------------------------------------------
floppy.dasm16
671
0

floppy.dasm16
672
0
;----------------------------------------------------------------
floppy.dasm16
673
0
:floppy__file__open
floppy.dasm16
674
0
;----------------------------------------------------------------
floppy.dasm16
675
2
3243
6b01
3244
0001
    set push, [sp + 1]
floppy.dasm16
676
2
3245
7c20
3246
312c
    jsr floppy__sector__read
floppy.dasm16
677
0

floppy.dasm16
678
0
    ; initialize file position
floppy.dasm16
679
2
3247
87c1
3248
0244
    set [floppy__file__position], 0
floppy.dasm16
680
0
    
floppy.dasm16
681
1
3249
6321
    set [sp], pop
floppy.dasm16
682
1
324a
6381
    set pc, pop
floppy.dasm16
683
0

floppy.dasm16
684
0
;----------------------------------------------------------------
floppy.dasm16
685
0
:floppy__file__close
floppy.dasm16
686
0
;----------------------------------------------------------------
floppy.dasm16
687
0
    ; store next free sector
floppy.dasm16
688
2
324b
7b01
324c
d980
    set push, [FLOPPY__SECTOR__NEXT]
floppy.dasm16
689
0

floppy.dasm16
690
0
    ; terminate current sector list
floppy.dasm16
691
2
324d
87c1
324e
d980
    set [FLOPPY__SECTOR__NEXT], 0
floppy.dasm16
692
0

floppy.dasm16
693
2
324f
7b01
3250
0246
    set push, [floppy__free__head]
floppy.dasm16
694
2
3251
7c20
3252
311d
    jsr floppy__sector__write
floppy.dasm16
695
0

floppy.dasm16
696
0
    ; update mbr
floppy.dasm16
697
2
3253
63c1
3254
0246
    set [floppy__free__head], pop
floppy.dasm16
698
0
    
floppy.dasm16
699
1
3255
6381
    set pc, pop
floppy.dasm16
700
0
    
floppy.dasm16
701
0
;----------------------------------------------------------------
floppy.dasm16
702
0
:floppy__word__write
floppy.dasm16
703
0
;----------------------------------------------------------------
floppy.dasm16
704
3
3256
7fd6
3257
db80
3258
0245
    ifl [floppy__buffer__position], MEM_FLOPPY_END
floppy.dasm16
705
2
3259
7f81
325a
3266
        set pc, floppy__word__write__use_buffer
floppy.dasm16
706
0

floppy.dasm16
707
2
325b
7b01
325c
0246
    set push, [floppy__free__head]
floppy.dasm16
708
2
325d
7c20
325e
311d
    jsr floppy__sector__write
floppy.dasm16
709
0
    
floppy.dasm16
710
3
325f
7bc1
3260
d980
3261
0246
    set [floppy__free__head], [FLOPPY__SECTOR__NEXT]
floppy.dasm16
711
0

floppy.dasm16
712
0
    ; read the next sector to memory buffer
floppy.dasm16
713
2
3262
7b01
3263
d980
    set push, [FLOPPY__SECTOR__NEXT]
floppy.dasm16
714
2
3264
7c20
3265
312c
    jsr floppy__sector__read
floppy.dasm16
715
0

floppy.dasm16
716
0
:floppy__word__write__use_buffer
floppy.dasm16
717
2
3266
7861
3267
0245
    set x, [floppy__buffer__position]
floppy.dasm16
718
2
3268
6961
3269
0001
    set [x], [sp + 1]
floppy.dasm16
719
0

floppy.dasm16
720
2
326a
8bc2
326b
0245
    add [floppy__buffer__position], 1
floppy.dasm16
721
2
326c
8bc2
326d
0244
    add [floppy__file__position], 1
floppy.dasm16
722
0
    
floppy.dasm16
723
1
326e
6321
    set [sp], pop
floppy.dasm16
724
1
326f
6381
    set pc, pop
floppy.dasm16
725
0

floppy.dasm16
726
0
;----------------------------------------------------------------
floppy.dasm16
727
0
:floppy__word__read
floppy.dasm16
728
0
;----------------------------------------------------------------
floppy.dasm16
729
3
3270
7fd6
3271
db80
3272
0245
    ifl [floppy__buffer__position], MEM_FLOPPY_END
floppy.dasm16
730
2
3273
7f81
3274
3279
        set pc, floppy__word__read__use_buffer
floppy.dasm16
731
0

floppy.dasm16
732
0
    ; read the next sector to memory buffer
floppy.dasm16
733
2
3275
7b01
3276
d980
    set push, [FLOPPY__SECTOR__NEXT]
floppy.dasm16
734
2
3277
7c20
3278
312c
    jsr floppy__sector__read
floppy.dasm16
735
0

floppy.dasm16
736
0
:floppy__word__read__use_buffer
floppy.dasm16
737
2
3279
7861
327a
0245
    set x, [floppy__buffer__position]
floppy.dasm16
738
1
327b
2c61
    set x, [x]
floppy.dasm16
739
0

floppy.dasm16
740
2
327c
8bc2
327d
0245
    add [floppy__buffer__position], 1
floppy.dasm16
741
2
327e
8bc2
327f
0244
    add [floppy__file__position], 1
floppy.dasm16
742
0

floppy.dasm16
743
1
3280
6381
    set pc, pop
crypt.dasm16
0
0
;Hummingbird-2 Encryption Algorithm
crypt.dasm16
1
0
;Implementation by HyperVerse Systems
crypt.dasm16
2
0
;V 1
crypt.dasm16
3
0

crypt.dasm16
4
0
;A = Pointer to IV
crypt.dasm16
5
0
;B = Pointer to key
crypt.dasm16
6
0
;C = Pointer to message
crypt.dasm16
7
0
;PUSH = Length of message
crypt.dasm16
8
0

crypt.dasm16
9
0
;Encryption function
crypt.dasm16
10
0
:crypt__Encrypt
crypt.dasm16
11
1
3281
1f01
    SET PUSH, J
crypt.dasm16
12
1
3282
0f01
    SET PUSH, X
crypt.dasm16
13
1
3283
1301
    SET PUSH, Y
crypt.dasm16
14
1
3284
1701
    SET PUSH, Z
crypt.dasm16
15
1
3285
1b01
    SET PUSH, I
crypt.dasm16
16
2
3286
7c20
3287
334b
    JSR crypt__Init
crypt.dasm16
17
0
    
crypt.dasm16
18
2
3288
68c1
3289
0006
    SET I, [SP+6]
crypt.dasm16
19
0
    :crypt__Encrypt_loop
crypt.dasm16
20
2
328a
7ce1
328b
0273
        SET J, crypt__State
crypt.dasm16
21
0
        
crypt.dasm16
22
1
328c
3c01
        SET A, [J]
crypt.dasm16
23
1
328d
2802
        ADD A, [C]
crypt.dasm16
24
2
328e
7c20
328f
33a4
        JSR crypt__EWD16
crypt.dasm16
25
1
3290
9422
        ADD B, 4
crypt.dasm16
26
1
3291
0061
        SET X, A
crypt.dasm16
27
0
        
crypt.dasm16
28
2
3292
5c01
3293
0001
        SET A, [J+1]
crypt.dasm16
29
1
3294
0c02
        ADD A, X
crypt.dasm16
30
2
3295
5d2c
3296
0004
        XOR [B], [J+4]
crypt.dasm16
31
3
3297
5e2c
3298
0005
3299
0001
        XOR [B+1], [J+5]
crypt.dasm16
32
3
329a
5e2c
329b
0006
329c
0002
        XOR [B+2], [J+6]
crypt.dasm16
33
3
329d
5e2c
329e
0007
329f
0003
        XOR [B+3], [J+7]
crypt.dasm16
34
2
32a0
7c20
32a1
33a4
        JSR crypt__EWD16
crypt.dasm16
35
2
32a2
5d2c
32a3
0004
        XOR [B], [J+4]
crypt.dasm16
36
3
32a4
5e2c
32a5
0005
32a6
0001
        XOR [B+1], [J+5]
crypt.dasm16
37
3
32a7
5e2c
32a8
0006
32a9
0002
        XOR [B+2], [J+6]
crypt.dasm16
38
3
32aa
5e2c
32ab
0007
32ac
0003
        XOR [B+3], [J+7]
crypt.dasm16
39
1
32ad
9423
        SUB B, 4
crypt.dasm16
40
1
32ae
0081
        SET Y, A
crypt.dasm16
41
0
        
crypt.dasm16
42
2
32af
5c01
32b0
0002
        SET A, [J+2]
crypt.dasm16
43
1
32b1
1002
        ADD A, Y
crypt.dasm16
44
2
32b2
5d2c
32b3
0004
        XOR [B], [J+4]
crypt.dasm16
45
3
32b4
5e2c
32b5
0005
32b6
0001
        XOR [B+1], [J+5]
crypt.dasm16
46
3
32b7
5e2c
32b8
0006
32b9
0002
        XOR [B+2], [J+6]
crypt.dasm16
47
3
32ba
5e2c
32bb
0007
32bc
0003
        XOR [B+3], [J+7]
crypt.dasm16
48
2
32bd
7c20
32be
33a4
        JSR crypt__EWD16
crypt.dasm16
49
2
32bf
5d2c
32c0
0004
        XOR [B], [J+4]
crypt.dasm16
50
3
32c1
5e2c
32c2
0005
32c3
0001
        XOR [B+1], [J+5]
crypt.dasm16
51
3
32c4
5e2c
32c5
0006
32c6
0002
        XOR [B+2], [J+6]
crypt.dasm16
52
3
32c7
5e2c
32c8
0007
32c9
0003
        XOR [B+3], [J+7]
crypt.dasm16
53
1
32ca
9422
        ADD B, 4
crypt.dasm16
54
1
32cb
00a1
        SET Z, A
crypt.dasm16
55
0

crypt.dasm16
56
2
32cc
5c01
32cd
0003
        SET A, [J+3]
crypt.dasm16
57
1
32ce
1402
        ADD A, Z
crypt.dasm16
58
2
32cf
7c20
32d0
33a4
        JSR crypt__EWD16
crypt.dasm16
59
1
32d1
9423
        SUB B, 4
crypt.dasm16
60
1
32d2
3c02
        ADD A, [J]
crypt.dasm16
61
1
32d3
0141
        SET [C], A
crypt.dasm16
62
0
        
crypt.dasm16
63
1
32d4
8842
        ADD C, 1
crypt.dasm16
64
1
32d5
88c3
        SUB I, 1
crypt.dasm16
65
1
32d6
84d2
        IFE I, 0
crypt.dasm16
66
2
32d7
7f81
32d8
3406
            SET PC, crypt__Return
crypt.dasm16
67
0
        
crypt.dasm16
68
2
32d9
7c20
32da
3336
        JSR crypt__Update_State
crypt.dasm16
69
0
        
crypt.dasm16
70
2
32db
7f81
32dc
328a
        SET PC, crypt__Encrypt_loop
crypt.dasm16
71
0

crypt.dasm16
72
0
;Decryption function
crypt.dasm16
73
0
:crypt__Decrypt
crypt.dasm16
74
1
32dd
1f01
    SET PUSH, J
crypt.dasm16
75
1
32de
0f01
    SET PUSH, X
crypt.dasm16
76
1
32df
1301
    SET PUSH, Y
crypt.dasm16
77
1
32e0
1701
    SET PUSH, Z
crypt.dasm16
78
1
32e1
1b01
    SET PUSH, I
crypt.dasm16
79
0
    
crypt.dasm16
80
2
32e2
7c20
32e3
334b
    JSR crypt__Init
crypt.dasm16
81
0
    
crypt.dasm16
82
2
32e4
68c1
32e5
0006
    SET I, [SP+6]
crypt.dasm16
83
0
    
crypt.dasm16
84
0
    :crypt__Decrypt_loop
crypt.dasm16
85
2
32e6
7ce1
32e7
0273
        SET J, crypt__State
crypt.dasm16
86
0
        
crypt.dasm16
87
1
32e8
2801
        SET A, [C]
crypt.dasm16
88
1
32e9
3c03
        SUB A, [J]
crypt.dasm16
89
1
32ea
9422
        ADD B, 4
crypt.dasm16
90
2
32eb
7c20
32ec
33c0
        JSR crypt__DWD16
crypt.dasm16
91
2
32ed
5c03
32ee
0003
        SUB A, [J+3]
crypt.dasm16
92
1
32ef
00a1
        SET Z, A
crypt.dasm16
93
0
        
crypt.dasm16
94
1
32f0
9423
        SUB B, 4
crypt.dasm16
95
2
32f1
5d2c
32f2
0004
        XOR [B], [J+4]
crypt.dasm16
96
3
32f3
5e2c
32f4
0005
32f5
0001
        XOR [B+1], [J+5]
crypt.dasm16
97
3
32f6
5e2c
32f7
0006
32f8
0002
        XOR [B+2], [J+6]
crypt.dasm16
98
3
32f9
5e2c
32fa
0007
32fb
0003
        XOR [B+3], [J+7]
crypt.dasm16
99
2
32fc
7c20
32fd
33c0
        JSR crypt__DWD16
crypt.dasm16
100
2
32fe
5d2c
32ff
0004
        XOR [B], [J+4]
crypt.dasm16
101
3
3300
5e2c
3301
0005
3302
0001
        XOR [B+1], [J+5]
crypt.dasm16
102
3
3303
5e2c
3304
0006
3305
0002
        XOR [B+2], [J+6]
crypt.dasm16
103
3
3306
5e2c
3307
0007
3308
0003
        XOR [B+3], [J+7]
crypt.dasm16
104
2
3309
5c03
330a
0002
        SUB A, [J+2]
crypt.dasm16
105
1
330b
0081
        SET Y, A
crypt.dasm16
106
0
        
crypt.dasm16
107
1
330c
9422
        ADD B, 4
crypt.dasm16
108
2
330d
5d2c
330e
0004
        XOR [B], [J+4]
crypt.dasm16
109
3
330f
5e2c
3310
0005
3311
0001
        XOR [B+1], [J+5]
crypt.dasm16
110
3
3312
5e2c
3313
0006
3314
0002
        XOR [B+2], [J+6]
crypt.dasm16
111
3
3315
5e2c
3316
0007
3317
0003
        XOR [B+3], [J+7]
crypt.dasm16
112
2
3318
7c20
3319
33c0
        JSR crypt__DWD16
crypt.dasm16
113
2
331a
5d2c
331b
0004
        XOR [B], [J+4]
crypt.dasm16
114
3
331c
5e2c
331d
0005
331e
0001
        XOR [B+1], [J+5]
crypt.dasm16
115
3
331f
5e2c
3320
0006
3321
0002
        XOR [B+2], [J+6]
crypt.dasm16
116
3
3322
5e2c
3323
0007
3324
0003
        XOR [B+3], [J+7]
crypt.dasm16
117
2
3325
5c03
3326
0001
        SUB A, [J+1]
crypt.dasm16
118
1
3327
0061
        SET X, A
crypt.dasm16
119
0
        
crypt.dasm16
120
1
3328
9423
        SUB B, 4
crypt.dasm16
121
2
3329
7c20
332a
33c0
        JSR crypt__DWD16
crypt.dasm16
122
1
332b
3c03
        SUB A, [J]
crypt.dasm16
123
1
332c
0141
        SET [C], A
crypt.dasm16
124
0
        
crypt.dasm16
125
1
332d
88c3
        SUB I, 1
crypt.dasm16
126
1
332e
8842
        ADD C, 1
crypt.dasm16
127
1
332f
84d2
        IFE I, 0
crypt.dasm16
128
2
3330
7f81
3331
3406
            SET PC, crypt__Return
crypt.dasm16
129
2
3332
7c20
3333
3336
        JSR crypt__Update_State
crypt.dasm16
130
0
        
crypt.dasm16
131
2
3334
7f81
3335
32e6
        SET PC, crypt__Decrypt_loop
crypt.dasm16
132
0
        
crypt.dasm16
133
0
:crypt__Update_State
crypt.dasm16
134
1
3336
15e2
    ADD [J], Z
crypt.dasm16
135
2
3337
0ee2
3338
0001
    ADD [J+1], X
crypt.dasm16
136
2
3339
12e2
333a
0002
    ADD [J+2], Y
crypt.dasm16
137
2
333b
3ee2
333c
0003
    ADD [J+3], [J]
crypt.dasm16
138
2
333d
0ee2
333e
0003
    ADD [J+3], X
crypt.dasm16
139
2
333f
3eec
3340
0004
    XOR [J+4], [J]
crypt.dasm16
140
3
3341
5eec
3342
0001
3343
0005
    XOR [J+5], [J+1]
crypt.dasm16
141
3
3344
5eec
3345
0002
3346
0006
    XOR [J+6], [J+2]
crypt.dasm16
142
3
3347
5eec
3348
0003
3349
0007
    XOR [J+7], [J+3]
crypt.dasm16
143
0
    
crypt.dasm16
144
1
334a
6381
    SET PC, POP
crypt.dasm16
145
0

crypt.dasm16
146
0
;Initialization
crypt.dasm16
147
0
:crypt__Init
crypt.dasm16
148
1
334b
0b01
    SET PUSH, C
crypt.dasm16
149
2
334c
7c41
334d
0273
    SET C, crypt__State
crypt.dasm16
150
0
    
crypt.dasm16
151
1
334e
2141
    SET [C], [A]
crypt.dasm16
152
3
334f
4241
3350
0001
3351
0001
    SET [C+1], [A+1]
crypt.dasm16
153
3
3352
4241
3353
0002
3354
0002
    SET [C+2], [A+2]
crypt.dasm16
154
3
3355
4241
3356
0003
3357
0003
    SET [C+3], [A+3]
crypt.dasm16
155
2
3358
2241
3359
0004
    SET [C+4], [A]
crypt.dasm16
156
3
335a
4241
335b
0001
335c
0005
    SET [C+5], [A+1]
crypt.dasm16
157
3
335d
4241
335e
0002
335f
0006
    SET [C+6], [A+2]
crypt.dasm16
158
3
3360
4241
3361
0003
3362
0007
    SET [C+7], [A+3]
crypt.dasm16
159
0
    
crypt.dasm16
160
1
3363
84c1
    SET I, 0
crypt.dasm16
161
0
    
crypt.dasm16
162
0
    :crypt__Init_loop
crypt.dasm16
163
1
3364
2801
    SET A, [C]
crypt.dasm16
164
1
3365
1802
    ADD A, I
crypt.dasm16
165
2
3366
7c20
3367
33a4
    JSR crypt__EWD16
crypt.dasm16
166
1
3368
00e1
    SET J, A
crypt.dasm16
167
0
    
crypt.dasm16
168
2
3369
4801
336a
0001
    SET A, [C+1]
crypt.dasm16
169
1
336b
1c02
    ADD A, J
crypt.dasm16
170
2
336c
7c20
336d
33a4
    JSR crypt__EWD16
crypt.dasm16
171
1
336e
0061
    SET X, A
crypt.dasm16
172
0
    
crypt.dasm16
173
2
336f
4801
3370
0002
    SET A, [C+2]
crypt.dasm16
174
1
3371
0c02
    ADD A, X
crypt.dasm16
175
2
3372
7c20
3373
33a4
    JSR crypt__EWD16
crypt.dasm16
176
1
3374
0081
    SET Y, A
crypt.dasm16
177
0
    
crypt.dasm16
178
2
3375
4801
3376
0003
    SET A, [C+3]
crypt.dasm16
179
1
3377
1002
    ADD A, Y
crypt.dasm16
180
2
3378
7c20
3379
33a4
    JSR crypt__EWD16
crypt.dasm16
181
1
337a
00a1
    SET Z, A
crypt.dasm16
182
0
    
crypt.dasm16
183
1
337b
2801
    SET A, [C]
crypt.dasm16
184
1
337c
1402
    ADD A, Z
crypt.dasm16
185
1
337d
900f
    SHL A, 3
crypt.dasm16
186
1
337e
740b
    BOR A, EX
crypt.dasm16
187
1
337f
0141
    SET [C], A
crypt.dasm16
188
1
3380
8842
    ADD C, 1
crypt.dasm16
189
0
    
crypt.dasm16
190
1
3381
2801
    SET A, [C]
crypt.dasm16
191
1
3382
1c02
    ADD A, J
crypt.dasm16
192
1
3383
880d
    SHR A, 1
crypt.dasm16
193
1
3384
740b
    BOR A, EX
crypt.dasm16
194
1
3385
0141
    SET [C], A
crypt.dasm16
195
1
3386
8842
    ADD C, 1
crypt.dasm16
196
0
    
crypt.dasm16
197
1
3387
2801
    SET A, [C]
crypt.dasm16
198
1
3388
0c02
    ADD A, X
crypt.dasm16
199
1
3389
a40f
    SHL A, 8
crypt.dasm16
200
1
338a
740b
    BOR A, EX
crypt.dasm16
201
1
338b
0141
    SET [C], A
crypt.dasm16
202
1
338c
8842
    ADD C, 1
crypt.dasm16
203
0
    
crypt.dasm16
204
1
338d
2801
    SET A, [C]
crypt.dasm16
205
1
338e
1002
    ADD A, Y
crypt.dasm16
206
1
338f
880f
    SHL A, 1
crypt.dasm16
207
1
3390
740b
    BOR A, EX
crypt.dasm16
208
1
3391
0141
    SET [C], A
crypt.dasm16
209
1
3392
9043
    SUB C, 3
crypt.dasm16
210
0
    
crypt.dasm16
211
2
3393
2a4c
3394
0004
    XOR [C+4], [C]
crypt.dasm16
212
3
3395
4a4c
3396
0001
3397
0005
    XOR [C+5], [C+1]
crypt.dasm16
213
3
3398
4a4c
3399
0002
339a
0006
    XOR [C+6], [C+2]
crypt.dasm16
214
3
339b
4a4c
339c
0003
339d
0007
    XOR [C+7], [C+3]
crypt.dasm16
215
0
    
crypt.dasm16
216
1
339e
88c2
    ADD I, 1
crypt.dasm16
217
1
339f
94d6
    IFL I, 4
crypt.dasm16
218
2
33a0
7f81
33a1
3364
        SET PC, crypt__Init_loop
crypt.dasm16
219
0
    
crypt.dasm16
220
1
33a2
6041
    SET C, POP
crypt.dasm16
221
1
33a3
6381
    SET PC, POP
crypt.dasm16
222
0

crypt.dasm16
223
0
;Encrypt Permutation
crypt.dasm16
224
0
:crypt__EWD16
crypt.dasm16
225
1
33a4
1b01
    SET PUSH, I
crypt.dasm16
226
1
33a5
0701
    SET PUSH, B
crypt.dasm16
227
0
    
crypt.dasm16
228
1
33a6
84c1
    SET I, 0
crypt.dasm16
229
0
    :crypt__EWD16_loop
crypt.dasm16
230
1
33a7
240c
        XOR A, [B]
crypt.dasm16
231
2
33a8
7c20
33a9
33b2
        JSR crypt__EMix
crypt.dasm16
232
1
33aa
88c2
        ADD I, 1
crypt.dasm16
233
1
33ab
8822
        ADD B, 1
crypt.dasm16
234
1
33ac
94d3
        IFN I, 4
crypt.dasm16
235
2
33ad
7f81
33ae
33a7
            SET PC, crypt__EWD16_loop
crypt.dasm16
236
0
    
crypt.dasm16
237
1
33af
6021
    SET B, POP
crypt.dasm16
238
1
33b0
60c1
    SET I, POP
crypt.dasm16
239
1
33b1
6381
    SET PC, POP
crypt.dasm16
240
0

crypt.dasm16
241
0
;Encrypt Mixing Function
crypt.dasm16
242
0
:crypt__EMix
crypt.dasm16
243
1
33b2
0701
    SET PUSH, B
crypt.dasm16
244
0
    
crypt.dasm16
245
2
33b3
7c21
33b4
027b
    SET B, crypt__SBoxE
crypt.dasm16
246
2
33b5
7c20
33b6
33e5
    JSR crypt__FuncS
crypt.dasm16
247
1
33b7
0021
    SET B, A
crypt.dasm16
248
1
33b8
9c2f
    SHL B, 6
crypt.dasm16
249
1
33b9
742b
    BOR B, EX
crypt.dasm16
250
1
33ba
002c
    XOR B, A
crypt.dasm16
251
1
33bb
ac0f
    SHL A, 10
crypt.dasm16
252
1
33bc
740b
    BOR A, EX
crypt.dasm16
253
1
33bd
040c
    XOR A, B
crypt.dasm16
254
0
    
crypt.dasm16
255
1
33be
6021
    SET B, POP
crypt.dasm16
256
1
33bf
6381
    SET PC, POP
crypt.dasm16
257
0

crypt.dasm16
258
0
;Decrypt Permutation
crypt.dasm16
259
0
:crypt__DWD16
crypt.dasm16
260
1
33c0
1b01
    SET PUSH, I
crypt.dasm16
261
0
    
crypt.dasm16
262
1
33c1
84c1
    SET I, 0
crypt.dasm16
263
1
33c2
9422
    ADD B, 4
crypt.dasm16
264
0
    :crypt__DWD16_loop
crypt.dasm16
265
1
33c3
8823
        SUB B, 1
crypt.dasm16
266
2
33c4
7c20
33c5
33cd
        JSR crypt__DMix
crypt.dasm16
267
1
33c6
240c
        XOR A, [B]
crypt.dasm16
268
1
33c7
88c2
        ADD I, 1
crypt.dasm16
269
1
33c8
94d3
        IFN I, 4
crypt.dasm16
270
2
33c9
7f81
33ca
33c3
            SET PC, crypt__DWD16_loop
crypt.dasm16
271
0
    
crypt.dasm16
272
1
33cb
60c1
    SET I, POP
crypt.dasm16
273
1
33cc
6381
    SET PC, POP
crypt.dasm16
274
0

crypt.dasm16
275
0
;Decrypt Mixing Function
crypt.dasm16
276
0
:crypt__DMix
crypt.dasm16
277
1
33cd
0701
    SET PUSH, B
crypt.dasm16
278
1
33ce
0b01
    SET PUSH, C
crypt.dasm16
279
0
    
crypt.dasm16
280
1
33cf
0021
    SET B, A
crypt.dasm16
281
1
33d0
0041
    SET C, A
crypt.dasm16
282
1
33d1
8c2f
    SHL B, 2
crypt.dasm16
283
1
33d2
742b
    BOR B, EX
crypt.dasm16
284
1
33d3
002c
    XOR B, A
crypt.dasm16
285
1
33d4
944f
    SHL C, 4
crypt.dasm16
286
1
33d5
744b
    BOR C, EX
crypt.dasm16
287
1
33d6
082c
    XOR B, C
crypt.dasm16
288
1
33d7
0041
    SET C, A
crypt.dasm16
289
1
33d8
b44f
    SHL C, 12
crypt.dasm16
290
1
33d9
744b
    BOR C, EX
crypt.dasm16
291
1
33da
082c
    XOR B, C
crypt.dasm16
292
1
33db
bc0f
    SHL A, 14
crypt.dasm16
293
1
33dc
740b
    BOR A, EX
crypt.dasm16
294
1
33dd
040c
    XOR A, B
crypt.dasm16
295
0
    
crypt.dasm16
296
2
33de
7c21
33df
028b
    SET B, crypt__SBoxD
crypt.dasm16
297
2
33e0
7c20
33e1
33e5
    JSR crypt__FuncS
crypt.dasm16
298
0
    
crypt.dasm16
299
1
33e2
6041
    SET C, POP
crypt.dasm16
300
1
33e3
6021
    SET B, POP
crypt.dasm16
301
1
33e4
6381
    SET PC, POP
crypt.dasm16
302
0

crypt.dasm16
303
0
;A = Word to SBox
crypt.dasm16
304
0
;B = SBox to use
crypt.dasm16
305
0
:crypt__FuncS
crypt.dasm16
306
1
33e5
0b01
    SET PUSH, C
crypt.dasm16
307
1
33e6
1b01
    SET PUSH, I
crypt.dasm16
308
1
33e7
0f01
    SET PUSH, X
crypt.dasm16
309
1
33e8
1301
    SET PUSH, Y
crypt.dasm16
310
1
33e9
1701
    SET PUSH, Z
crypt.dasm16
311
0
    
crypt.dasm16
312
1
33ea
0041
    SET C, A
crypt.dasm16
313
1
33eb
8401
    SET A, 0
crypt.dasm16
314
1
33ec
84c1
    SET I, 0
crypt.dasm16
315
0
    
crypt.dasm16
316
0
    :crypt__FuncS_loop
crypt.dasm16
317
1
33ed
88c2
    ADD I, 1
crypt.dasm16
318
1
33ee
944f
    SHL C, 4
crypt.dasm16
319
1
33ef
7461
    SET X, EX
crypt.dasm16
320
1
33f0
8c6d
    SHR X, 2
crypt.dasm16
321
1
33f1
7481
    SET Y, EX
crypt.dasm16
322
1
33f2
bc8d
    SHR Y, 14
crypt.dasm16
323
1
33f3
0462
    ADD X, B
crypt.dasm16
324
1
33f4
8882
    ADD Y, 1
crypt.dasm16
325
1
33f5
9484
    MUL Y, 4
crypt.dasm16
326
1
33f6
2ca1
    SET Z, [X]
crypt.dasm16
327
1
33f7
10af
    SHL Z, Y
crypt.dasm16
328
1
33f8
74a1
    SET Z, EX
crypt.dasm16
329
1
33f9
c0aa
    AND Z, 0xf
crypt.dasm16
330
1
33fa
940f
    SHL A, 4
crypt.dasm16
331
1
33fb
140b
    BOR A, Z
crypt.dasm16
332
1
33fc
9422
    ADD B, 4
crypt.dasm16
333
1
33fd
94d6
    IFL I, 4
crypt.dasm16
334
2
33fe
7f81
33ff
33ed
        SET PC, crypt__FuncS_loop
crypt.dasm16
335
0
    
crypt.dasm16
336
1
3400
60a1
    SET Z, POP
crypt.dasm16
337
1
3401
6081
    SET Y, POP
crypt.dasm16
338
1
3402
6061
    SET X, POP
crypt.dasm16
339
1
3403
60c1
    SET I, POP
crypt.dasm16
340
1
3404
6041
    SET C, POP
crypt.dasm16
341
1
3405
6381
    SET PC, POP
crypt.dasm16
342
0

crypt.dasm16
343
0
:crypt__Return
crypt.dasm16
344
1
3406
85e1
    SET [J], 0
crypt.dasm16
345
2
3407
86e1
3408
0001
    SET [J+1], 0
crypt.dasm16
346
2
3409
86e1
340a
0002
    SET [J+2], 0
crypt.dasm16
347
2
340b
86e1
340c
0003
    SET [J+3], 0
crypt.dasm16
348
2
340d
86e1
340e
0004
    SET [J+4], 0
crypt.dasm16
349
2
340f
86e1
3410
0005
    SET [J+5], 0
crypt.dasm16
350
2
3411
86e1
3412
0006
    SET [J+6], 0
crypt.dasm16
351
2
3413
86e1
3414
0007
    SET [J+7], 0
crypt.dasm16
352
1
3415
0801
    SET A, C
crypt.dasm16
353
0
    
crypt.dasm16
354
1
3416
60c1
    SET I, POP
crypt.dasm16
355
1
3417
60a1
    SET Z, POP
crypt.dasm16
356
1
3418
6081
    SET Y, POP
crypt.dasm16
357
1
3419
6061
    SET X, POP
crypt.dasm16
358
1
341a
60e1
    SET J, POP
crypt.dasm16
359
1
341b
6041
    SET C, POP
crypt.dasm16
360
1
341c
6003
    SUB A, POP
crypt.dasm16
361
1
341d
0b81
    SET PC, C
crypt.dasm16
362
0

crypt.dasm16
363
0

admiral.dasm16
0
0
#include "defs.dasm16"
admiral.dasm16
1
565
0000
8701
0001
9b01
0002
7c20
0003
2039
0004
17c1
0005
0238
0006
6fc1
0007
0239
0008
7c20
0009
20e4
000a
7c20
000b
2e16
000c
7c20
000d
2ee2
000e
af01
000f
8b01
0010
7c20
0011
21d3
0012
0ea1
0013
ffff
0014
0fc1
0015
0235
0016
0fc1
0017
0236
0018
9f01
0019
8f01
001a
7c20
001b
2770
001c
0ea1
001d
fffb
001e
0fc1
001f
0237
0020
7f01
0021
036f
0022
7c20
0023
2050
0024
7f01
0025
0392
0026
7c20
0027
2050
0028
7c20
0029
2237
002a
7c20
002b
2214
002c
7801
002d
0255
002e
7803
002f
0254
0030
0301
0031
7c20
0032
22a2
0033
0f01
0034
7c20
0035
2050
0036
7f01
0037
03a5
0038
7c20
0039
2050
003a
7f01
003b
03b3
003c
7c20
003d
2050
003e
7c20
003f
00e2
0040
0ea1
0041
fffe
0042
ac41
0043
7c20
0044
2ef4
0045
7c20
0046
1b35
0047
7c20
0048
07a1
0049
0ea1
004a
fffd
004b
7e72
004c
4000
004d
0001
004e
7f81
004f
0055
0050
0f01
0051
7c20
0052
1dfc
0053
0ea1
0054
fffd
0055
7fd3
0056
0410
0057
025c
0058
7f81
0059
0047
005a
7f81
005b
003a
005c
8f01
005d
8701
005e
7c20
005f
2039
0060
5701
0061
000b
0062
5701
0063
000a
0064
7c20
0065
2f2e
0066
8473
0067
7c20
0068
2026
0069
5701
006a
000b
006b
7f01
006c
03d2
006d
7c20
006e
2f2e
006f
8472
0070
7c20
0071
2026
0072
0f01
0073
5701
0074
000a
0075
7c20
0076
005c
0077
7c20
0078
2026
0079
8f01
007a
8701
007b
7c20
007c
2039
007d
5701
007e
000b
007f
5701
0080
000a
0081
7c20
0082
2f89
0083
8473
0084
7c20
0085
2026
0086
5701
0087
000b
0088
7f01
0089
03d2
008a
7c20
008b
2f2e
008c
8472
008d
7c20
008e
00c6
008f
0f01
0090
5701
0091
000a
0092
7c20
0093
0079
0094
7c20
0095
2026
0096
9701
0097
8701
0098
7c20
0099
2039
009a
5701
009b
000d
009c
5701
009d
000c
009e
7c20
009f
2f2e
00a0
8473
00a1
7f81
00a2
00bb
00a3
5701
00a4
000d
00a5
7f01
00a6
03d2
00a7
7c20
00a8
2f2e
00a9
8472
00aa
7f81
00ab
00b7
00ac
0f01
00ad
5701
00ae
000c
00af
5701
00b0
000b
00b1
8f01
00b2
7c20
00b3
0096
00b4
8473
00b5
7c20
00b6
2026
00b7
8eb2
00b8
000a
00b9
7c20
00ba
2026
00bb
5701
00bc
000d
00bd
5701
00be
000c
00bf
5701
00c0
000b
00c1
7c20
00c2
2f54
00c3
8861
00c4
7c20
00c5
2026
00c6
6001
00c7
78a1
00c8
0238
00c9
7b61
00ca
0239
00cb
7bc1
00cc
0235
00cd
0236
00ce
7f01
00cf
03b7
00d0
7c20
00d1
2050
00d2
0301
00d3
7c20
00d4
0215
00d5
ac41
00d6
7c20
00d7
2ef4
00d8
7c20
00d9
1b74
00da
0f01
00db
7c20
00dc
2050
00dd
ac41
00de
7c20
00df
2ef4
00e0
7f81
00e1
003a
00e2
8701
00e3
8b01
00e4
7c20
00e5
2039
00e6
7881
00e7
023a
00e8
9bc1
00e9
026a
00ea
53c1
00eb
0002
00ec
026b
00ed
53c1
00ee
0002
00ef
026c
00f0
53c1
00f1
0002
00f2
026d
00f3
87c1
00f4
026e
00f5
7a81
00f6
026c
00f7
0002
00f8
7841
00f9
026e
00fa
7c20
00fb
2e21
00fc
7c20
00fd
2103
00fe
7c20
00ff
2e21
0100
0bc1
0101
026e
0102
7c52
0103
0080
0104
7f81
0105
0122
0106
7c52
0107
0081
0108
7f81
0109
0131
010a
7c52
010b
0082
010c
7f81
010d
01b9
010e
7c52
010f
0083
0110
7f81
0111
01b2
0112
d052
0113
7f81
0114
0171
0115
c452
0116
7f81
0117
016a
0118
c852
0119
7f81
011a
0188
011b
e854
011c
7c56
011d
007f
011e
7f81
011f
01c0
0120
7f81
0121
00f5
0122
87d2
0123
026a
0124
7f81
0125
00f5
0126
7801
0127
0237
0128
2001
0129
7802
012a
026a
012b
8512
012c
7f81
012d
00f5
012e
8301
012f
7f81
0130
0138
0131
9bd2
0132
026a
0133
7f81
0134
00f5
0135
8b01
0136
7f81
0137
0138
0138
7c20
0139
01f9
013a
78c1
013b
026b
013c
7801
013d
026d
013e
00d2
013f
7f81
0140
0144
0141
85c1
0142
7f9e
0143
013e
0144
7801
0145
0237
0146
7821
0147
026a
0148
0c41
0149
7c20
014a
2784
014b
63c2
014c
026a
014d
7801
014e
0237
014f
7821
0150
026a
0151
7c20
0152
277f
0153
7a81
0154
026b
0155
0002
0156
7bc1
0157
026b
0158
026c
0159
7bc1
015a
026b
015b
026d
015c
2cc1
015d
183e
015e
2422
015f
04d2
0160
7f81
0161
00f5
0162
04d4
0163
7f81
0164
00f5
0165
3b01
0166
7c20
0167
01d1
0168
7f9e
0169
015f
016a
7bd2
016b
026c
016c
026b
016d
7f81
016e
00f5
016f
8bc3
0170
026c
0171
7bd2
0172
026d
0173
026c
0174
7f81
0175
00f5
0176
78c1
0177
026c
0178
78d2
0179
026d
017a
7f81
017b
0181
017c
59c1
017d
0001
017e
88c2
017f
7f81
0180
0178
0181
78c1
0182
026d
0183
85c1
0184
8bc3
0185
026d
0186
7f81
0187
00f5
0188
7c20
0189
01f9
018a
2c01
018b
8d16
018c
7f81
018d
01ae
018e
7801
018f
0237
0190
9421
0191
7c20
0192
277f
0193
8472
0194
7f81
0195
019e
0196
0f01
0197
5701
0198
ffff
0199
7c20
019a
1dc0
019b
8472
019c
7f81
019d
01ae
019e
9821
019f
5441
01a0
ffff
01a1
7c20
01a2
2784
01a3
7801
01a4
0237
01a5
2001
01a6
00c1
01a7
2002
01a8
8cc2
01a9
3ac1
01aa
ffff
01ab
00d6
01ac
7f9e
01ad
01a9
01ae
5461
01af
ffff
01b0
7f81
01b1
2026
01b2
7bd6
01b3
026d
01b4
026c
01b5
8bc2
01b6
026c
01b7
7f81
01b8
00f5
01b9
7bd4
01ba
026b
01bb
026c
01bc
8bc3
01bd
026c
01be
7f81
01bf
00f5
01c0
78e1
01c1
026d
01c2
78c1
01c3
026c
01c4
1cd2
01c5
7f81
01c6
01cc
01c7
5de1
01c8
ffff
01c9
88e3
01ca
7f81
01cb
01c4
01cc
0b01
01cd
7c20
01ce
01d1
01cf
7f81
01d0
00f5
01d1
7f4b
01d2
7000
01d3
0001
01d4
7861
01d5
026c
01d6
6961
01d7
0001
01d8
6321
01d9
8bc2
01da
026c
01db
8bc2
01dc
026d
01dd
53d6
01de
0001
01df
026d
01e0
6381
01e1
8701
01e2
8301
01e3
7c20
01e4
2e38
01e5
7fc3
01e6
0020
01e7
026b
01e8
7fc3
01e9
0020
01ea
026c
01eb
7fc3
01ec
0020
01ed
026d
01ee
33d6
01ef
026b
01f0
33c1
01f1
026b
01f2
7bd6
01f3
026b
01f4
026c
01f5
7bc1
01f6
026b
01f7
026c
01f8
6381
01f9
1b01
01fa
1f01
01fb
78c1
01fc
026d
01fd
1b01
01fe
7b23
01ff
026b
0200
8b22
0201
a701
0202
7c20
0203
2770
0204
0ea1
0205
ffff
0206
2ce1
0207
3ce2
0208
c9ff
0209
78d6
020a
026b
020b
7f81
020c
0212
020d
39e1
020e
7dea
020f
007f
0210
7f9f
0211
0209
0212
60e1
0213
60c1
0214
6381
0215
0301
0216
0b01
0217
0f01
0218
c401
0219
9403
021a
7c20
021b
0228
021c
8413
021d
7f81
021e
0219
021f
7c41
0220
0020
0221
7c20
0222
2ef4
0223
6061
0224
6041
0225
6001
0226
6321
0227
6381
0228
6841
0229
0005
022a
004d
022b
c04a
022c
a854
022d
7c42
022e
0037
022f
ac56
0230
7c42
0231
0030
0232
7c20
0233
2ef4
0234
6381
#include "interpreter.dasm16"
admiral.dasm16
2
1388
0235
0000
0236
0000
0237
0000
0238
0000
0239
0000
023a
023b
023b
db80
023c
dd00
023d
db80
023e
dd00
023f
de80
0240
dd00
0241
de80
0242
e000
0243
de80
0244
0000
0245
0000
0246
0000
0247
0000
0248
0000
0249
0000
024a
be8c
024b
8000
024c
b400
024d
5678
024e
1234
024f
0000
0250
0000
0251
0000
0252
0000
0253
0028
0254
4000
0255
d980
0256
0000
0257
0253
0258
0000
0259
0000
025a
0000
025b
0000
025c
0000
025d
0000
025e
0000
025f
0000
0260
0000
0261
0000
0262
0000
0263
0000
0264
0000
0265
0000
0266
0000
0267
0000
0268
0000
0269
0000
026a
0000
026b
0000
026c
0000
026d
0000
026e
0000
026f
2f43
0270
2f4d
0271
2f7a
0272
2f7e
0273
0000
0274
0000
0275
0000
0276
0000
0277
0000
0278
0000
0279
0000
027a
0000
027b
7ce9
027c
215f
027d
b6d0
027e
48a3
027f
4a16
0280
8f7c
0281
30ed
0282
59b2
0283
2fc1
0284
56ad
0285
e834
0286
0b97
0287
f458
0288
9721
0289
a30e
028a
6cdb
028b
b54f
028c
c690
028d
d3e8
028e
1a27
028f
92f8
0290
0c36
0291
4d1e
0292
7ba5
0293
c30a
0294
b45f
0295
9e6d
0296
2781
0297
a769
0298
12c5
0299
348f
029a
deb0
029b
0000
029c
0080
029d
0000
029e
4000
029f
02a1
02a0
0020
02a1
0001
02a2
ffff
02a3
02a5
02a4
0020
02a5
0001
02a6
0000
02a7
02a9
02a8
0020
02a9
0001
02aa
0001
02ab
02ad
02ac
0020
02ad
0001
02ae
0002
02af
02b1
02b0
0020
02b1
0001
02b2
0003
02b3
02b5
02b4
0020
02b5
0001
02b6
0004
02b7
02b9
02b8
0020
02b9
0001
02ba
0005
02bb
02bd
02bc
0020
02bd
0001
02be
0006
02bf
02c1
02c0
0020
02c1
0001
02c2
0007
02c3
02c5
02c4
0020
02c5
0001
02c6
0008
02c7
02c9
02c8
0020
02c9
0001
02ca
0009
02cb
02cd
02cc
0020
02cd
0001
02ce
000a
02cf
02d1
02d0
0020
02d1
0001
02d2
000b
02d3
02d5
02d4
0020
02d5
0001
02d6
000c
02d7
02d9
02d8
0020
02d9
0001
02da
000d
02db
02dd
02dc
0020
02dd
0001
02de
000e
02df
02e1
02e0
0020
02e1
0001
02e2
000f
02e3
02e5
02e4
0020
02e5
0001
02e6
0010
02e7
02a5
02e8
0010
02e9
02a9
02ea
0010
02eb
02ed
02ec
0040
02ed
8000
02ee
0000
02ef
0000
02f0
0000
02f1
02f3
02f2
0040
02f3
fffd
02f4
0000
02f5
0000
02f6
0000
02f7
02f9
02f8
0040
02f9
0003
02fa
0000
02fb
0000
02fc
0000
02fd
02ff
02fe
0040
02ff
0001
0300
0000
0301
0000
0302
0000
0303
030d
0304
0313
0305
0319
0306
031f
0307
0325
0308
032b
0309
0331
030a
0337
030b
033d
030c
0343
030d
030f
030e
0040
030f
ffff
0310
0000
0311
0000
0312
0000
0313
0315
0314
0040
0315
fffe
0316
8000
0317
8000
0318
0000
0319
031b
031a
0040
031b
fffe
031c
8001
031d
8000
031e
0000
031f
0321
0320
0040
0321
fffe
0322
8001
0323
c000
0324
0000
0325
0327
0326
0040
0327
fffe
0328
8002
0329
8000
032a
0000
032b
032d
032c
0040
032d
fffe
032e
8002
032f
a000
0330
0000
0331
0333
0332
0040
0333
fffe
0334
8002
0335
c000
0336
0000
0337
0339
0338
0040
0339
fffe
033a
8002
033b
e000
033c
0000
033d
033f
033e
0040
033f
fffe
0340
8003
0341
8000
0342
0000
0343
0345
0344
0040
0345
fffe
0346
8003
0347
9000
0348
0000
0349
034b
034a
0040
034b
fffe
034c
8003
034d
a000
034e
0000
034f
0351
0350
0008
0351
0003
0352
0069
0353
006e
0354
0066
0355
0357
0356
0008
0357
0004
0358
002d
0359
0069
035a
006e
035b
0066
035c
035e
035d
0008
035e
0003
035f
0030
0360
002e
0361
0030
0362
0364
0363
0008
0364
0004
0365
002d
0366
0030
0367
002e
0368
0030
0369
036b
036a
0008
036b
0003
036c
006e
036d
0061
036e
006e
036f
0371
0370
0008
0371
0020
0372
0020
0373
002a
0374
002a
0375
0020
0376
0044
0377
0043
0378
0050
0379
0055
037a
0020
037b
0041
037c
0044
037d
004d
037e
0049
037f
0052
0380
0041
0381
004c
0382
0020
0383
0049
0384
004e
0385
0054
0386
0045
0387
0052
0388
0050
0389
0052
038a
0045
038b
0054
038c
0045
038d
0052
038e
0020
038f
002a
0390
002a
0391
0020
0392
0394
0393
0008
0394
0010
0395
0036
0396
0034
0397
004b
0398
0020
0399
0052
039a
0041
039b
004d
039c
0020
039d
0053
039e
0059
039f
0053
03a0
0054
03a1
0045
03a2
004d
03a3
0020
03a4
0020
03a5
03a7
03a6
0008
03a7
000b
03a8
0020
03a9
0057
03aa
004f
03ab
0052
03ac
0044
03ad
0053
03ae
0020
03af
0046
03b0
0052
03b1
0045
03b2
0045
03b3
03b5
03b4
0008
03b5
0001
03b6
003e
03b7
03b9
03b8
0008
03b9
0006
03ba
0045
03bb
0052
03bc
0052
03bd
004f
03be
0052
03bf
003a
03c0
03c2
03c1
0008
03c2
0008
03c3
004d
03c4
0041
03c5
0049
03c6
004e
03c7
002e
03c8
0042
03c9
0049
03ca
004e
03cb
03cd
03cc
0800
03cd
0004
03ce
006d
03cf
0061
03d0
0069
03d1
006e
03d2
03d4
03d3
0800
03d4
0001
03d5
005f
03d6
03d8
03d7
0800
03d8
0002
03d9
0065
03da
0078
03db
03dd
03dc
0800
03dd
0002
03de
006d
03df
0065
03e0
03e2
03e1
0800
03e2
0004
03e3
0061
03e4
0072
03e5
0067
03e6
0076
03e7
03e9
03e8
0008
03e9
0004
03ea
006e
03eb
006f
03ec
006e
03ed
0065
03ee
03f0
03ef
0008
03f0
0004
03f1
0074
03f2
0072
03f3
0075
03f4
0065
03f5
03f7
03f6
0008
03f7
0005
03f8
0066
03f9
0061
03fa
006c
03fb
0073
03fc
0065
03fd
03ff
03fe
0008
03ff
0000
0400
0030
0401
0031
0402
0032
0403
0033
0404
0034
0405
0035
0406
0036
0407
0037
0408
0038
0409
0039
040a
0061
040b
0062
040c
0063
040d
0064
040e
0065
040f
0066
0410
07bf
0411
00c6
0412
00c6
0413
0000
0414
07bd
0415
00c6
0416
00c6
0417
0000
0418
07c3
0419
00c6
041a
00c6
041b
0000
041c
07c3
041d
00c6
041e
00c6
041f
0000
0420
0aaf
0421
0b1f
0422
00c6
0423
0000
0424
0aaf
0425
0b17
0426
00c6
0427
0000
0428
0aaf
0429
0b1b
042a
00c6
042b
0000
042c
0aaf
042d
0b0e
042e
00c6
042f
0000
0430
0aaf
0431
0b0e
0432
00c6
0433
0000
0434
0aaf
0435
0b2e
0436
00c6
0437
0000
0438
0aaf
0439
0b33
043a
00c6
043b
0000
043c
0aaf
043d
0b38
043e
00c6
043f
0000
0440
0aaf
0441
0c0c
0442
00c6
0443
0000
0444
0994
0445
00c6
0446
00c6
0447
0000
0448
07c5
0449
00c6
044a
00c6
044b
0000
044c
097a
044d
00c6
044e
00c6
044f
0000
0450
0911
0451
00c6
0452
00c6
0453
0000
0454
07d2
0455
00c6
0456
00c6
0457
0000
0458
00c6
0459
00c6
045a
00c6
045b
0000
045c
00c6
045d
00c6
045e
00c6
045f
0000
0460
0903
0461
00c6
0462
00c6
0463
0000
0464
087f
0465
00c6
0466
00c6
0467
0000
0468
0a07
0469
00c6
046a
00c6
046b
0000
046c
08e8
046d
00c6
046e
00c6
046f
0000
0470
07cd
0471
00c6
0472
00c6
0473
0000
0474
08c2
0475
00c6
0476
00c6
0477
0000
0478
08e8
0479
00c6
047a
00c6
047b
0000
047c
00c6
047d
00c6
047e
0ea5
047f
0010
0480
00c6
0481
00c6
0482
0ee5
0483
0010
0484
00c6
0485
00c6
0486
0ee9
0487
0010
0488
00c6
0489
00c6
048a
0eed
048b
0010
048c
00c6
048d
00c6
048e
0ef1
048f
0010
0490
00c6
0491
00c6
0492
0ef5
0493
0010
0494
00c6
0495
00c6
0496
0ed9
0497
0010
0498
00c6
0499
00c6
049a
0edd
049b
0010
049c
00c6
049d
00c6
049e
0ee1
049f
0010
04a0
00c6
04a1
00c6
04a2
0ed1
04a3
0010
04a4
00c6
04a5
00c6
04a6
0ed5
04a7
0010
04a8
00c6
04a9
00c6
04aa
1079
04ab
0020
04ac
00c6
04ad
00c6
04ae
00c6
04af
0000
04b0
00c6
04b1
00c6
04b2
0c5a
04b3
0040
04b4
00c6
04b5
00c6
04b6
0c46
04b7
0050
04b8
00c6
04b9
00c6
04ba
0ccd
04bb
0060
04bc
0aaf
04bd
0c29
04be
0cc4
04bf
0060
04c0
00c6
04c1
00c6
04c2
0c8f
04c3
0070
04c4
00c6
04c5
00c6
04c6
0d61
04c7
0080
04c8
00c6
04c9
00c6
04ca
0d2d
04cb
0080
04cc
00c6
04cd
00c6
04ce
0d20
04cf
0080
04d0
00c6
04d1
00c6
04d2
0d47
04d3
0080
04d4
00c6
04d5
00c6
04d6
0d3a
04d7
0080
04d8
00c6
04d9
00c6
04da
0d54
04db
0080
04dc
00c6
04dd
00c6
04de
0e13
04df
0090
04e0
00c6
04e1
00c6
04e2
0e27
04e3
0100
04e4
00c6
04e5
00c6
04e6
0e3b
04e7
0110
04e8
00c6
04e9
00c6
04ea
0e4f
04eb
0120
04ec
00c6
04ed
00c6
04ee
0e63
04ef
0120
04f0
0aaf
04f1
0be2
04f2
0d8a
04f3
0130
04f4
0aaf
04f5
0be9
04f6
0daf
04f7
0130
04f8
00c6
04f9
00c6
04fa
0dc9
04fb
0140
04fc
00c6
04fd
00c6
04fe
0e77
04ff
0140
0500
00c6
0501
00c6
0502
0e91
0503
0140
0504
00c6
0505
00c6
0506
0df7
0507
0170
0508
0aaf
0509
0b62
050a
0fa5
050b
0180
050c
00c6
050d
00c6
050e
00c6
050f
0000
0510
0aaf
0511
0b3d
0512
0ef9
0513
0200
0514
00c6
0515
00c6
0516
00c6
0517
0000
0518
0aaf
0519
0b98
051a
00c6
051b
0000
051c
00c6
051d
00c6
051e
00c6
051f
0000
0520
00c6
0521
00c6
0522
102b
0523
0210
0524
0003
0525
0069
0526
0064
0527
111e
0528
0003
0529
0072
052a
006d
052b
12ac
052c
0004
052d
0064
052e
0069
052f
0072
0530
1274
0531
0004
0532
0068
0533
0065
0534
0078
0535
132d
0536
0004
0537
0068
0538
0077
0539
0069
053a
14c0
053b
0004
053c
0068
053d
0077
053e
006e
053f
14b5
0540
0004
0541
0068
0542
0077
0543
0071
0544
14d7
0545
0004
0546
006d
0547
0065
0548
006d
0549
1188
054a
0004
054b
0072
054c
006e
054d
0064
054e
1202
054f
0004
0550
0069
0551
006e
0552
0074
0553
12bc
0554
0004
0555
0073
0556
0074
0557
0072
0558
133e
0559
0004
055a
006c
055b
0065
055c
006e
055d
1255
055e
0004
055f
0061
0560
0062
0561
0073
0562
123c
0563
0004
0564
006f
0565
0072
0566
0064
0567
11da
0568
0004
0569
0063
056a
0068
056b
0072
056c
11c4
056d
0004
056e
0063
056f
006d
0570
0070
0571
11ae
0572
0004
0573
006b
0574
0065
0575
0079
0576
136c
0577
0005
0578
0062
0579
006f
057a
006f
057b
006c
057c
134e
057d
0005
057e
0063
057f
0061
0580
006c
0581
006c
0582
141c
0583
0005
0584
0065
0585
0064
0586
0069
0587
0074
0588
11ef
0589
0005
058a
0065
058b
0078
058c
0069
058d
0074
058e
119a
058f
0005
0590
0067
0591
0065
0592
0074
0593
0063
0594
1359
0595
0005
0596
006c
0597
006f
0598
0061
0599
0064
059a
1288
059b
0005
059c
0070
059d
0065
059e
0065
059f
006b
05a0
143c
05a1
0005
05a2
0070
05a3
006f
05a4
006b
05a5
0065
05a6
146c
05a7
0005
05a8
0072
05a9
0065
05aa
0061
05ab
0064
05ac
1499
05ad
0005
05ae
0072
05af
0065
05b0
0070
05b1
0072
05b2
1320
05b3
0005
05b4
0073
05b5
0061
05b6
0076
05b7
0065
05b8
1298
05b9
0005
05ba
0073
05bb
006f
05bc
0072
05bd
0074
05be
13a2
05bf
0005
05c0
0074
05c1
0079
05c2
0070
05c3
0065
05c4
1267
05c5
0005
05c6
0077
05c7
0067
05c8
0065
05c9
0074
05ca
13f0
05cb
0005
05cc
0077
05cd
0073
05ce
0065
05cf
0074
05d0
1406
05d1
0006
05d2
0072
05d3
0061
05d4
006e
05d5
0067
05d6
0065
05d7
113d
05d8
0006
05d9
0066
05da
006c
05db
006f
05dc
0061
05dd
0074
05de
12ee
05df
0006
05e0
0069
05e1
006e
05e2
0070
05e3
0075
05e4
0074
05e5
1129
05e6
0006
05e7
0077
05e8
0072
05e9
0069
05ea
0074
05eb
0065
05ec
149c
05ed
0007
05ee
0063
05ef
0075
05f0
0072
05f1
0073
05f2
006f
05f3
0072
05f4
13ba
05f5
0007
05f6
0066
05f7
006f
05f8
0072
05f9
006d
05fa
0061
05fb
0074
05fc
127d
05fd
0007
05fe
006c
05ff
006f
0600
0063
0601
0061
0602
006c
0603
0073
0604
119c
0605
0007
0606
0073
0607
0063
0608
0072
0609
006f
060a
006c
060b
006c
060c
1521
060d
0008
060e
0067
060f
006c
0610
006f
0611
0062
0612
0061
0613
006c
0614
0073
0615
11a5
0616
0001
0617
0eff
0618
0007
0619
0061
061a
0070
061b
0070
061c
0065
061d
006e
061e
0064
061f
10ff
0620
0007
0621
0069
0622
006e
0623
0073
0624
0065
0625
0072
0626
0074
0627
110c
0628
0001
0629
0eff
062a
0007
062b
0063
062c
0072
062d
0065
062e
0061
062f
0074
0630
0065
0631
10ea
0632
0001
0633
0eff
0634
0008
0635
0064
0636
0065
0637
0063
0638
0072
0639
0079
063a
0070
063b
0074
063c
2ade
063d
0008
063e
0065
063f
006e
0640
0063
0641
0072
0642
0079
0643
0070
0644
0074
0645
2aec
0646
0006
0647
006c
0648
006f
0649
0077
064a
0065
064b
0072
064c
2a33
064d
0006
064e
0075
064f
0070
0650
0070
0651
0065
0652
0072
0653
2a4a
0654
0005
0655
0066
0656
0069
0657
006e
0658
0064
0659
2a5f
065a
0008
065b
0072
065c
0065
065d
0070
065e
006c
065f
0061
0660
0063
0661
0065
0662
2b22
0663
0006
0664
0073
0665
0070
0666
006c
0667
0069
0668
0074
0669
2b69
066a
0009
066b
0065
066c
006e
066d
0064
066e
0073
066f
0077
0670
0069
0671
0074
0672
0068
0673
2a9b
0674
000b
0675
0073
0676
0074
0677
0061
0678
0072
0679
0074
067a
0073
067b
0077
067c
0069
067d
0074
067e
0068
067f
2a9f
0680
0008
0681
0069
0682
0073
0683
0061
0684
006c
0685
0070
0686
0068
0687
0061
0688
2a03
0689
0008
068a
0069
068b
0073
068c
0064
068d
0069
068e
0067
068f
0069
0690
0074
0691
2a1e
0692
0001
0693
0eff
0694
0003
0695
0069
0696
0066
0697
0444
0698
0003
0699
006f
069a
0072
069b
04b0
069c
0003
069d
0069
069e
0073
069f
04c0
06a0
0003
06a1
0069
06a2
006e
06a3
04b8
06a4
0004
06a5
0063
06a6
006c
06a7
0073
06a8
0448
06a9
0004
06aa
0061
06ab
006e
06ac
0064
06ad
04b4
06ae
0004
06af
006e
06b0
006f
06b1
0074
06b2
04bc
06b3
0004
06b4
0064
06b5
0065
06b6
006c
06b7
044c
06b8
0004
06b9
0066
06ba
006f
06bb
0072
06bc
0450
06bd
0004
06be
0069
06bf
006e
06c0
0066
06c1
0428
06c2
0004
06c3
006e
06c4
0061
06c5
006e
06c6
0428
06c7
0004
06c8
0072
06c9
0075
06ca
006e
06cb
0454
06cc
0005
06cd
0074
06ce
0072
06cf
0075
06d0
0065
06d1
0438
06d2
0005
06d3
006e
06d4
006f
06d5
006e
06d6
0065
06d7
0434
06d8
0005
06d9
0065
06da
006c
06db
0069
06dc
0066
06dd
0458
06de
0005
06df
0065
06e0
006c
06e1
0073
06e2
0065
06e3
045c
06e4
0005
06e5
0070
06e6
0061
06e7
0073
06e8
0073
06e9
0460
06ea
0006
06eb
0066
06ec
0061
06ed
006c
06ee
0073
06ef
0065
06f0
043c
06f1
0006
06f2
0070
06f3
0072
06f4
0069
06f5
006e
06f6
0074
06f7
0464
06f8
0006
06f9
0077
06fa
0068
06fb
0069
06fc
006c
06fd
0065
06fe
0468
06ff
0006
0700
0072
0701
0065
0702
0073
0703
0065
0704
0074
0705
0470
0706
0006
0707
0062
0708
0072
0709
0065
070a
0061
070b
006b
070c
046c
070d
0007
070e
0072
070f
0065
0710
0074
0711
0075
0712
0072
0713
006e
0714
0474
0715
0009
0716
0063
0717
006f
0718
006e
0719
0074
071a
0069
071b
006e
071c
0075
071d
0065
071e
0478
071f
0001
0720
042c
0721
1cdc
0722
00c6
0723
00c6
0724
00c6
0725
00c6
0726
00c6
0727
00c6
0728
00c6
0729
00c6
072a
00c6
072b
1bcc
072c
00c6
072d
00c6
072e
00c6
072f
00c6
0730
00c6
0731
00c6
0732
1bcc
0733
00c6
0734
00c6
0735
00c6
0736
00c6
0737
00c6
0738
00c6
0739
00c6
073a
00c6
073b
00c6
073c
00c6
073d
00c6
073e
00c6
073f
00c6
0740
00c6
0741
1dbe
0742
1cca
0743
1d47
0744
1db9
0745
1d26
0746
1c78
0747
1c6a
0748
1d47
0749
1c16
074a
1c1b
074b
1c42
074c
1c34
074d
1c11
074e
1c3b
074f
1bfa
0750
1c71
0751
1ce3
0752
1ce3
0753
1ce3
0754
1ce3
0755
1ce3
0756
1ce3
0757
1ce3
0758
1ce3
0759
1ce3
075a
1ce3
075b
1c0c
075c
00c6
075d
1c86
075e
1c7f
075f
1ca8
0760
00c6
0761
00c6
0762
1d26
0763
1d26
0764
1d26
0765
1d26
0766
1d26
0767
1d26
0768
1d26
0769
1d26
076a
1d26
076b
1d26
076c
1d26
076d
1d26
076e
1d26
076f
1d26
0770
1d26
0771
1d26
0772
1d26
0773
1d26
0774
1d26
0775
1d26
0776
1d26
0777
1d26
0778
1d26
0779
1d26
077a
1d26
077b
1d26
077c
1c2a
077d
00c6
077e
1c2f
077f
1c5c
0780
1d26
0781
00c6
0782
1d26
0783
1d26
0784
1d26
0785
1d26
0786
1d26
0787
1d26
0788
1d26
0789
1d26
078a
1d26
078b
1d26
078c
1d26
078d
1d26
078e
1d26
078f
1d26
0790
1d26
0791
1d26
0792
1d26
0793
1d26
0794
1d26
0795
1d26
0796
1d26
0797
1d26
0798
1d26
0799
1d26
079a
1d26
079b
1d26
079c
1c20
079d
1c63
079e
1c25
079f
1c07
07a0
00c6
#include "data.dasm16"
admiral.dasm16
3
3543
07a1
8701
07a2
9701
07a3
7c20
07a4
2039
07a5
7881
07a6
025c
07a7
3381
07a8
8701
07a9
9701
07aa
7c20
07ab
2039
07ac
7841
07ad
025c
07ae
7c52
07af
0468
07b0
7c20
07b1
00c6
07b2
7c52
07b3
0444
07b4
7c20
07b5
00c6
07b6
7c52
07b7
0450
07b8
7c20
07b9
00c6
07ba
7881
07bb
025c
07bc
3381
07bd
7c20
07be
1ba6
07bf
7c61
07c0
029d
07c1
7f81
07c2
2026
07c3
7c20
07c4
00c6
07c5
7c20
07c6
1ba6
07c7
7c20
07c8
2ee2
07c9
7c61
07ca
029d
07cb
7f81
07cc
2026
07cd
7c20
07ce
2ee2
07cf
8761
07d0
84a1
07d1
8781
07d2
7c20
07d3
1ba6
07d4
7fd2
07d5
0414
07d6
025c
07d7
7f81
07d8
07ee
07d9
7fd2
07da
0410
07db
025c
07dc
7f81
07dd
07ee
07de
8701
07df
7c20
07e0
0ab4
07e1
0ea1
07e2
ffff
07e3
0f01
07e4
7c20
07e5
1dfc
07e6
0ea1
07e7
ffff
07e8
a671
07e9
0001
07ea
7c20
07eb
00c6
07ec
7f81
07ed
07f1
07ee
7ea1
07ef
03c0
07f0
ffff
07f1
5701
07f2
ffff
07f3
7c20
07f4
3094
07f5
0ea1
07f6
ffff
07f7
aa71
07f8
0001
07f9
7c20
07fa
00c6
07fb
af01
07fc
8b01
07fd
7c20
07fe
21d3
07ff
0ea1
0800
fffe
0801
0f01
0802
7f01
0803
03d6
0804
7b01
0805
0235
0806
7c20
0807
2f54
0808
9b01
0809
9701
080a
7c20
080b
21d3
080c
0ea1
080d
fffc
080e
5701
080f
fffe
0810
7f01
0811
03e0
0812
0f01
0813
7c20
0814
2f54
0815
5461
0816
ffff
0817
a672
0818
0001
0819
7f81
081a
0822
081b
5701
081c
fffe
081d
7f01
081e
03db
081f
0f01
0820
7c20
0821
2f54
0822
7fd2
0823
0414
0824
025c
0825
7f81
0826
083e
0827
7fd2
0828
0410
0829
025c
082a
7f81
082b
083e
082c
8701
082d
7c20
082e
0ab4
082f
0ea1
0830
fffd
0831
0f01
0832
7c20
0833
1dfc
0834
0ea1
0835
fffd
0836
5701
0837
fffc
0838
5701
0839
fffd
083a
7c20
083b
27d8
083c
7f81
083d
0822
083e
7b01
083f
0236
0840
57c1
0841
fffe
0842
0236
0843
7c20
0844
1b44
0845
5461
0846
ffff
0847
a672
0848
0001
0849
7f81
084a
0858
084b
5701
084c
ffff
084d
7f01
084e
03cb
084f
7c20
0850
2f2e
0851
8472
0852
7c20
0853
00c6
0854
a673
0855
0001
0856
7c20
0857
00c6
0858
7c20
0859
1b35
085a
7c20
085b
07a1
085c
0ea1
085d
fffd
085e
7e72
085f
2000
0860
0001
0861
7f81
0862
0872
0863
7fd3
0864
0410
0865
025c
0866
7f81
0867
085a
0868
7c01
0869
029d
086a
7c20
086b
1b52
086c
6bc1
086d
0006
086e
0236
086f
0061
0870
7f81
0871
2026
0872
2c01
0873
7e13
0874
0474
0875
0001
0876
7c20
0877
00c6
0878
4301
0879
0002
087a
7c20
087b
1dfc
087c
0c01
087d
7f81
087e
086a
087f
7c20
0880
1ba6
0881
7fd2
0882
0414
0883
025c
0884
7f81
0885
08b7
0886
7fd2
0887
0410
0888
025c
0889
7f81
088a
08bb
088b
8701
088c
7c20
088d
0ab4
088e
0ea1
088f
ffff
0890
7e72
0891
0100
0892
0001
0893
7f81
0894
089f
0895
0f01
0896
7c20
0897
1dfc
0898
0ea1
0899
ffff
089a
0f01
089b
7c20
089c
2050
089d
7f81
089e
0881
089f
0f01
08a0
7c20
08a1
1dfc
08a2
0ea1
08a3
ffff
08a4
0f01
08a5
7f01
08a6
08ab
08a7
7c20
08a8
28e4
08a9
7f81
08aa
0881
08ab
0b01
08ac
6b01
08ad
0002
08ae
7c20
08af
2050
08b0
7c41
08b1
0020
08b2
7c20
08b3
2ef4
08b4
6041
08b5
6321
08b6
6381
08b7
7f01
08b8
0414
08b9
7c20
08ba
1b9d
08bb
ac41
08bc
7c20
08bd
2ef4
08be
7c61
08bf
029d
08c0
7f81
08c1
2026
08c2
7c20
08c3
1ba6
08c4
9301
08c5
7f01
08c6
2000
08c7
7c20
08c8
2770
08c9
0ea1
08ca
ffff
08cb
2c01
08cc
7e01
08cd
0474
08ce
0001
08cf
7e01
08d0
029b
08d1
0002
08d2
7fd2
08d3
0414
08d4
025c
08d5
7f81
08d6
08e4
08d7
7fd2
08d8
0410
08d9
025c
08da
7f81
08db
08e4
08dc
8701
08dd
7c20
08de
0ab4
08df
5401
08e0
ffff
08e1
2001
08e2
0e01
08e3
0002
08e4
5461
08e5
ffff
08e6
7f81
08e7
2026
08e8
7821
08e9
025c
08ea
7c20
08eb
1ba6
08ec
7fd3
08ed
0414
08ee
025c
08ef
7fd3
08f0
0410
08f1
025c
08f2
7c20
08f3
00c6
08f4
7c20
08f5
1ba6
08f6
9301
08f7
7f01
08f8
2000
08f9
7c20
08fa
2770
08fb
2c01
08fc
0601
08fd
0001
08fe
7e01
08ff
029d
0900
0002
0901
7f81
0902
2026
0903
7c20
0904
1ba6
0905
7fd3
0906
0414
0907
025c
0908
7fd3
0909
0410
090a
025c
090b
7c20
090c
00c6
090d
7c61
090e
029d
090f
7f81
0910
2026
0911
7c20
0912
1ba6
0913
7c20
0914
09f4
0915
8701
0916
7c20
0917
0ad6
0918
0ea1
0919
fffd
091a
7f01
091b
04b8
091c
7c20
091d
1b9d
091e
8701
091f
7c20
0920
0ab4
0921
0ea1
0922
fffc
0923
0f01
0924
7c20
0925
1dfc
0926
0ea1
0927
fffc
0928
7f01
0929
04ac
092a
7c20
092b
1b9d
092c
7c20
092d
1b44
092e
84c1
092f
5401
0930
fffd
0931
5421
0932
fffc
0933
2441
0934
28d2
0935
7f81
0936
0971
0937
1842
0938
a632
0939
0001
093a
7f81
093b
094c
093c
0301
093d
4b01
093e
0001
093f
7c20
0940
1f3a
0941
7c20
0942
0a85
0943
7e72
0944
2000
0945
0001
0946
7f81
0947
095d
0948
7c20
0949
1b52
094a
7f9e
094b
092f
094c
9612
094d
0001
094e
7f81
094f
0957
0950
0301
0951
4b01
0952
0001
0953
7c20
0954
1fb1
0955
7f81
0956
0941
0957
0301
0958
0701
0959
7c20
095a
1f3a
095b
7f81
095c
0941
095d
2c01
095e
7e12
095f
0478
0960
0001
0961
7f81
0962
0948
0963
7e12
0964
046c
0965
0001
0966
7f81
0967
096f
0968
7e12
0969
0474
096a
0001
096b
7f81
096c
0975
096d
7c20
096e
00c6
096f
7c20
0970
1b52
0971
7c20
0972
0a5e
0973
7c61
0974
029d
0975
57c1
0976
ffff
0977
0236
0978
7f81
0979
2026
097a
7c20
097b
1ba6
097c
7fd2
097d
0414
097e
025c
097f
7f81
0980
0990
0981
7fd2
0982
0410
0983
025c
0984
7f81
0985
0990
0986
8701
0987
7c20
0988
0ab4
0989
0ea1
098a
ffff
098b
0f01
098c
7c20
098d
1fdd
098e
7f81
098f
097c
0990
7c61
0991
029d
0992
7f81
0993
2026
0994
7c20
0995
1ba6
0996
8701
0997
7c20
0998
0ab4
0999
0ea1
099a
fffd
099b
0f01
099c
7c20
099d
1dfc
099e
0ea1
099f
fffd
09a0
0f01
09a1
7c20
09a2
1ea9
09a3
0ea1
09a4
fffd
09a5
7f01
09a6
04ac
09a7
7c20
09a8
1b9d
09a9
7eb2
09aa
02e7
09ab
fffd
09ac
7f81
09ad
09d5
09ae
7c20
09af
0a85
09b0
7e72
09b1
2000
09b2
0001
09b3
7f81
09b4
2026
09b5
7fd2
09b6
0410
09b7
025c
09b8
7f81
09b9
09f0
09ba
7f81
09bb
09c9
09bc
7f01
09bd
04ac
09be
7c20
09bf
0a4e
09c0
7c20
09c1
1ba6
09c2
7c20
09c3
0a5e
09c4
7fd2
09c5
0410
09c6
025c
09c7
7f81
09c8
09f0
09c9
7fd2
09ca
0458
09cb
025c
09cc
7f81
09cd
09bc
09ce
7fd2
09cf
045c
09d0
025c
09d1
7f81
09d2
09bc
09d3
7f81
09d4
09f0
09d5
7c20
09d6
0a5e
09d7
7fd2
09d8
0458
09d9
025c
09da
7f81
09db
0994
09dc
7fd2
09dd
045c
09de
025c
09df
7f81
09e0
09e3
09e1
7f81
09e2
09f0
09e3
7c20
09e4
1ba6
09e5
7f01
09e6
04ac
09e7
7c20
09e8
1b9d
09e9
7c20
09ea
0a85
09eb
7e72
09ec
2000
09ed
0001
09ee
7f81
09ef
2026
09f0
7c61
09f1
029d
09f2
7f81
09f3
2026
09f4
7aa1
09f5
0236
09f6
ffff
09f7
9b01
09f8
8b01
09f9
7c20
09fa
21d3
09fb
0ea1
09fc
fffe
09fd
0fc1
09fe
0236
09ff
0f01
0a00
7f01
0a01
03d2
0a02
5701
0a03
ffff
0a04
7c20
0a05
2f54
0a06
6381
0a07
7c20
0a08
1ba6
0a09
7c20
0a0a
09f4
0a0b
7c20
0a0c
1b44
0a0d
8701
0a0e
7c20
0a0f
0ab4
0a10
0ea1
0a11
fffd
0a12
0f01
0a13
7c20
0a14
1ea9
0a15
0ea1
0a16
fffd
0a17
7f01
0a18
04ac
0a19
7c20
0a1a
1b9d
0a1b
7eb2
0a1c
02e7
0a1d
fffd
0a1e
7f81
0a1f
0a45
0a20
7c20
0a21
0a85
0a22
7e72
0a23
2000
0a24
0001
0a25
7f81
0a26
0a2b
0a27
7c20
0a28
1b52
0a29
7f81
0a2a
0a0d
0a2b
2c01
0a2c
7e12
0a2d
0478
0a2e
0001
0a2f
7f81
0a30
0a27
0a31
7e12
0a32
046c
0a33
0001
0a34
7f81
0a35
0a3d
0a36
7e12
0a37
0474
0a38
0001
0a39
7f81
0a3a
0a49
0a3b
7c20
0a3c
00c6
0a3d
7c20
0a3e
1b52
0a3f
7f01
0a40
04ac
0a41
7c20
0a42
0a4e
0a43
7c20
0a44
1ba6
0a45
7c20
0a46
0a5e
0a47
7c61
0a48
029d
0a49
57c1
0a4a
ffff
0a4b
0236
0a4c
7f81
0a4d
2026
0a4e
6bd2
0a4f
0001
0a50
025c
0a51
7f81
0a52
0a5c
0a53
7fd2
0a54
0410
0a55
025c
0a56
7f81
0a57
0a5c
0a58
7c20
0a59
1ba6
0a5a
7f81
0a5b
0a4e
0a5c
6321
0a5d
6381
0a5e
8701
0a5f
8701
0a60
7c20
0a61
2039
0a62
7fd2
0a63
0414
0a64
025c
0a65
7c20
0a66
0a6f
0a67
7f01
0a68
0414
0a69
7c20
0a6a
0a4e
0a6b
7c20
0a6c
1ba6
0a6d
7f81
0a6e
2026
0a6f
7c20
0a70
1ba6
0a71
7f01
0a72
0418
0a73
7c20
0a74
1b9d
0a75
8801
0a76
7fd2
0a77
0418
0a78
025c
0a79
8802
0a7a
7fd2
0a7b
041c
0a7c
025c
0a7d
8803
0a7e
7c20
0a7f
1ba6
0a80
8412
0a81
7f81
0a82
2026
0a83
7f81
0a84
0a76
0a85
8701
0a86
8701
0a87
7c20
0a88
2039
0a89
7fd2
0a8a
0414
0a8b
025c
0a8c
7f81
0a8d
0a92
0a8e
7c20
0a8f
07a8
0a90
7f81
0a91
2026
0a92
7c20
0a93
1ba6
0a94
7f01
0a95
0418
0a96
7c20
0a97
1b9d
0a98
7c20
0a99
07a1
0a9a
7e72
0a9b
2000
0a9c
0001
0a9d
7f81
0a9e
2026
0a9f
7fd2
0aa0
041c
0aa1
025c
0aa2
7f81
0aa3
0aab
0aa4
7fd2
0aa5
0410
0aa6
025c
0aa7
7f81
0aa8
2026
0aa9
7f81
0aaa
0a98
0aab
7c20
0aac
1ba6
0aad
7f81
0aae
2026
0aaf
8701
0ab0
7c20
0ab1
0ab4
0ab2
7f81
0ab3
2026
0ab4
8b01
0ab5
8b01
0ab6
7c20
0ab7
2039
0ab8
5421
0ab9
000a
0aba
7841
0abb
025c
0abc
4820
0abd
0001
0abe
0ea1
0abf
ffff
0ac0
7841
0ac1
025c
0ac2
4834
0ac3
0003
0ac4
7f81
0ac5
0ad2
0ac6
4832
0ac7
0003
0ac8
7f81
0ac9
0ad2
0aca
5701
0acb
ffff
0acc
4820
0acd
0002
0ace
0ea1
0acf
ffff
0ad0
7f81
0ad1
0ac0
0ad2
5461
0ad3
ffff
0ad4
7f81
0ad5
2026
0ad6
8b01
0ad7
8b01
0ad8
7c20
0ad9
2039
0ada
5421
0adb
000a
0adc
8481
0add
7fd2
0ade
042c
0adf
025c
0ae0
7c81
0ae1
0b0e
0ae2
7fd2
0ae3
0510
0ae4
025c
0ae5
7c81
0ae6
0b3d
0ae7
8492
0ae8
7c20
0ae9
00c6
0aea
1020
0aeb
0ea1
0aec
ffff
0aed
7841
0aee
025c
0aef
4834
0af0
0003
0af1
7f81
0af2
0ad2
0af3
4832
0af4
0003
0af5
7f81
0af6
0ad2
0af7
8481
0af8
7c52
0af9
0508
0afa
7c81
0afb
0fa5
0afc
7c52
0afd
0520
0afe
7c81
0aff
102b
0b00
7c52
0b01
04a8
0b02
7c81
0b03
1079
0b04
8492
0b05
7f81
0b06
0ad2
0b07
5701
0b08
ffff
0b09
1020
0b0a
0ea1
0b0b
ffff
0b0c
7f81
0b0d
0aed
0b0e
7c20
0b0f
1b65
0b10
0ea1
0b11
ffff
0b12
7c20
0b13
1ba6
0b14
5461
0b15
ffff
0b16
6381
0b17
7c01
0b18
2313
0b19
7f81
0b1a
0b21
0b1b
7c01
0b1c
1887
0b1d
7f81
0b1e
0b21
0b1f
7c01
0b20
22c3
0b21
7c20
0b22
1b65
0b23
0ea1
0b24
ffff
0b25
0f01
0b26
0020
0b27
0ea1
0b28
ffff
0b29
7c20
0b2a
1ba6
0b2b
5461
0b2c
ffff
0b2d
6381
0b2e
7c20
0b2f
1ba6
0b30
7c61
0b31
029b
0b32
6381
0b33
7c20
0b34
1ba6
0b35
7c61
0b36
02e9
0b37
6381
0b38
7c20
0b39
1ba6
0b3a
7c61
0b3b
02e7
0b3c
6381
0b3d
8701
0b3e
8b01
0b3f
7c20
0b40
2039
0b41
7c20
0b42
1ba6
0b43
7fd2
0b44
0514
0b45
025c
0b46
7f81
0b47
0b5a
0b48
8701
0b49
7c20
0b4a
0ab4
0b4b
0ea1
0b4c
ffff
0b4d
7e70
0b4e
0100
0b4f
0001
0b50
9661
0b51
0001
0b52
7f01
0b53
0514
0b54
7c20
0b55
1b9d
0b56
5461
0b57
ffff
0b58
7f81
0b59
2026
0b5a
7c20
0b5b
1ba6
0b5c
8701
0b5d
9701
0b5e
7c20
0b5f
2770
0b60
7f81
0b61
2026
0b62
8701
0b63
8f01
0b64
7c20
0b65
2039
0b66
7c20
0b67
1ba6
0b68
7fd2
0b69
050c
0b6a
025c
0b6b
7f81
0b6c
0b90
0b6d
8701
0b6e
7c20
0b6f
0ab4
0b70
0ea1
0b71
ffff
0b72
7e72
0b73
0100
0b74
0001
0b75
7f81
0b76
0b84
0b77
9b01
0b78
8f01
0b79
7c20
0b7a
21d3
0b7b
0ea1
0b7c
fffe
0b7d
2c01
0b7e
8901
0b7f
5601
0b80
ffff
0b81
0001
0b82
7f81
0b83
0b88
0b84
8e61
0b85
0001
0b86
0ea1
0b87
fffe
0b88
7f01
0b89
050c
0b8a
7c20
0b8b
1b9d
0b8c
5461
0b8d
fffe
0b8e
7f81
0b8f
2026
0b90
7c20
0b91
1ba6
0b92
9b01
0b93
8f01
0b94
7c20
0b95
21d3
0b96
7f81
0b97
2026
0b98
8701
0b99
9701
0b9a
7c20
0b9b
2039
0b9c
9b01
0b9d
8b01
0b9e
7c20
0b9f
21d3
0ba0
0ea1
0ba1
ffff
0ba2
7c20
0ba3
1ba6
0ba4
7fd2
0ba5
051c
0ba6
025c
0ba7
7f81
0ba8
0bda
0ba9
8701
0baa
7c20
0bab
0ab4
0bac
0ea1
0bad
fffd
0bae
0f01
0baf
7c20
0bb0
1dfc
0bb1
0ea1
0bb2
fffd
0bb3
7f01
0bb4
04ac
0bb5
7c20
0bb6
1b9d
0bb7
7f01
0bb8
0030
0bb9
7c20
0bba
0ab4
0bbb
0ea1
0bbc
fffc
0bbd
0f01
0bbe
7c20
0bbf
1dfc
0bc0
0ea1
0bc1
fffc
0bc2
8f01
0bc3
9701
0bc4
7c20
0bc5
2770
0bc6
0ea1
0bc7
fffe
0bc8
2c01
0bc9
5601
0bca
fffd
0bcb
0001
0bcc
5601
0bcd
fffc
0bce
0002
0bcf
5701
0bd0
ffff
0bd1
5701
0bd2
fffe
0bd3
7c20
0bd4
27d8
0bd5
7fd2
0bd6
04a8
0bd7
025c
0bd8
7f81
0bd9
0ba2
0bda
7f01
0bdb
051c
0bdc
7c20
0bdd
1b9d
0bde
5461
0bdf
ffff
0be0
7f81
0be1
2026
0be2
7c20
0be3
1ba6
0be4
7f01
0be5
0150
0be6
7c20
0be7
0ab4
0be8
6381
0be9
8701
0bea
8b01
0beb
7c20
0bec
2039
0bed
7c20
0bee
1ba6
0bef
7f01
0bf0
0150
0bf1
7c20
0bf2
0ab4
0bf3
0ea1
0bf4
ffff
0bf5
0f01
0bf6
7c20
0bf7
1dfc
0bf8
0ea1
0bf9
ffff
0bfa
8481
0bfb
7e70
0bfc
0030
0bfd
0001
0bfe
7c81
0bff
24c3
0c00
7e72
0c01
0040
0c02
0001
0c03
7c81
0c04
1578
0c05
8492
0c06
7c20
0c07
00c6
0c08
0f01
0c09
1020
0c0a
7f81
0c0b
2026
0c0c
8701
0c0d
8b01
0c0e
7c20
0c0f
2039
0c10
7c20
0c11
1ba6
0c12
7f01
0c13
0160
0c14
7c20
0c15
0ab4
0c16
0ea1
0c17
ffff
0c18
0f01
0c19
7c20
0c1a
1dfc
0c1b
0ea1
0c1c
ffff
0c1d
7e72
0c1e
0030
0c1f
0001
0c20
7f81
0c21
0c24
0c22
7c20
0c23
00c6
0c24
0f01
0c25
7c20
0c26
24bc
0c27
7f81
0c28
2026
0c29
8701
0c2a
8b01
0c2b
7c20
0c2c
2039
0c2d
7c20
0c2e
1ba6
0c2f
7f01
0c30
0055
0c31
7c20
0c32
0ab4
0c33
0ea1
0c34
ffff
0c35
0f01
0c36
7c20
0c37
1dfc
0c38
0ea1
0c39
ffff
0c3a
0f01
0c3b
7c20
0c3c
1ea9
0c3d
0c01
0c3e
7c61
0c3f
02e7
0c40
7c12
0c41
02e7
0c42
7c61
0c43
02e9
0c44
7f81
0c45
2026
0c46
8b01
0c47
8f01
0c48
7c20
0c49
2039
0c4a
7c20
0c4b
0c6e
0c4c
7c61
0c4d
02e9
0c4e
7eb2
0c4f
02e7
0c50
ffff
0c51
7c61
0c52
02e7
0c53
7eb2
0c54
02e7
0c55
fffe
0c56
7c61
0c57
02e7
0c58
7f81
0c59
2026
0c5a
8b01
0c5b
8f01
0c5c
7c20
0c5d
2039
0c5e
7c20
0c5f
0c6e
0c60
7c61
0c61
02e7
0c62
7eb2
0c63
02e9
0c64
ffff
0c65
7c61
0c66
02e9
0c67
7eb2
0c68
02e9
0c69
fffe
0c6a
7c61
0c6b
02e9
0c6c
7f81
0c6d
2026
0c6e
7c20
0c6f
1ba6
0c70
5701
0c71
000a
0c72
7c20
0c73
1dfc
0c74
0ea1
0c75
ffff
0c76
0f01
0c77
7c20
0c78
1ea9
0c79
0ea1
0c7a
ffff
0c7b
7841
0c7c
025c
0c7d
4b01
0c7e
0003
0c7f
7c20
0c80
0ab4
0c81
0ea1
0c82
fffe
0c83
5701
0c84
fffe
0c85
7c20
0c86
1dfc
0c87
0ea1
0c88
fffe
0c89
0f01
0c8a
7c20
0c8b
1ea9
0c8c
0ea1
0c8d
fffe
0c8e
6381
0c8f
8b01
0c90
8f01
0c91
7c20
0c92
2039
0c93
8801
0c94
7c20
0c95
1ba6
0c96
7fd3
0c97
04bc
0c98
025c
0c99
8401
0c9a
7fd2
0c9b
04bc
0c9c
025c
0c9d
7c20
0c9e
1ba6
0c9f
5701
0ca0
000a
0ca1
7c20
0ca2
1dfc
0ca3
0ea1
0ca4
ffff
0ca5
7f01
0ca6
0070
0ca7
7c20
0ca8
0ab4
0ca9
0ea1
0caa
fffe
0cab
5701
0cac
fffe
0cad
7c20
0cae
1dfc
0caf
0ea1
0cb0
fffe
0cb1
8812
0cb2
7f81
0cb3
0cbc
0cb4
7c61
0cb5
02e7
0cb6
5472
0cb7
ffff
0cb8
7c61
0cb9
02e9
0cba
7f81
0cbb
2026
0cbc
7c61
0cbd
02e9
0cbe
5472
0cbf
ffff
0cc0
7c61
0cc1
02e7
0cc2
7f81
0cc3
2026
0cc4
8b01
0cc5
8f01
0cc6
7c20
0cc7
2039
0cc8
7c20
0cc9
1ba6
0cca
8801
0ccb
7f81
0ccc
0cd2
0ccd
8b01
0cce
8f01
0ccf
7c20
0cd0
2039
0cd1
8401
0cd2
7f01
0cd3
04b8
0cd4
7c20
0cd5
1b9d
0cd6
5701
0cd7
000a
0cd8
7c20
0cd9
1dfc
0cda
0ea1
0cdb
ffff
0cdc
7f01
0cdd
0060
0cde
7c20
0cdf
0ab4
0ce0
0ea1
0ce1
fffe
0ce2
5701
0ce3
fffe
0ce4
7c20
0ce5
1dfc
0ce6
0ea1
0ce7
fffe
0ce8
a670
0ce9
0001
0cea
7f81
0ceb
0cf6
0cec
8a70
0ced
0001
0cee
7f81
0cef
0d00
0cf0
9e70
0cf1
0001
0cf2
7f81
0cf3
0d0a
0cf4
7c20
0cf5
00c6
0cf6
0f01
0cf7
5701
0cf8
ffff
0cf9
7c20
0cfa
29de
0cfb
8072
0cfc
7f81
0cfd
0d19
0cfe
7f81
0cff
0d12
0d00
0f01
0d01
5701
0d02
ffff
0d03
7c20
0d04
2f2e
0d05
8472
0d06
7f81
0d07
0d19
0d08
7f81
0d09
0d12
0d0a
0f01
0d0b
5701
0d0c
ffff
0d0d
7c20
0d0e
28f9
0d0f
8072
0d10
7f81
0d11
0d19
0d12
7c61
0d13
02e9
0d14
8812
0d15
7c61
0d16
02e7
0d17
7f81
0d18
2026
0d19
7c61
0d1a
02e7
0d1b
8812
0d1c
7c61
0d1d
02e9
0d1e
7f81
0d1f
2026
0d20
8b01
0d21
8f01
0d22
7c20
0d23
2039
0d24
7c20
0d25
0d6e
0d26
7c61
0d27
02e9
0d28
8812
0d29
7c61
0d2a
02e7
0d2b
7f81
0d2c
2026
0d2d
8b01
0d2e
8f01
0d2f
7c20
0d30
2039
0d31
7c20
0d32
0d6e
0d33
7c61
0d34
02e7
0d35
8012
0d36
7c61
0d37
02e9
0d38
7f81
0d39
2026
0d3a
8b01
0d3b
8f01
0d3c
7c20
0d3d
2039
0d3e
7c20
0d3f
0d6e
0d40
7c61
0d41
02e9
0d42
8012
0d43
7c61
0d44
02e7
0d45
7f81
0d46
2026
0d47
8b01
0d48
8f01
0d49
7c20
0d4a
2039
0d4b
7c20
0d4c
0d6e
0d4d
7c61
0d4e
02e7
0d4f
8812
0d50
7c61
0d51
02e9
0d52
7f81
0d53
2026
0d54
8b01
0d55
8f01
0d56
7c20
0d57
2039
0d58
7c20
0d59
0d6e
0d5a
7c61
0d5b
02e7
0d5c
8413
0d5d
7c61
0d5e
02e9
0d5f
7f81
0d60
2026
0d61
8b01
0d62
8f01
0d63
7c20
0d64
2039
0d65
7c20
0d66
0d6e
0d67
7c61
0d68
02e7
0d69
8412
0d6a
7c61
0d6b
02e9
0d6c
7f81
0d6d
2026
0d6e
7c20
0d6f
1ba6
0d70
7f01
0d71
0080
0d72
7c20
0d73
0ab4
0d74
0ea1
0d75
fffe
0d76
5701
0d77
000a
0d78
7c20
0d79
1dfc
0d7a
0ea1
0d7b
ffff
0d7c
5701
0d7d
fffe
0d7e
7c20
0d7f
1dfc
0d80
0ea1
0d81
fffe
0d82
5701
0d83
ffff
0d84
5701
0d85
fffe
0d86
7c20
0d87
1dc0
0d88
0c01
0d89
6381
0d8a
8b01
0d8b
8f01
0d8c
7c20
0d8d
2039
0d8e
7c20
0d8f
105f
0d90
7c20
0d91
0d94
0d92
7f81
0d93
2026
0d94
7c20
0d95
2007
0d96
4041
0d97
0001
0d98
444b
0d99
0001
0d9a
7c51
0d9b
ffcf
0d9c
7c81
0d9d
254d
0d9e
7c52
0d9f
0040
0da0
7c81
0da1
15db
0da2
a452
0da3
7c81
0da4
283b
0da5
8c52
0da6
7c81
0da7
283b
0da8
9452
0da9
7c81
0daa
283b
0dab
0301
0dac
0701
0dad
1020
0dae
6381
0daf
8b01
0db0
8f01
0db1
7c20
0db2
2039
0db3
7c20
0db4
105f
0db5
7c20
0db6
0db9
0db7
7f81
0db8
2026
0db9
7c20
0dba
2007
0dbb
4041
0dbc
0001
0dbd
444b
0dbe
0001
0dbf
7c51
0dc0
ffcf
0dc1
7c81
0dc2
253b
0dc3
7c52
0dc4
0040
0dc5
7c81
0dc6
164d
0dc7
7f81
0dc8
0dab
0dc9
8b01
0dca
8f01
0dcb
7c20
0dcc
2039
0dcd
7c20
0dce
105f
0dcf
7c20
0dd0
0dd3
0dd1
7f81
0dd2
2026
0dd3
7c20
0dd4
2007
0dd5
4041
0dd6
0001
0dd7
444b
0dd8
0001
0dd9
7c51
0dda
ffcf
0ddb
7c81
0ddc
25c7
0ddd
7c52
0dde
0040
0ddf
7c81
0de0
165f
0de1
7c52
0de2
0028
0de3
7c81
0de4
2887
0de5
7c52
0de6
0024
0de7
7c81
0de8
2887
0de9
7c52
0dea
0022
0deb
7c81
0dec
2887
0ded
7e13
0dee
0020
0def
0001
0df0
7f81
0df1
0dab
0df2
03a1
0df3
0401
0df4
7421
0df5
7f81
0df6
0dab
0df7
8b01
0df8
8f01
0df9
7c20
0dfa
2039
0dfb
7c20
0dfc
1057
0dfd
7c20
0dfe
0e01
0dff
7f81
0e00
2026
0e01
4041
0e02
0001
0e03
444b
0e04
0001
0e05
7c51
0e06
ffcf
0e07
7c81
0e08
2589
0e09
7e12
0e0a
0040
0e0b
0001
0e0c
7e32
0e0d
0020
0e0e
0001
0e0f
7c81
0e10
1846
0e11
7f81
0e12
0dab
0e13
8b01
0e14
8f01
0e15
7c20
0e16
2039
0e17
7c20
0e18
105f
0e19
7c20
0e1a
0e1d
0e1b
7f81
0e1c
2026
0e1d
4041
0e1e
0001
0e1f
444b
0e20
0001
0e21
7c51
0e22
ffcf
0e23
7c81
0e24
23fa
0e25
7f81
0e26
0dab
0e27
8b01
0e28
8f01
0e29
7c20
0e2a
2039
0e2b
7c20
0e2c
105f
0e2d
7c20
0e2e
0e31
0e2f
7f81
0e30
2026
0e31
4041
0e32
0001
0e33
444b
0e34
0001
0e35
7c51
0e36
ffcf
0e37
7c81
0e38
242e
0e39
7f81
0e3a
0dab
0e3b
8b01
0e3c
8f01
0e3d
7c20
0e3e
2039
0e3f
7c20
0e40
105f
0e41
7c20
0e42
0e45
0e43
7f81
0e44
2026
0e45
4041
0e46
0001
0e47
444b
0e48
0001
0e49
7c51
0e4a
ffcf
0e4b
7c81
0e4c
2436
0e4d
7f81
0e4e
0dab
0e4f
8b01
0e50
8f01
0e51
7c20
0e52
2039
0e53
7c20
0e54
105f
0e55
7c20
0e56
0e59
0e57
7f81
0e58
2026
0e59
4041
0e5a
0001
0e5b
444b
0e5c
0001
0e5d
7c51
0e5e
ffcf
0e5f
7c81
0e60
243e
0e61
7f81
0e62
0dab
0e63
8b01
0e64
8f01
0e65
7c20
0e66
2039
0e67
7c20
0e68
105f
0e69
7c20
0e6a
0e6d
0e6b
7f81
0e6c
2026
0e6d
4041
0e6e
0001
0e6f
444b
0e70
0001
0e71
7c51
0e72
ffcf
0e73
7c81
0e74
2476
0e75
7f81
0e76
0dab
0e77
8b01
0e78
8f01
0e79
7c20
0e7a
2039
0e7b
7c20
0e7c
105f
0e7d
7c20
0e7e
0e81
0e7f
7f81
0e80
2026
0e81
7c20
0e82
2007
0e83
4041
0e84
0001
0e85
444b
0e86
0001
0e87
7c51
0e88
ffcf
0e89
7c81
0e8a
2621
0e8b
7c52
0e8c
0040
0e8d
7c81
0e8e
16d2
0e8f
7f81
0e90
0dab
0e91
8b01
0e92
8f01
0e93
7c20
0e94
2039
0e95
7c20
0e96
105f
0e97
7c20
0e98
0e9b
0e99
7f81
0e9a
2026
0e9b
4041
0e9c
0001
0e9d
444b
0e9e
0001
0e9f
7c51
0ea0
ffcf
0ea1
7c81
0ea2
262d
0ea3
7f81
0ea4
0dab
0ea5
8b01
0ea6
8b01
0ea7
7c20
0ea8
2039
0ea9
7c20
0eaa
1ba6
0eab
ab01
0eac
7c20
0ead
0ab4
0eae
0ea1
0eaf
ffff
0eb0
0f01
0eb1
7c20
0eb2
1dfc
0eb3
0ea1
0eb4
ffff
0eb5
5701
0eb6
000a
0eb7
0f01
0eb8
7c20
0eb9
1f3a
0eba
7f81
0ebb
2026
0ebc
6b01
0ebd
0002
0ebe
6b01
0ebf
0002
0ec0
9701
0ec1
8f01
0ec2
7c20
0ec3
2039
0ec4
7c20
0ec5
1057
0ec6
5420
0ec7
000b
0ec8
0ea1
0ec9
ffff
0eca
5701
0ecb
000a
0ecc
0f01
0ecd
7c20
0ece
1f3a
0ecf
7f81
0ed0
2026
0ed1
7f01
0ed2
0e59
0ed3
7f81
0ed4
0ebc
0ed5
7f01
0ed6
0e6d
0ed7
7f81
0ed8
0ebc
0ed9
7f01
0eda
0e1d
0edb
7f81
0edc
0ebc
0edd
7f01
0ede
0e31
0edf
7f81
0ee0
0ebc
0ee1
7f01
0ee2
0e45
0ee3
7f81
0ee4
0ebc
0ee5
7f01
0ee6
0d94
0ee7
7f81
0ee8
0ebc
0ee9
7f01
0eea
0db9
0eeb
7f81
0eec
0ebc
0eed
7f01
0eee
0dd3
0eef
7f81
0ef0
0ebc
0ef1
7f01
0ef2
0e81
0ef3
7f81
0ef4
0ebc
0ef5
7f01
0ef6
0e9b
0ef7
7f81
0ef8
0ebc
0ef9
8b01
0efa
9701
0efb
7c20
0efc
2039
0efd
7f81
0efe
10b1
0eff
af01
0f00
8b01
0f01
7c20
0f02
21d3
0f03
0ea1
0f04
ffff
0f05
0f01
0f06
7f01
0f07
03d6
0f08
7b01
0f09
0235
0f0a
7c20
0f0b
2f54
0f0c
9b01
0f0d
9701
0f0e
7c20
0f0f
21d3
0f10
0ea1
0f11
fffc
0f12
5701
0f13
ffff
0f14
7f01
0f15
03e0
0f16
0f01
0f17
7c20
0f18
2f54
0f19
5401
0f1a
000a
0f1b
7e13
0f1c
0400
0f1d
0001
0f1e
7f81
0f1f
0f29
0f20
2001
0f21
5701
0f22
ffff
0f23
7f01
0f24
03db
0f25
4301
0f26
0001
0f27
7c20
0f28
2f54
0f29
7c20
0f2a
1ba6
0f2b
7fd2
0f2c
0514
0f2d
025c
0f2e
7f81
0f2f
0f66
0f30
7f01
0f31
0030
0f32
7c20
0f33
0ab4
0f34
0ea1
0f35
fffe
0f36
7fd2
0f37
047c
0f38
025c
0f39
7f81
0f3a
0f47
0f3b
0f01
0f3c
7c20
0f3d
1dfc
0f3e
0ea1
0f3f
fffe
0f40
5701
0f41
fffc
0f42
0f01
0f43
7c20
0f44
27d8
0f45
7f81
0f46
0f61
0f47
7e73
0f48
0800
0f49
0001
0f4a
7c20
0f4b
00c6
0f4c
7c20
0f4d
1ba6
0f4e
7f01
0f4f
0030
0f50
7c20
0f51
0ab4
0f52
0ea1
0f53
fffd
0f54
0f01
0f55
7c20
0f56
1dfc
0f57
0ea1
0f58
fffd
0f59
5701
0f5a
ffff
0f5b
5701
0f5c
fffe
0f5d
5701
0f5e
fffd
0f5f
7c20
0f60
2f54
0f61
7fd2
0f62
04a8
0f63
025c
0f64
7f81
0f65
0f29
0f66
7f01
0f67
0514
0f68
7c20
0f69
1b9d
0f6a
5701
0f6b
000a
0f6c
7c20
0f6d
1dfc
0f6e
0ea1
0f6f
fffe
0f70
a673
0f71
0001
0f72
7c20
0f73
00c6
0f74
7b01
0f75
0236
0f76
57c1
0f77
ffff
0f78
0236
0f79
7c20
0f7a
1b44
0f7b
5461
0f7c
fffe
0f7d
7c20
0f7e
1b35
0f7f
7c20
0f80
07a1
0f81
0ea1
0f82
fffd
0f83
7e72
0f84
2000
0f85
0001
0f86
7f81
0f87
0f97
0f88
7fd3
0f89
0410
0f8a
025c
0f8b
7f81
0f8c
0f7f
0f8d
7c01
0f8e
029d
0f8f
7c20
0f90
1b52
0f91
6bc1
0f92
0006
0f93
0236
0f94
0061
0f95
7f81
0f96
2026
0f97
2c01
0f98
7e13
0f99
0474
0f9a
0001
0f9b
7c20
0f9c
00c6
0f9d
4301
0f9e
0002
0f9f
7c20
0fa0
1dfc
0fa1
0c01
0fa2
7f81
0fa3
0f8f
0fa4
6381
0fa5
8b01
0fa6
9301
0fa7
7c20
0fa8
2039
0fa9
7c20
0faa
1ba6
0fab
5701
0fac
000a
0fad
7c20
0fae
1dfc
0faf
0ea1
0fb0
ffff
0fb1
8a72
0fb2
0001
0fb3
7f81
0fb4
1008
0fb5
be71
0fb6
0001
0fb7
7c20
0fb8
00c6
0fb9
7fd3
0fba
04ac
0fbb
025c
0fbc
7f81
0fbd
0fc3
0fbe
7ea1
0fbf
02a3
0fc0
fffe
0fc1
7f81
0fc2
0fd2
0fc3
8701
0fc4
7c20
0fc5
0ab4
0fc6
0ea1
0fc7
fffe
0fc8
0f01
0fc9
7c20
0fca
1dfc
0fcb
0ea1
0fcc
fffe
0fcd
7fd3
0fce
04ac
0fcf
025c
0fd0
7f81
0fd1
1017
0fd2
7c20
0fd3
1ba6
0fd4
56a1
0fd5
fffe
0fd6
fffd
0fd7
8f01
0fd8
9701
0fd9
7c20
0fda
2770
0fdb
0ea1
0fdc
fffe
0fdd
2c61
0fde
5661
0fdf
fffd
0fe0
0001
0fe1
7fd2
0fe2
050c
0fe3
025c
0fe4
7f81
0fe5
0ff8
0fe6
8701
0fe7
7c20
0fe8
0ab4
0fe9
0ea1
0fea
fffd
0feb
0f01
0fec
7c20
0fed
1dfc
0fee
0ea1
0fef
fffd
0ff0
5401
0ff1
fffe
0ff2
2001
0ff3
5601
0ff4
fffd
0ff5
0002
0ff6
7f81
0ff7
1017
0ff8
5401
0ff9
ffff
0ffa
2001
0ffb
2301
0ffc
7c20
0ffd
22a2
0ffe
0ea1
0fff
fffd
1000
5401
1001
fffe
1002
2001
1003
5601
1004
fffd
1005
0002
1006
7f81
1007
1017
1008
8701
1009
7c20
100a
0ab4
100b
0ea1
100c
fffe
100d
0f01
100e
7c20
100f
1dfc
1010
0ea1
1011
fffe
1012
7e71
1013
00fc
1014
0001
1015
7c20
1016
00c6
1017
7f01
1018
050c
1019
7c20
101a
1b9d
101b
8f01
101c
7f01
101d
0200
101e
7c20
101f
2770
1020
0ea1
1021
fffd
1022
2c01
1023
5601
1024
ffff
1025
0001
1026
5601
1027
fffe
1028
0002
1029
7f81
102a
2026
102b
8b01
102c
9301
102d
7c20
102e
2039
102f
8f01
1030
7f01
1031
0400
1032
7c20
1033
2770
1034
0ea1
1035
ffff
1036
5701
1037
000a
1038
7c20
1039
1dfc
103a
b271
103b
0001
103c
7c20
103d
00c6
103e
5401
103f
ffff
1040
2001
1041
0e01
1042
0001
1043
7c20
1044
1ba6
1045
7fd3
1046
042c
1047
025c
1048
7c20
1049
00c6
104a
7c20
104b
1b65
104c
5401
104d
ffff
104e
2001
104f
0e01
1050
0002
1051
7c20
1052
1ba6
1053
5461
1054
ffff
1055
7f81
1056
2026
1057
7801
1058
025c
1059
4001
105a
0003
105b
8803
105c
0301
105d
7f81
105e
1063
105f
7801
1060
025c
1061
4301
1062
0003
1063
5701
1064
000a
1065
7c20
1066
1dfc
1067
0ea1
1068
ffff
1069
0c01
106a
7c20
106b
1ba6
106c
7c20
106d
0ab4
106e
0ea1
106f
fffe
1070
0f01
1071
7c20
1072
1dfc
1073
0ea1
1074
fffe
1075
0c21
1076
7c81
1077
00c6
1078
6381
1079
8b01
107a
8f01
107b
7c20
107c
2039
107d
5401
107e
000a
107f
02a1
1080
ffff
1081
7e12
1082
0100
1083
0001
1084
7f81
1085
1091
1086
9b01
1087
7f01
1088
0100
1089
7c20
108a
21d3
108b
0ea1
108c
ffff
108d
2c61
108e
8961
108f
0261
1090
0001
1091
7c20
1092
1ba6
1093
7801
1094
025c
1095
7d13
1096
0aaf
1097
7f81
1098
10ad
1099
7f01
109a
0020
109b
7eb2
109c
0ace
109d
0009
109e
7c20
109f
0ab4
10a0
7eb2
10a1
0b0a
10a2
0009
10a3
7c20
10a4
0ad6
10a5
0ea1
10a6
fffe
10a7
5701
10a8
ffff
10a9
5701
10aa
fffe
10ab
7c20
10ac
27d8
10ad
5461
10ae
ffff
10af
7f81
10b0
2026
10b1
5401
10b2
000a
10b3
7e12
10b4
0800
10b5
0001
10b6
7f81
10b7
10da
10b8
7e12
10b9
0400
10ba
0001
10bb
7f81
10bc
10bf
10bd
7f81
10be
0eff
10bf
2001
10c0
4021
10c1
0001
10c2
8461
10c3
8e32
10c4
0001
10c5
7c61
10c6
0618
10c7
a632
10c8
0001
10c9
7c61
10ca
0634
10cb
8a32
10cc
0001
10cd
7c61
10ce
062a
10cf
8472
10d0
7f81
10d1
0eff
10d2
4001
10d3
0002
10d4
2001
10d5
2021
10d6
8802
10d7
7c20
10d8
2168
10d9
0b81
10da
2001
10db
2021
10dc
8802
10dd
7c61
10de
0524
10df
7c20
10e0
2168
10e1
0b81
10e2
7c20
10e3
1542
10e4
5401
10e5
000a
10e6
2001
10e7
4001
10e8
0001
10e9
6381
10ea
7c20
10eb
10e2
10ec
84d3
10ed
7c20
10ee
00c6
10ef
9b01
10f0
8b01
10f1
7c20
10f2
21d3
10f3
0ea1
10f4
ffff
10f5
0f01
10f6
7f01
10f7
03d2
10f8
0301
10f9
7c20
10fa
2f54
10fb
5461
10fc
ffff
10fd
7f81
10fe
2026
10ff
7c20
1100
10e2
1101
88d3
1102
7c20
1103
00c6
1104
0301
1105
5701
1106
ffff
1107
7c20
1108
27d8
1109
0061
110a
7f81
110b
2026
110c
7c20
110d
10e2
110e
8cd3
110f
7c20
1110
00c6
1111
5701
1112
ffff
1113
7c20
1114
22bc
1115
0301
1116
0f01
1117
5701
1118
fffe
1119
7c20
111a
27b5
111b
0061
111c
7f81
111d
2026
111e
7c20
111f
1542
1120
88d3
1121
7c20
1122
00c6
1123
5701
1124
ffff
1125
7c20
1126
22a2
1127
7f81
1128
2026
1129
7c20
112a
1542
112b
88d4
112c
7c20
112d
00c6
112e
5701
112f
ffff
1130
7c20
1131
211a
1132
0ea1
1133
ffff
1134
2c01
1135
8903
1136
ac41
1137
7c20
1138
2ef4
1139
5461
113a
ffff
113b
7f81
113c
2026
113d
7c20
113e
1542
113f
84d2
1140
7c20
1141
00c6
1142
88d4
1143
7f81
1144
114b
1145
56a1
1146
ffff
1147
fffe
1148
7ea1
1149
02a3
114a
ffff
114b
8cd4
114c
7f81
114d
1151
114e
7ea1
114f
02a7
1150
fffd
1151
90d4
1152
7c20
1153
00c6
1154
5701
1155
ffff
1156
572b
1157
fffe
1158
572b
1159
fffd
115a
63f1
115b
ffcf
115c
7c20
115d
00c6
115e
5701
115f
fffd
1160
7c20
1161
24df
1162
0c81
1163
808c
1164
8882
1165
d701
1166
8f01
1167
7c20
1168
21d3
1169
0ea1
116a
fffc
116b
5701
116c
ffff
116d
5701
116e
fffe
116f
7c20
1170
1dc0
1171
1073
1172
7f81
1173
1184
1174
5701
1175
fffc
1176
5701
1177
ffff
1178
7c20
1179
27d8
117a
5701
117b
ffff
117c
5701
117d
fffd
117e
7c20
117f
254d
1180
0ea1
1181
ffff
1182
7f81
1183
116b
1184
5461
1185
fffc
1186
7f81
1187
2026
1188
7c20
1189
1542
118a
84d3
118b
7c20
118c
00c6
118d
7c20
118e
2237
118f
7c20
1190
2214
1191
7801
1192
0255
1193
7803
1194
0254
1195
0301
1196
7c20
1197
22a2
1198
7f81
1199
2026
119a
7c20
119b
00c6
119c
7c20
119d
1542
119e
84d3
119f
7c20
11a0
00c6
11a1
7861
11a2
0236
11a3
7f81
11a4
2026
11a5
7c20
11a6
1542
11a7
84d3
11a8
7c20
11a9
00c6
11aa
7861
11ab
0235
11ac
7f81
11ad
2026
11ae
7c20
11af
1542
11b0
8cd3
11b1
7c20
11b2
00c6
11b3
5701
11b4
ffff
11b5
5701
11b6
fffe
11b7
7c20
11b8
1dc0
11b9
0c01
11ba
7c61
11bb
02a3
11bc
8012
11bd
7c61
11be
029f
11bf
8812
11c0
7c61
11c1
02a7
11c2
7f81
11c3
2026
11c4
7c20
11c5
1542
11c6
88d3
11c7
7c20
11c8
00c6
11c9
5401
11ca
ffff
11cb
7e11
11cc
0030
11cd
0001
11ce
7c20
11cf
00c6
11d0
2001
11d1
2002
11d2
8b01
11d3
a701
11d4
7c20
11d5
2770
11d6
2cde
11d7
21c1
11d8
7f81
11d9
2026
11da
7c20
11db
1542
11dc
88d3
11dd
7c20
11de
00c6
11df
5401
11e0
ffff
11e1
a613
11e2
0001
11e3
7c20
11e4
00c6
11e5
2001
11e6
8913
11e7
7c20
11e8
00c6
11e9
4301
11ea
0001
11eb
7c20
11ec
22a2
11ed
7f81
11ee
2026
11ef
7c20
11f0
1542
11f1
88d4
11f2
7c20
11f3
00c6
11f4
5401
11f5
ffff
11f6
84d2
11f7
7c01
11f8
03fd
11f9
a613
11fa
0001
11fb
7c20
11fc
00c6
11fd
0301
11fe
7c20
11ff
2be1
1200
7f81
1201
2026
1202
7c20
1203
1542
1204
84d4
1205
7f81
1206
120d
1207
7801
1208
030d
1209
7821
120a
0313
120b
7f81
120c
122e
120d
88d4
120e
7f81
120f
1220
1210
5421
1211
ffff
1212
4441
1213
0001
1214
7c51
1215
0070
1216
7c20
1217
00c6
1218
7c01
1219
02a3
121a
7c52
121b
0040
121c
7801
121d
030d
121e
7f81
121f
122e
1220
5401
1221
ffff
1222
5421
1223
fffe
1224
7e11
1225
0070
1226
0001
1227
7c20
1228
00c6
1229
7e31
122a
0070
122b
0001
122c
7c20
122d
00c6
122e
7c20
122f
2007
1230
7c81
1231
23b8
1232
7e12
1233
0040
1234
0001
1235
7c81
1236
180b
1237
0301
1238
0701
1239
1020
123a
7f81
123b
2026
123c
7c20
123d
1542
123e
88d3
123f
7c20
1240
00c6
1241
5401
1242
ffff
1243
8481
1244
7e10
1245
0030
1246
0001
1247
7c81
1248
24ab
1249
7e10
124a
0040
124b
0001
124c
7c81
124d
158d
124e
8492
124f
7c20
1250
00c6
1251
0301
1252
1020
1253
7f81
1254
2026
1255
7c20
1256
1542
1257
88d3
1258
7c20
1259
00c6
125a
5401
125b
ffff
125c
7e11
125d
080f
125e
0001
125f
7c20
1260
00c6
1261
2001
1262
2301
1263
7c20
1264
22a2
1265
7f81
1266
2026
1267
7c20
1268
1542
1269
88d3
126a
7c20
126b
00c6
126c
5461
126d
ffff
126e
4f01
126f
0001
1270
7c20
1271
22a2
1272
7f81
1273
2026
1274
7c20
1275
1542
1276
84d3
1277
7c20
1278
00c6
1279
7c20
127a
3058
127b
7f81
127c
2026
127d
7c20
127e
1542
127f
84d3
1280
7c20
1281
00c6
1282
7c20
1283
3028
1284
7c61
1285
029d
1286
7f81
1287
2026
1288
7c20
1289
1542
128a
88d3
128b
7c20
128c
00c6
128d
5401
128e
ffff
128f
a611
1290
0001
1291
7c20
1292
00c6
1293
0301
1294
7c20
1295
3094
1296
7f81
1297
2026
1298
7c20
1299
1542
129a
8cd3
129b
7c20
129c
00c6
129d
5401
129e
ffff
129f
a611
12a0
0001
12a1
7c20
12a2
00c6
12a3
0301
12a4
5701
12a5
fffe
12a6
7c20
12a7
3061
12a8
7c61
12a9
029d
12aa
7f81
12ab
2026
12ac
7c20
12ad
1542
12ae
88d3
12af
7c20
12b0
00c6
12b1
5401
12b2
ffff
12b3
a611
12b4
0001
12b5
7c20
12b6
00c6
12b7
0301
12b8
7c20
12b9
30b1
12ba
7f81
12bb
2026
12bc
7c20
12bd
1542
12be
88d3
12bf
7c20
12c0
00c6
12c1
5401
12c2
ffff
12c3
7e12
12c4
0020
12c5
0001
12c6
7f81
12c7
12d7
12c8
c612
12c9
0001
12ca
7f81
12cb
12da
12cc
a612
12cd
0001
12ce
7f81
12cf
12e4
12d0
7e12
12d1
0040
12d2
0001
12d3
7f81
12d4
12e9
12d5
7c20
12d6
00c6
12d7
0061
12d8
7f81
12d9
2026
12da
7c12
12db
02e7
12dc
7c61
12dd
02a3
12de
7c12
12df
02e9
12e0
7c61
12e1
02a7
12e2
7f81
12e3
2026
12e4
0301
12e5
7c20
12e6
22c3
12e7
7f81
12e8
2026
12e9
0301
12ea
7c20
12eb
179f
12ec
7f81
12ed
2026
12ee
7c20
12ef
1542
12f0
88d3
12f1
7c20
12f2
00c6
12f3
5401
12f4
ffff
12f5
7e12
12f6
0020
12f7
0001
12f8
7f81
12f9
1309
12fa
c612
12fb
0001
12fc
7f81
12fd
130e
12fe
a612
12ff
0001
1300
7f81
1301
1318
1302
7e12
1303
0040
1304
0001
1305
7f81
1306
131d
1307
7c20
1308
00c6
1309
0301
130a
7c20
130b
1757
130c
7f81
130d
2026
130e
7c12
130f
02e7
1310
7861
1311
030d
1312
7c12
1313
02e9
1314
7861
1315
0313
1316
7f81
1317
2026
1318
0301
1319
7c20
131a
1887
131b
7f81
131c
2026
131d
0061
131e
7f81
131f
2026
1320
7c20
1321
1542
1322
88d3
1323
7c20
1324
00c6
1325
5701
1326
ffff
1327
7c20
1328
2086
1329
0ea1
132a
ffff
132b
7f81
132c
2026
132d
7c20
132e
1542
132f
88d3
1330
7c20
1331
00c6
1332
5461
1333
ffff
1334
7e73
1335
0020
1336
0001
1337
7c20
1338
00c6
1339
0f01
133a
7c20
133b
2369
133c
7f81
133d
2026
133e
7c20
133f
1542
1340
88d3
1341
7c20
1342
00c6
1343
5461
1344
ffff
1345
a672
1346
0001
1347
7f81
1348
2026
1349
0f01
134a
7c20
134b
2086
134c
7f81
134d
2026
134e
7c20
134f
1542
1350
88d3
1351
7c20
1352
00c6
1353
5701
1354
ffff
1355
7c20
1356
1ea9
1357
7f81
1358
2026
1359
7c20
135a
1542
135b
84d3
135c
7c20
135d
00c6
135e
8801
135f
7a40
1360
024f
1361
8452
1362
7f81
1363
135e
1364
8b01
1365
a701
1366
7c20
1367
2770
1368
2cde
1369
09c1
136a
7f81
136b
2026
136c
7c20
136d
1542
136e
88d2
136f
7f81
1370
1381
1371
84d3
1372
7c20
1373
00c6
1374
8801
1375
7a40
1376
024f
1377
7c61
1378
02a3
1379
8452
137a
7f81
137b
2026
137c
0b01
137d
7c20
137e
22a2
137f
7f81
1380
2026
1381
5401
1382
ffff
1383
7e10
1384
0030
1385
0001
1386
7f81
1387
1394
1388
a613
1389
0001
138a
7c20
138b
00c6
138c
2001
138d
8913
138e
7c20
138f
00c6
1390
4021
1391
0001
1392
7f81
1393
1398
1394
0301
1395
7c20
1396
22bc
1397
0c21
1398
8c01
1399
7a40
139a
024f
139b
7c61
139c
02e9
139d
8452
139e
7c61
139f
02e7
13a0
7f81
13a1
2026
13a2
7c20
13a3
1542
13a4
88d4
13a5
7c20
13a6
13af
13a7
5701
13a8
ffff
13a9
7f01
13aa
02e7
13ab
7c20
13ac
1ee1
13ad
7f81
13ae
2026
13af
8cd4
13b0
7c20
13b1
00c6
13b2
5701
13b3
ffff
13b4
5701
13b5
fffe
13b6
7c20
13b7
1ee1
13b8
7f81
13b9
2026
13ba
7c20
13bb
1542
13bc
84d2
13bd
7f81
13be
13ca
13bf
8cd3
13c0
7c20
13c1
00c6
13c2
7c20
13c3
13ce
13c4
0f01
13c5
7c20
13c6
13e0
13c7
0f01
13c8
7c20
13c9
2e28
13ca
7c20
13cb
2ebe
13cc
7f81
13cd
2026
13ce
5461
13cf
ffff
13d0
7e71
13d1
0030
13d2
0001
13d3
7c20
13d4
00c6
13d5
0f01
13d6
7c20
13d7
22bc
13d8
7c70
13d9
8000
13da
8461
13db
7c74
13dc
001f
13dd
7c61
13de
001f
13df
6381
13e0
5461
13e1
fffe
13e2
7e71
13e3
0030
13e4
0001
13e5
7c20
13e6
00c6
13e7
0f01
13e8
7c20
13e9
22bc
13ea
7c70
13eb
8000
13ec
8461
13ed
b074
13ee
b061
13ef
6381
13f0
7c20
13f1
1542
13f2
8cd3
13f3
7c20
13f4
00c6
13f5
7c20
13f6
13ce
13f7
0f01
13f8
7c20
13f9
13e0
13fa
0f01
13fb
7c20
13fc
2e97
13fd
0c41
13fe
8b01
13ff
a701
1400
7c20
1401
2770
1402
2cde
1403
09c1
1404
7f81
1405
2026
1406
7c20
1407
1542
1408
90d3
1409
7c20
140a
00c6
140b
7c20
140c
13ce
140d
0f01
140e
7c20
140f
13e0
1410
0f01
1411
5461
1412
fffd
1413
2c61
1414
4f01
1415
0001
1416
7c20
1417
2ea9
1418
7c61
1419
029d
141a
7f81
141b
2026
141c
7c20
141d
1542
141e
7c61
141f
d980
1420
84d2
1421
7f81
1422
1430
1423
88d3
1424
7c20
1425
00c6
1426
5461
1427
ffff
1428
7e73
1429
0020
142a
0001
142b
7c20
142c
00c6
142d
0f01
142e
7c20
142f
22bc
1430
1701
1431
0f01
1432
7c20
1433
1562
1434
6020
1435
7c20
1436
156d
1437
60a1
1438
7c61
1439
029d
143a
7f81
143b
2026
143c
7c20
143d
1542
143e
5461
143f
ffff
1440
7e73
1441
0020
1442
0001
1443
7c20
1444
00c6
1445
0f01
1446
7c20
1447
22bc
1448
8cd2
1449
7f81
144a
1453
144b
88d3
144c
7c20
144d
00c6
144e
2f01
144f
7c20
1450
22a2
1451
7f81
1452
2026
1453
0cc1
1454
5461
1455
fffe
1456
7e73
1457
0020
1458
0001
1459
7c20
145a
00c6
145b
0f01
145c
7c20
145d
22bc
145e
0cc2
145f
88c3
1460
0f01
1461
a701
1462
7c20
1463
2770
1464
2ce1
1465
3ce2
1466
2cf2
1467
7f81
1468
2026
1469
39ff
146a
7f81
146b
1466
146c
7c20
146d
1542
146e
8cd3
146f
7c20
1470
00c6
1471
5461
1472
ffff
1473
7e73
1474
0020
1475
0001
1476
7c20
1477
00c6
1478
0f01
1479
7c20
147a
22bc
147b
0ce1
147c
5461
147d
fffe
147e
a672
147f
0001
1480
7f81
1481
148f
1482
7e73
1483
0020
1484
0001
1485
7c20
1486
00c6
1487
0f01
1488
7c20
1489
22bc
148a
0de1
148b
5461
148c
fffe
148d
7f81
148e
2026
148f
2cc1
1490
38e2
1491
88e3
1492
38c2
1493
2cd2
1494
7f81
1495
2026
1496
39ff
1497
7f81
1498
1493
1499
8421
149a
7f81
149b
149d
149c
8821
149d
7c20
149e
1542
149f
88d3
14a0
7c20
14a1
00c6
14a2
5461
14a3
ffff
14a4
7e73
14a5
0020
14a6
0001
14a7
7c20
14a8
00c6
14a9
0f01
14aa
7c20
14ab
22bc
14ac
0f01
14ad
8432
14ae
7c20
14af
312c
14b0
8832
14b1
7c20
14b2
311d
14b3
7f81
14b4
2026
14b5
7c20
14b6
1542
14b7
84d3
14b8
7c20
14b9
00c6
14ba
0e00
14bb
0f01
14bc
7c20
14bd
22a2
14be
7f81
14bf
2026
14c0
7c20
14c1
1542
14c2
88d3
14c3
7c20
14c4
00c6
14c5
5461
14c6
ffff
14c7
7e73
14c8
0020
14c9
0001
14ca
7c20
14cb
00c6
14cc
0f01
14cd
7c20
14ce
22bc
14cf
0f01
14d0
7c20
14d1
1562
14d2
6240
14d3
7c20
14d4
156d
14d5
7f81
14d6
2026
14d7
7c20
14d8
1542
14d9
88d3
14da
7c20
14db
00c6
14dc
5461
14dd
ffff
14de
7e73
14df
0020
14e0
0001
14e1
7c20
14e2
00c6
14e3
5701
14e4
ffff
14e5
7c20
14e6
22bc
14e7
0e20
14e8
0f01
14e9
1301
14ea
0b01
14eb
0301
14ec
0701
14ed
9301
14ee
9701
14ef
7c20
14f0
2770
14f1
0ea1
14f2
ffff
14f3
0c01
14f4
7c20
14f5
22a2
14f6
0ea1
14f7
fffe
14f8
0f01
14f9
7f01
14fa
02e3
14fb
7c20
14fc
243e
14fd
2c01
14fe
6201
14ff
0002
1500
5401
1501
ffff
1502
2001
1503
0e01
1504
0001
1505
7c20
1506
22a2
1507
5401
1508
ffff
1509
2001
150a
0e01
150b
0002
150c
7c20
150d
22a2
150e
0ea1
150f
fffe
1510
0f01
1511
7f01
1512
02e3
1513
7c20
1514
243e
1515
2c01
1516
6201
1517
0002
1518
5401
1519
ffff
151a
2001
151b
0e01
151c
0003
151d
5461
151e
ffff
151f
7f81
1520
2026
1521
7c20
1522
1542
1523
8cd3
1524
7c20
1525
00c6
1526
5461
1527
ffff
1528
7e71
1529
0030
152a
0001
152b
7c20
152c
00c6
152d
0f01
152e
7c20
152f
22bc
1530
0f01
1531
5461
1532
fffe
1533
7e71
1534
0030
1535
0001
1536
7c20
1537
00c6
1538
0f01
1539
7c20
153a
22bc
153b
0f01
153c
7c20
153d
2e38
153e
7c61
153f
029d
1540
7f81
1541
2026
1542
84c1
1543
7c20
1544
1ba6
1545
90d2
1546
7f81
1547
155d
1548
7fd2
1549
0514
154a
025c
154b
7f81
154c
155d
154d
7f01
154e
0030
154f
7c20
1550
0ab4
1551
141e
1552
1803
1553
0d01
1554
0f01
1555
7c20
1556
1dfc
1557
0d01
1558
7fd2
1559
04a8
155a
025c
155b
7f81
155c
1543
155d
7f01
155e
0514
155f
7c20
1560
1b9d
1561
6381
1562
7801
1563
db7b
1564
7821
1565
db7c
1566
7841
1567
db7d
1568
7861
1569
db7e
156a
7881
156b
db7f
156c
6381
156d
03c1
156e
db7b
156f
07c1
1570
db7c
1571
0bc1
1572
db7d
1573
0fc1
1574
db7e
1575
13c1
1576
db7f
1577
6381
#include "parser.dasm16"
admiral.dasm16
4
1469
1578
8b01
1579
8701
157a
7c20
157b
2039
157c
9701
157d
7f01
157e
0040
157f
7c20
1580
21d3
1581
54c1
1582
000a
1583
38c1
1584
2c01
1585
00e1
1586
39fe
1587
39fe
1588
39fe
1589
39fe
158a
8105
158b
7f81
158c
2026
158d
8b01
158e
8701
158f
7c20
1590
2039
1591
5461
1592
000a
1593
2c81
1594
8597
1595
7f81
1596
2026
1597
7f81
1598
157c
1599
8f01
159a
8b01
159b
7c20
159c
2039
159d
5701
159e
000a
159f
7c20
15a0
1757
15a1
0ea1
15a2
ffff
15a3
5701
15a4
000b
15a5
5701
15a6
ffff
15a7
7c20
15a8
15bd
15a9
7f81
15aa
2026
15ab
8f01
15ac
8b01
15ad
7c20
15ae
2039
15af
5701
15b0
000b
15b1
7c20
15b2
1757
15b3
0ea1
15b4
ffff
15b5
5701
15b6
ffff
15b7
5701
15b8
000a
15b9
7c20
15ba
15bd
15bb
7f81
15bc
2026
15bd
1b01
15be
1f01
15bf
68c1
15c0
0004
15c1
38c1
15c2
68e1
15c3
0003
15c4
3ce1
15c5
8461
15c6
3dd7
15c7
8861
15c8
3dd5
15c9
8061
15ca
8473
15cb
7f81
15cc
15d6
15cd
7dd3
15ce
fffe
15cf
8dd3
15d0
7f81
15d1
15d6
15d2
7c20
15d3
1a70
15d4
85d5
15d5
8065
15d6
60e1
15d7
60c1
15d8
6321
15d9
6321
15da
6381
15db
8f01
15dc
8b01
15dd
7c20
15de
2039
15df
9701
15e0
7f01
15e1
0040
15e2
7c20
15e3
21d3
15e4
0ea1
15e5
ffff
15e6
54c1
15e7
000b
15e8
38c1
15e9
54e1
15ea
000a
15eb
3ce1
15ec
7c01
15ed
1a9f
15ee
7f81
15ef
1a8a
15f0
7c20
15f1
1a70
15f2
8073
15f3
7f81
15f4
15f8
15f5
1ccc
15f6
18ec
15f7
1ccc
15f8
5461
15f9
ffff
15fa
5841
15fb
0001
15fc
5c43
15fd
0001
15fe
7c54
15ff
001f
1600
7f81
1601
1b27
1602
5c21
1603
0003
1604
082d
1605
5c01
1606
0002
1607
080d
1608
2c41
1609
3941
160a
5a41
160b
0001
160c
0001
160d
5a41
160e
0002
160f
0002
1610
5a41
1611
0003
1612
0003
1613
3dd2
1614
7f81
1615
162f
1616
0643
1617
0003
1618
025b
1619
0002
161a
8652
161b
0003
161c
8652
161d
0002
161e
7f81
161f
1b1f
1620
7c20
1621
1a43
1622
024f
1623
0002
1624
024f
1625
0003
1626
764b
1627
0002
1628
0243
1629
0001
162a
87b2
162b
7f81
162c
2026
162d
7f81
162e
1b1b
162f
065a
1630
0003
1631
025a
1632
0002
1633
8652
1634
0003
1635
8652
1636
0002
1637
87b2
1638
7f81
1639
1b1f
163a
87b2
163b
7f81
163c
2026
163d
8a4d
163e
0003
163f
8a4d
1640
0002
1641
764b
1642
0003
1643
7e4b
1644
8000
1645
0002
1646
8a42
1647
0001
1648
87b2
1649
7f81
164a
2026
164b
7f81
164c
1b0f
164d
8f01
164e
8b01
164f
7c20
1650
2039
1651
5701
1652
000a
1653
7c20
1654
1578
1655
0ea1
1656
ffff
1657
5701
1658
000b
1659
5701
165a
ffff
165b
7c20
165c
15db
165d
7f81
165e
2026
165f
8f01
1660
8b01
1661
7c20
1662
2039
1663
54c1
1664
000b
1665
38c1
1666
54e1
1667
000a
1668
3ce1
1669
9f63
166a
7c01
166b
1ac3
166c
7f81
166d
1a8a
166e
8f21
166f
7f81
1670
1673
1671
7f21
1672
fffe
1673
5801
1674
0001
1675
7c03
1676
8000
1677
5c21
1678
0001
1679
7c23
167a
8000
167b
0041
167c
0442
167d
080c
167e
082c
167f
040a
1680
7c21
1681
1b0f
1682
7ed6
1683
8000
1684
0001
1685
7c21
1686
1b1b
1687
7c10
1688
8000
1689
0781
168a
7c42
168b
8001
168c
0b41
168d
0001
168e
5f41
168f
0003
1690
0005
1691
5b44
1692
0003
1693
0005
1694
7741
1695
0004
1696
5801
1697
0002
1698
5c04
1699
0003
169a
7741
169b
0003
169c
0342
169d
0004
169e
7742
169f
0003
16a0
5801
16a1
0003
16a2
5c04
16a3
0002
16a4
7742
16a5
0003
16a6
7741
16a7
0002
16a8
0342
16a9
0004
16aa
7742
16ab
0003
16ac
7742
16ad
0002
16ae
5801
16af
0002
16b0
5c04
16b1
0002
16b2
7742
16b3
0002
16b4
0342
16b5
0003
16b6
7742
16b7
0002
16b8
7f50
16b9
8000
16ba
0002
16bb
7f81
16bc
16ca
16bd
8b4f
16be
0002
16bf
8b4f
16c0
0003
16c1
774b
16c2
0002
16c3
7f50
16c4
8000
16c5
0004
16c6
8b4b
16c7
0003
16c8
8b43
16c9
0001
16ca
9701
16cb
7f01
16cc
0040
16cd
7c20
16ce
21d3
16cf
6cc1
16d0
7f81
16d1
1b27
16d2
8f01
16d3
9301
16d4
7c20
16d5
2039
16d6
54c1
16d7
000b
16d8
38c1
16d9
54e1
16da
000a
16db
3ce1
16dc
1b01
16dd
7c20
16de
19a1
16df
1f01
16e0
7c20
16e1
19a1
16e2
5b01
16e3
0003
16e4
5b01
16e5
0002
16e6
9763
16e7
7c01
16e8
1ae7
16e9
7f81
16ea
1a8a
16eb
8f21
16ec
7f81
16ed
16f0
16ee
7f21
16ef
fffe
16f0
5801
16f1
0001
16f2
7c03
16f3
8000
16f4
5c21
16f5
0001
16f6
7c23
16f7
8000
16f8
0041
16f9
0443
16fa
080c
16fb
082c
16fc
040a
16fd
7c21
16fe
1b0f
16ff
7ed6
1700
8000
1701
0001
1702
7c21
1703
1b1b
1704
7c10
1705
8000
1706
0781
1707
7c42
1708
8000
1709
0b41
170a
0001
170b
8801
170c
8441
170d
8821
170e
5f52
170f
0002
1710
0004
1711
5f56
1712
0003
1713
0005
1714
8421
1715
5f56
1716
0002
1717
0004
1718
8421
1719
880f
171a
040b
171b
77f2
171c
0000
171d
7f81
171e
1726
171f
8453
1720
7f81
1721
173b
1722
8841
1723
0341
1724
0002
1725
8801
1726
8432
1727
7f81
1728
172f
1729
5f43
172a
0003
172b
0005
172c
5f5b
172d
0002
172e
0004
172f
8b4f
1730
0004
1731
7421
1732
8b4f
1733
0005
1734
774b
1735
0004
1736
8832
1737
7f81
1738
1719
1739
7f81
173a
170d
173b
0341
173c
0003
173d
6c41
173e
7c20
173f
1a43
1740
024f
1741
0002
1742
024f
1743
0003
1744
764b
1745
0002
1746
0243
1747
0001
1748
6c61
1749
87b3
174a
7f81
174b
1b1b
174c
9701
174d
7f01
174e
0040
174f
7c20
1750
21d3
1751
6cc1
1752
1b01
1753
7c20
1754
19a1
1755
7f81
1756
1b27
1757
8b01
1758
8f01
1759
7c20
175a
2039
175b
5401
175c
000a
175d
2001
175e
8912
175f
8612
1760
0001
1761
7f81
1762
1b1f
1763
5701
1764
000a
1765
7c20
1766
24ab
1767
0ea1
1768
fffe
1769
0cc1
176a
9701
176b
7f01
176c
0040
176d
7c20
176e
21d3
176f
0ea1
1770
ffff
1771
0ce1
1772
38c1
1773
3ce1
1774
7de1
1775
fffe
1776
56b3
1777
fffe
1778
000a
1779
8de1
177a
3841
177b
944f
177c
7c42
177d
7fff
177e
5821
177f
0001
1780
7c20
1781
1a4e
1782
0043
1783
0ae1
1784
0001
1785
5ae1
1786
0001
1787
0002
1788
02ef
1789
0002
178a
86e1
178b
0003
178c
89d4
178d
5ae1
178e
0002
178f
0003
1790
02ef
1791
0003
1792
76eb
1793
0002
1794
8421
1795
8dd4
1796
5821
1797
0003
1798
002f
1799
76eb
179a
0003
179b
5461
179c
ffff
179d
7f81
179e
2026
179f
8b01
17a0
8b01
17a1
7c20
17a2
2039
17a3
5481
17a4
000a
17a5
3081
17a6
7d92
17a7
8000
17a8
7c20
17a9
00c6
17aa
7d92
17ab
fffd
17ac
7c20
17ad
00c6
17ae
9192
17af
7c20
17b0
00c6
17b1
7c61
17b2
02a3
17b3
8192
17b4
7f81
17b5
2026
17b6
8992
17b7
7f81
17b8
2026
17b9
5001
17ba
0001
17bb
03f4
17bc
8000
17bd
7f81
17be
2026
17bf
7c03
17c0
8000
17c1
940d
17c2
8802
17c3
0301
17c4
7f01
17c5
0020
17c6
7c20
17c7
2770
17c8
0ea1
17c9
ffff
17ca
54c1
17cb
000a
17cc
38c1
17cd
2ce1
17ce
0021
17cf
942f
17d0
7c22
17d1
7fff
17d2
5823
17d3
0001
17d4
5ae1
17d5
0002
17d6
0001
17d7
06ed
17d8
0001
17d9
89f2
17da
7f81
17db
17e4
17dc
7481
17dd
5ae1
17de
0003
17df
0002
17e0
06ed
17e1
0002
17e2
12eb
17e3
0002
17e4
85d7
17e5
7f81
17e6
2026
17e7
0f01
17e8
7c20
17e9
24c3
17ea
7f81
17eb
2026
17ec
8b01
17ed
8b01
17ee
7c20
17ef
2039
17f0
5701
17f1
000a
17f2
7c20
17f3
179f
17f4
0ea1
17f5
ffff
17f6
0f01
17f7
7c20
17f8
22bc
17f9
7f81
17fa
2026
17fb
8b01
17fc
8b01
17fd
7c20
17fe
2039
17ff
5701
1800
000a
1801
7c20
1802
22a2
1803
0ea1
1804
ffff
1805
5701
1806
ffff
1807
7c20
1808
1757
1809
7f81
180a
2026
180b
8f01
180c
8f01
180d
7c20
180e
2039
180f
9701
1810
7f01
1811
0040
1812
7c20
1813
21d3
1814
0ea1
1815
ffff
1816
2cc1
1817
7dc1
1818
fffe
1819
7ec1
181a
8000
181b
0001
181c
7c20
181d
23ed
181e
7c6b
181f
8000
1820
0ec1
1821
0002
1822
7c20
1823
23ed
1824
0ec1
1825
0003
1826
5701
1827
ffff
1828
7f01
1829
0313
182a
7c20
182b
164d
182c
0ea1
182d
ffff
182e
5701
182f
000a
1830
5701
1831
000b
1832
7c20
1833
164d
1834
0ea1
1835
fffe
1836
5701
1837
ffff
1838
5701
1839
fffe
183a
7c20
183b
165f
183c
0ea1
183d
ffff
183e
5701
183f
ffff
1840
5701
1841
000b
1842
7c20
1843
15db
1844
7f81
1845
2026
1846
8f01
1847
8f01
1848
7c20
1849
2039
184a
8801
184b
5701
184c
000a
184d
7c20
184e
22bc
184f
0c41
1850
7c61
1851
0313
1852
8452
1853
7f81
1854
2026
1855
7c51
1856
8000
1857
7f81
1858
185c
1859
804c
185a
8842
185b
8401
185c
56a1
185d
000b
185e
ffff
185f
7ea1
1860
0313
1861
fffe
1862
8452
1863
7f81
1864
187b
1865
8851
1866
7f81
1867
1870
1868
5701
1869
fffe
186a
5701
186b
ffff
186c
7c20
186d
165f
186e
0ea1
186f
fffe
1870
5701
1871
ffff
1872
5701
1873
ffff
1874
7c20
1875
165f
1876
0ea1
1877
ffff
1878
884d
1879
7f81
187a
1862
187b
5461
187c
fffe
187d
8812
187e
7f81
187f
2026
1880
7f01
1881
0313
1882
0f01
1883
7c20
1884
16d2
1885
7f81
1886
2026
1887
8b01
1888
8b01
1889
7c20
188a
2039
188b
5401
188c
000a
188d
2021
188e
2441
188f
8c54
1890
7e32
1891
0069
1892
0001
1893
7e32
1894
006e
1895
0002
1896
7e32
1897
0066
1898
0003
1899
7f81
189a
1b13
189b
8c54
189c
7e32
189d
006e
189e
0001
189f
7e32
18a0
0061
18a1
0002
18a2
7e32
18a3
006e
18a4
0003
18a5
7f81
18a6
1b0b
18a7
9054
18a8
7e32
18a9
002d
18aa
0001
18ab
7e32
18ac
0069
18ad
0002
18ae
7e32
18af
006e
18b0
0003
18b1
7e32
18b2
0066
18b3
0004
18b4
7f81
18b5
1b17
18b6
9054
18b7
7e32
18b8
002b
18b9
0001
18ba
7e32
18bb
0069
18bc
0002
18bd
7e32
18be
006e
18bf
0003
18c0
7e32
18c1
0066
18c2
0004
18c3
7f81
18c4
1b13
18c5
7ea1
18c6
030d
18c7
ffff
18c8
8701
18c9
8701
18ca
8701
18cb
8b01
18cc
8421
18cd
7c20
18ce
277f
18cf
8822
18d0
0c41
18d1
7c52
18d2
002b
18d3
7f81
18d4
194b
18d5
7c52
18d6
002d
18d7
7f81
18d8
192f
18d9
7c52
18da
0065
18db
7f81
18dc
195f
18dd
7c52
18de
0045
18df
7f81
18e0
195f
18e1
7c52
18e2
002e
18e3
7f81
18e4
1957
18e5
7c54
18e6
0039
18e7
7f81
18e8
1968
18e9
7c56
18ea
0030
18eb
7f81
18ec
1968
18ed
7c43
18ee
0030
18ef
7eb0
18f0
0060
18f1
fffb
18f2
7f81
18f3
1918
18f4
e6b0
18f5
fffb
18f6
7f81
18f7
18fe
18f8
a2b0
18f9
fffb
18fa
7f81
18fb
1904
18fc
7f81
18fd
1968
18fe
c6a1
18ff
fffb
1900
8aa3
1901
fffc
1902
7f81
1903
1906
1904
96a1
1905
fffb
1906
5701
1907
ffff
1908
7f01
1909
0349
190a
7c20
190b
165f
190c
0ea1
190d
ffff
190e
5701
190f
ffff
1910
4b01
1911
0303
1912
7c20
1913
15db
1914
0ea1
1915
ffff
1916
7f81
1917
18cd
1918
7ea1
1919
0080
191a
fffb
191b
aea4
191c
fffd
191d
87b3
191e
7f81
191f
1927
1920
0aa2
1921
fffd
1922
87b3
1923
7f81
1924
1927
1925
7f81
1926
18cd
1927
5461
1928
ffff
1929
8ab2
192a
fffe
192b
7f81
192c
1b1b
192d
7f81
192e
1b0f
192f
8ab0
1930
fffb
1931
7f81
1932
193a
1933
7eb0
1934
0020
1935
fffb
1936
7f81
1937
1944
1938
7f81
1939
1968
193a
8ea1
193b
fffb
193c
5701
193d
ffff
193e
7c20
193f
1578
1940
0ea1
1941
ffff
1942
7f81
1943
18cd
1944
7ea1
1945
0040
1946
fffb
1947
8aa1
1948
fffe
1949
7f81
194a
18cd
194b
8ab0
194c
fffb
194d
8ea1
194e
fffb
194f
7eb0
1950
0020
1951
fffb
1952
7ea1
1953
0040
1954
fffb
1955
7f81
1956
1968
1957
a2b1
1958
fffb
1959
7f81
195a
1968
195b
a6a1
195c
fffb
195d
7f81
195e
18cd
195f
e2b1
1960
fffb
1961
7f81
1962
1968
1963
7ea1
1964
0020
1965
fffb
1966
7f81
1967
18cd
1968
7eb0
1969
0063
196a
fffb
196b
7c20
196c
00c6
196d
87a1
196e
86b2
196f
fffe
1970
7ea2
1971
8000
1972
fffd
1973
87b3
1974
7f81
1975
1927
1976
56a2
1977
fffc
1978
fffd
1979
7eb0
197a
8000
197b
fffc
197c
87b2
197d
7f81
197e
1927
197f
7eb1
1980
8000
1981
fffc
1982
87b3
1983
7f81
1984
1927
1985
5461
1986
ffff
1987
7c01
1988
165f
1989
8021
198a
7eb4
198b
8000
198c
fffd
198d
7f81
198e
1992
198f
7c01
1990
16d2
1991
8821
1992
7eb2
1993
8000
1994
fffd
1995
7f81
1996
2026
1997
0f01
1998
7f01
1999
0349
199a
0020
199b
0ea1
199c
ffff
199d
06a2
199e
fffd
199f
7f81
19a0
1992
19a1
0f01
19a2
6861
19a3
0002
19a4
2f01
19a5
7c20
19a6
0215
19a7
4f01
19a8
0001
19a9
7c20
19aa
0215
19ab
4f01
19ac
0002
19ad
7c20
19ae
0215
19af
4f01
19b0
0003
19b1
7c20
19b2
0215
19b3
6061
19b4
6321
19b5
6381
19b6
8b01
19b7
8f01
19b8
7c20
19b9
2039
19ba
54c1
19bb
000a
19bc
38c1
19bd
8461
19be
7dd2
19bf
8000
19c0
7c61
19c1
0369
19c2
7dd2
19c3
fffd
19c4
7c61
19c5
034f
19c6
91d2
19c7
7c61
19c8
0355
19c9
89d2
19ca
7c61
19cb
0362
19cc
81d2
19cd
7c61
19ce
035c
19cf
8473
19d0
7f81
19d1
2026
19d2
bb01
19d3
a701
19d4
7c20
19d5
21d3
19d6
0ea1
19d7
ffff
19d8
5701
19d9
000a
19da
7c20
19db
158d
19dc
0ea1
19dd
fffe
19de
8801
19df
8421
19e0
56b2
19e1
fffe
19e2
000a
19e3
7f81
19e4
19eb
19e5
5701
19e6
ffff
19e7
7f01
19e8
002d
19e9
7c20
19ea
27d8
19eb
5701
19ec
fffe
19ed
7f01
19ee
0349
19ef
7c20
19f0
15bd
19f1
8072
19f2
7f81
19f3
19ff
19f4
5701
19f5
fffe
19f6
7f01
19f7
0349
19f8
7c20
19f9
16d2
19fa
0ea1
19fb
fffe
19fc
8802
19fd
7f81
19fe
19eb
19ff
5701
1a00
fffe
1a01
7c20
1a02
17ec
1a03
0c41
1a04
7c62
1a05
0030
1a06
5701
1a07
ffff
1a08
0f01
1a09
7c20
1a0a
27d8
1a0b
5701
1a0c
fffe
1a0d
4b01
1a0e
0303
1a0f
7c20
1a10
164d
1a11
0ea1
1a12
fffe
1a13
044b
1a14
8452
1a15
7f81
1a16
1a1b
1a17
8822
1a18
a832
1a19
7f81
1a1a
1a2f
1a1b
5701
1a1c
fffe
1a1d
7f01
1a1e
0349
1a1f
7c20
1a20
165f
1a21
0ea1
1a22
fffe
1a23
8803
1a24
8413
1a25
7f81
1a26
19ff
1a27
5701
1a28
ffff
1a29
7f01
1a2a
002e
1a2b
7c20
1a2c
27d8
1a2d
7f81
1a2e
19ff
1a2f
8803
1a30
8412
1a31
7f81
1a32
1a3f
1a33
7c10
1a34
8000
1a35
7f81
1a36
1a3f
1a37
5701
1a38
ffff
1a39
7f01
1a3a
0030
1a3b
7c20
1a3c
27d8
1a3d
7f81
1a3e
1a2f
1a3f
5461
1a40
ffff
1a41
7f81
1a42
2026
1a43
8401
1a44
4821
1a45
0002
1a46
8433
1a47
7f81
1a48
1a54
1a49
c401
1a4a
4821
1a4b
0003
1a4c
7f81
1a4d
1a54
1a4e
8401
1a4f
8433
1a50
7f81
1a51
1a54
1a52
c401
1a53
6381
1a54
7c30
1a55
ff00
1a56
7f81
1a57
1a5a
1a58
a402
1a59
a42f
1a5a
7c30
1a5b
f000
1a5c
7f81
1a5d
1a60
1a5e
9402
1a5f
942f
1a60
7c30
1a61
c000
1a62
7f81
1a63
1a66
1a64
8c02
1a65
8c2f
1a66
7c30
1a67
8000
1a68
6381
1a69
8802
1a6a
7c30
1a6b
4000
1a6c
6381
1a6d
7c01
1a6e
0020
1a6f
6381
1a70
8461
1a71
5ed4
1a72
0003
1a73
0003
1a74
8861
1a75
5ed6
1a76
0003
1a77
0003
1a78
8061
1a79
5ed4
1a7a
0002
1a7b
0002
1a7c
8861
1a7d
5ed6
1a7e
0002
1a7f
0002
1a80
8061
1a81
5ed4
1a82
0001
1a83
0001
1a84
8861
1a85
5ed6
1a86
0001
1a87
0001
1a88
8061
1a89
6381
1a8a
7dd2
1a8b
8000
1a8c
7f81
1a8d
1b0b
1a8e
7df2
1a8f
8000
1a90
7f81
1a91
1b0b
1a92
3c21
1a93
9c25
1a94
d822
1a95
85f5
1a96
9c23
1a97
3822
1a98
85d5
1a99
8823
1a9a
0022
1a9b
7d32
1a9c
00c6
1a9d
2420
1a9e
2781
1a9f
1b13
1aa0
1b13
1aa1
1b13
1aa2
1b13
1aa3
1b13
1aa4
1b0b
1aa5
1b13
1aa6
15f0
1aa7
1b2e
1aa8
1b2e
1aa9
15f0
1aaa
1b17
1aab
1b13
1aac
1b27
1aad
1b1f
1aae
1b1f
1aaf
1b27
1ab0
1b17
1ab1
1b13
1ab2
1b27
1ab3
1b1f
1ab4
1b23
1ab5
1b27
1ab6
1b17
1ab7
1b13
1ab8
15f0
1ab9
1b2e
1aba
1b2e
1abb
15f0
1abc
1b17
1abd
1b0b
1abe
1b17
1abf
1b17
1ac0
1b17
1ac1
1b17
1ac2
1b17
1ac3
1b13
1ac4
1b13
1ac5
1b0b
1ac6
1b0b
1ac7
1b17
1ac8
1b17
1ac9
1b13
1aca
1671
1acb
1b1f
1acc
1b23
1acd
166e
1ace
1b17
1acf
1b0b
1ad0
1b1f
1ad1
1b1f
1ad2
1b23
1ad3
1b23
1ad4
1b0b
1ad5
1b0b
1ad6
1b23
1ad7
1b23
1ad8
1b1f
1ad9
1b1f
1ada
1b0b
1adb
1b17
1adc
166e
1add
1b23
1ade
1b1f
1adf
1671
1ae0
1b13
1ae1
1b17
1ae2
1b17
1ae3
1b0b
1ae4
1b0b
1ae5
1b13
1ae6
1b13
1ae7
1b0b
1ae8
1b1f
1ae9
1b1f
1aea
1b23
1aeb
1b23
1aec
1b0b
1aed
1b13
1aee
16ee
1aef
1b1f
1af0
1b23
1af1
16eb
1af2
1b17
1af3
00c6
1af4
00c6
1af5
00c6
1af6
00c6
1af7
00c6
1af8
00c6
1af9
00c6
1afa
00c6
1afb
00c6
1afc
00c6
1afd
00c6
1afe
00c6
1aff
1b17
1b00
16eb
1b01
1b23
1b02
1b1f
1b03
16ee
1b04
1b13
1b05
1b0b
1b06
1b23
1b07
1b23
1b08
1b1f
1b09
1b1f
1b0a
1b0b
1b0b
7c61
1b0c
02eb
1b0d
7f81
1b0e
2026
1b0f
2c01
1b10
8515
1b11
7f81
1b12
1b17
1b13
7c61
1b14
02f1
1b15
7f81
1b16
2026
1b17
7c61
1b18
02f7
1b19
7f81
1b1a
2026
1b1b
2c01
1b1c
8515
1b1d
7f81
1b1e
1b23
1b1f
7c61
1b20
030d
1b21
7f81
1b22
2026
1b23
7c61
1b24
02fd
1b25
7f81
1b26
2026
1b27
2ce1
1b28
39fe
1b29
39fe
1b2a
39fe
1b2b
39fe
1b2c
7f81
1b2d
2026
1b2e
2cc1
1b2f
3dde
1b30
3dde
1b31
3dde
1b32
3dde
1b33
7f81
1b34
2026
#include "float2.dasm16"
admiral.dasm16
5
651
1b35
0fc1
1b36
0259
1b37
87c1
1b38
025c
1b39
87c1
1b3a
025d
1b3b
87c1
1b3c
025e
1b3d
87c1
1b3e
025a
1b3f
87c1
1b40
025b
1b41
7c20
1b42
1ba6
1b43
6381
1b44
6061
1b45
7b01
1b46
0259
1b47
7b01
1b48
025c
1b49
7b01
1b4a
025d
1b4b
7b01
1b4c
025e
1b4d
7b01
1b4e
025a
1b4f
7b01
1b50
025b
1b51
0f81
1b52
6061
1b53
67c1
1b54
025b
1b55
6bc1
1b56
0001
1b57
025a
1b58
6bc1
1b59
0002
1b5a
025e
1b5b
6bc1
1b5c
0003
1b5d
025d
1b5e
6bc1
1b5f
0004
1b60
025c
1b61
6bc1
1b62
0005
1b63
0259
1b64
0f81
1b65
7b01
1b66
0259
1b67
7b01
1b68
025d
1b69
7b01
1b6a
025e
1b6b
7c20
1b6c
280e
1b6d
7fd2
1b6e
042c
1b6f
025c
1b70
7e61
1b71
0800
1b72
0001
1b73
6381
1b74
0301
1b75
0701
1b76
7801
1b77
0259
1b78
0301
1b79
7821
1b7a
025d
1b7b
7c20
1b7c
1b91
1b7d
0701
1b7e
7c20
1b7f
1b86
1b80
0701
1b81
7c20
1b82
280e
1b83
6021
1b84
6001
1b85
6381
1b86
7c20
1b87
277f
1b88
8472
1b89
6381
1b8a
7e72
1b8b
1bcc
1b8c
0721
1b8d
6381
1b8e
8822
1b8f
7f81
1b90
1b86
1b91
8432
1b92
6381
1b93
8823
1b94
7c20
1b95
277f
1b96
7e73
1b97
1bcc
1b98
0721
1b99
7f81
1b9a
1b91
1b9b
8822
1b9c
6381
1b9d
6061
1b9e
63d3
1b9f
025c
1ba0
7c20
1ba1
00c6
1ba2
0f01
1ba3
7c20
1ba4
1ba6
1ba5
6381
1ba6
0301
1ba7
0701
1ba8
0b01
1ba9
7bd4
1baa
025a
1bab
025b
1bac
7f81
1bad
1bf3
1bae
7bd6
1baf
025a
1bb0
025b
1bb1
7f81
1bb2
1bec
1bb3
7801
1bb4
0259
1bb5
7821
1bb6
025e
1bb7
7fd2
1bb8
0430
1bb9
025c
1bba
8822
1bbb
7c20
1bbc
1db1
1bbd
07c1
1bbe
025d
1bbf
7c74
1bc0
007f
1bc1
7c20
1bc2
00c6
1bc3
4f81
1bc4
0721
1bc5
8822
1bc6
07c1
1bc7
025e
1bc8
6041
1bc9
6021
1bca
6001
1bcb
6381
1bcc
7fc1
1bcd
0414
1bce
025c
1bcf
8822
1bd0
8441
1bd1
7c20
1bd2
277f
1bd3
7c73
1bd4
0020
1bd5
7f81
1bd6
1bdb
1bd7
8842
1bd8
8822
1bd9
7f81
1bda
1bd1
1bdb
7e72
1bdc
1db9
1bdd
0721
1bde
7c20
1bdf
1b86
1be0
7e72
1be1
1bcc
1be2
0721
1be3
7f81
1be4
1bcf
1be5
8472
1be6
7f81
1be7
1bc6
1be8
0bc1
1be9
025a
1bea
7f81
1beb
1bc6
1bec
7fc1
1bed
0418
1bee
025c
1bef
8bc2
1bf0
025b
1bf1
7f81
1bf2
1bc8
1bf3
7fc1
1bf4
041c
1bf5
025c
1bf6
8bc3
1bf7
025b
1bf8
7f81
1bf9
1bc8
1bfa
8822
1bfb
7c20
1bfc
277f
1bfd
7e72
1bfe
1ce3
1bff
0721
1c00
7f81
1c01
1d5f
1c02
7fc1
1c03
0520
1c04
025c
1c05
7f81
1c06
1bc6
1c07
7fc1
1c08
0440
1c09
025c
1c0a
7f81
1c0b
1bc5
1c0c
7fc1
1c0d
04ac
1c0e
025c
1c0f
7f81
1c10
1bc5
1c11
7fc1
1c12
04a8
1c13
025c
1c14
7f81
1c15
1bc5
1c16
7fc1
1c17
0510
1c18
025c
1c19
7f81
1c1a
1bc5
1c1b
7fc1
1c1c
0514
1c1d
025c
1c1e
7f81
1c1f
1bc5
1c20
7fc1
1c21
0518
1c22
025c
1c23
7f81
1c24
1bc5
1c25
7fc1
1c26
051c
1c27
025c
1c28
7f81
1c29
1bc5
1c2a
7fc1
1c2b
0508
1c2c
025c
1c2d
7f81
1c2e
1bc5
1c2f
7fc1
1c30
050c
1c31
025c
1c32
7f81
1c33
1bc5
1c34
7fc1
1c35
04f0
1c36
025c
1c37
7c41
1c38
0480
1c39
7f81
1c3a
1cd1
1c3b
7fc1
1c3c
04f4
1c3d
025c
1c3e
7c41
1c3f
0484
1c40
7f81
1c41
1cd1
1c42
8822
1c43
7c20
1c44
277f
1c45
7c72
1c46
003d
1c47
7f81
1c48
1c52
1c49
7c72
1c4a
002a
1c4b
7f81
1c4c
1c57
1c4d
7fc1
1c4e
04f8
1c4f
025c
1c50
7f81
1c51
1bc6
1c52
7fc1
1c53
0488
1c54
025c
1c55
7f81
1c56
1bc5
1c57
7fc1
1c58
0504
1c59
025c
1c5a
7f81
1c5b
1bc5
1c5c
7fc1
1c5d
04e0
1c5e
025c
1c5f
7c41
1c60
0498
1c61
7f81
1c62
1cd1
1c63
7fc1
1c64
04dc
1c65
025c
1c66
7c41
1c67
0494
1c68
7f81
1c69
1cd1
1c6a
7fc1
1c6b
04e4
1c6c
025c
1c6d
7c41
1c6e
049c
1c6f
7f81
1c70
1cd1
1c71
7fc1
1c72
04fc
1c73
025c
1c74
7c41
1c75
048c
1c76
7f81
1c77
1cd1
1c78
7fc1
1c79
0500
1c7a
025c
1c7b
7c41
1c7c
0490
1c7d
7f81
1c7e
1cd1
1c7f
7fc1
1c80
047c
1c81
025c
1c82
7c41
1c83
04c4
1c84
7f81
1c85
1cd1
1c86
7fc1
1c87
04c8
1c88
025c
1c89
8822
1c8a
7c20
1c8b
277f
1c8c
7c72
1c8d
003c
1c8e
7f81
1c8f
1c99
1c90
7c73
1c91
003d
1c92
7f81
1c93
1bc6
1c94
7fc1
1c95
04cc
1c96
025c
1c97
7f81
1c98
1bc5
1c99
7fc1
1c9a
04e8
1c9b
025c
1c9c
8822
1c9d
7c20
1c9e
277f
1c9f
7c73
1ca0
003d
1ca1
7f81
1ca2
1bc6
1ca3
7fc1
1ca4
04a0
1ca5
025c
1ca6
7f81
1ca7
1bc5
1ca8
7fc1
1ca9
04d0
1caa
025c
1cab
8822
1cac
7c20
1cad
277f
1cae
7c72
1caf
003e
1cb0
7f81
1cb1
1cbb
1cb2
7c73
1cb3
003d
1cb4
7f81
1cb5
1bc6
1cb6
7fc1
1cb7
04d4
1cb8
025c
1cb9
7f81
1cba
1bc5
1cbb
7fc1
1cbc
04ec
1cbd
025c
1cbe
8822
1cbf
7c20
1cc0
277f
1cc1
7c73
1cc2
003d
1cc3
7f81
1cc4
1bc6
1cc5
7fc1
1cc6
04a4
1cc7
025c
1cc8
7f81
1cc9
1bc5
1cca
7fc1
1ccb
04bc
1ccc
025c
1ccd
7c41
1cce
04d8
1ccf
7f81
1cd0
1cd1
1cd1
8822
1cd2
7c20
1cd3
277f
1cd4
7c73
1cd5
003d
1cd6
7f81
1cd7
1bc6
1cd8
0bc1
1cd9
025c
1cda
7f81
1cdb
1bc5
1cdc
7fc1
1cdd
0410
1cde
025c
1cdf
87c1
1ce0
025a
1ce1
7f81
1ce2
1bc6
1ce3
7c73
1ce4
0030
1ce5
7f81
1ce6
1cf7
1ce7
8822
1ce8
7c20
1ce9
277f
1cea
7c72
1ceb
0078
1cec
7f81
1ced
1d0b
1cee
7c72
1cef
0058
1cf0
7f81
1cf1
1d0b
1cf2
7f81
1cf3
1cf7
1cf4
8822
1cf5
7c20
1cf6
277f
1cf7
7c72
1cf8
002e
1cf9
7f81
1cfa
1d5f
1cfb
7c72
1cfc
0065
1cfd
7f81
1cfe
1d5f
1cff
7e72
1d00
1ce3
1d01
0721
1d02
7f81
1d03
1cf4
1d04
07c1
1d05
025e
1d06
7fc1
1d07
0420
1d08
025c
1d09
7f81
1d0a
1bc6
1d0b
8822
1d0c
7c20
1d0d
277f
1d0e
7e72
1d0f
1ce3
1d10
0721
1d11
7f81
1d12
1d0b
1d13
7c74
1d14
0060
1d15
7c76
1d16
0067
1d17
7f81
1d18
1d0b
1d19
7c74
1d1a
0040
1d1b
7c76
1d1c
0047
1d1d
7f81
1d1e
1d0b
1d1f
07c1
1d20
025e
1d21
7fc1
1d22
0424
1d23
025c
1d24
7f81
1d25
1bc6
1d26
8822
1d27
7c20
1d28
277f
1d29
7e72
1d2a
1d26
1d2b
0721
1d2c
7f81
1d2d
1d26
1d2e
7e72
1d2f
1ce3
1d30
0721
1d31
7f81
1d32
1d26
1d33
07c1
1d34
025e
1d35
2001
1d36
7802
1d37
025d
1d38
7823
1d39
025d
1d3a
8802
1d3b
1b01
1d3c
1f01
1d3d
7c61
1d3e
0694
1d3f
7c20
1d40
2168
1d41
60e1
1d42
60c1
1d43
0bc1
1d44
025c
1d45
7f81
1d46
1bc8
1d47
0c81
1d48
8bc2
1d49
025d
1d4a
8822
1d4b
7c20
1d4c
277f
1d4d
8472
1d4e
7c20
1d4f
00c6
1d50
7e72
1d51
1bcc
1d52
0721
1d53
7c20
1d54
00c6
1d55
1073
1d56
7f81
1d57
1d4a
1d58
07c1
1d59
025e
1d5a
7fc1
1d5b
0430
1d5c
025c
1d5d
7f81
1d5e
1bc6
1d5f
7821
1d60
025d
1d61
8841
1d62
7c20
1d63
277f
1d64
8822
1d65
7c72
1d66
002b
1d67
7f81
1d68
1d90
1d69
7c72
1d6a
002d
1d6b
7f81
1d6c
1d90
1d6d
7c72
1d6e
0065
1d6f
7f81
1d70
1d9e
1d71
7c72
1d72
002e
1d73
7f81
1d74
1d98
1d75
7e73
1d76
1ce3
1d77
0721
1d78
7f81
1d79
1da5
1d7a
7c50
1d7b
0060
1d7c
7f81
1d7d
1d8c
1d7e
e450
1d7f
7f81
1d80
1d86
1d81
a050
1d82
7f81
1d83
1d89
1d84
7f81
1d85
1da5
1d86
c441
1d87
7f81
1d88
1d62
1d89
9441
1d8a
7f81
1d8b
1d62
1d8c
7c41
1d8d
0080
1d8e
7f81
1d8f
1d62
1d90
7c53
1d91
0020
1d92
7f81
1d93
1da5
1d94
7c41
1d95
0040
1d96
7f81
1d97
1d62
1d98
a051
1d99
7f81
1d9a
1da5
1d9b
a441
1d9c
7f81
1d9d
1d62
1d9e
e051
1d9f
7f81
1da0
1da5
1da1
7c41
1da2
0020
1da3
7f81
1da4
1d62
1da5
7c50
1da6
0063
1da7
7c20
1da8
00c6
1da9
8823
1daa
07c1
1dab
025e
1dac
7fc1
1dad
0428
1dae
025c
1daf
7f81
1db0
1bc8
1db1
7c20
1db2
277f
1db3
7c73
1db4
0020
1db5
6381
1db6
8822
1db7
7f81
1db8
1db1
1db9
8822
1dba
7c20
1dbb
1b86
1dbc
7f81
1dbd
1bcc
1dbe
7c20
1dbf
00c6
#include "lexer2.dasm16"
admiral.dasm16
6
965
1dc0
0301
1dc1
0701
1dc2
6801
1dc3
0004
1dc4
6821
1dc5
0003
1dc6
0c63
1dc7
0412
1dc8
7f81
1dc9
1df7
1dca
0301
1dcb
0701
1dcc
7f01
1dcd
1df7
1dce
8802
1dcf
8822
1dd0
7d10
1dd1
0030
1dd2
7d30
1dd3
0030
1dd4
7f81
1dd5
24f4
1dd6
7d10
1dd7
0040
1dd8
7d30
1dd9
0040
1dda
7f81
1ddb
15bd
1ddc
7d10
1ddd
0030
1dde
7d30
1ddf
0040
1de0
7f81
1de1
15ab
1de2
7d10
1de3
0040
1de4
7d30
1de5
0030
1de6
7f81
1de7
1599
1de8
7d10
1de9
0808
1dea
2132
1deb
7f81
1dec
2994
1ded
a110
1dee
2132
1def
7f81
1df0
2946
1df1
8461
1df2
2514
1df3
8861
1df4
2516
1df5
8061
1df6
9362
1df7
6021
1df8
6001
1df9
6321
1dfa
6321
1dfb
6381
1dfc
8b01
1dfd
8b01
1dfe
7c20
1dff
2039
1e00
5461
1e01
000a
1e02
7e70
1e03
0100
1e04
0001
1e05
9661
1e06
0001
1e07
4c01
1e08
0001
1e09
7c12
1e0a
0800
1e0b
7f81
1e0c
1e1a
1e0d
9412
1e0e
7f81
1e0f
1e24
1e10
7c12
1e11
0400
1e12
7f81
1e13
1e39
1e14
7c12
1e15
0200
1e16
7f81
1e17
1e45
1e18
7f81
1e19
2026
1e1a
7b01
1e1b
0236
1e1c
0f01
1e1d
7c20
1e1e
005c
1e1f
8472
1e20
7c20
1e21
00c6
1e22
7f81
1e23
2026
1e24
0c01
1e25
84c1
1e26
2041
1e27
2841
1e28
08d2
1e29
7f81
1e2a
1e35
1e2b
2021
1e2c
1822
1e2d
4701
1e2e
0001
1e2f
7c20
1e30
1dfc
1e31
0e21
1e32
0001
1e33
7f9e
1e34
1e28
1e35
5461
1e36
000a
1e37
7f81
1e38
2026
1e39
2c61
1e3a
4f01
1e3b
0001
1e3c
4f01
1e3d
0002
1e3e
7c20
1e3f
005c
1e40
8472
1e41
7c20
1e42
00c6
1e43
7f81
1e44
2026
1e45
2c01
1e46
4021
1e47
0001
1e48
4041
1e49
0002
1e4a
8a32
1e4b
0001
1e4c
7f81
1e4d
1e5c
1e4e
8e32
1e4f
0001
1e50
7f81
1e51
1e65
1e52
9632
1e53
0001
1e54
7f81
1e55
1e65
1e56
a632
1e57
0001
1e58
7f81
1e59
1e86
1e5a
7c20
1e5b
00c6
1e5c
0701
1e5d
0b01
1e5e
7c20
1e5f
005c
1e60
8472
1e61
7c20
1e62
00c6
1e63
7f81
1e64
2026
1e65
7e52
1e66
0020
1e67
0001
1e68
7f81
1e69
1e70
1e6a
9652
1e6b
0001
1e6c
7f81
1e6d
1e76
1e6e
7c20
1e6f
00c6
1e70
0701
1e71
0b01
1e72
7c20
1e73
2913
1e74
7f81
1e75
2026
1e76
2801
1e77
0701
1e78
4301
1e79
0001
1e7a
7c20
1e7b
22bc
1e7c
0f01
1e7d
4301
1e7e
0002
1e7f
7c20
1e80
22bc
1e81
0f01
1e82
7c20
1e83
280e
1e84
7f81
1e85
2026
1e86
7e52
1e87
0020
1e88
0001
1e89
7f81
1e8a
1e91
1e8b
9652
1e8c
0001
1e8d
7f81
1e8e
1e76
1e8f
7c20
1e90
00c6
1e91
0701
1e92
0b01
1e93
7c20
1e94
22bc
1e95
2481
1e96
7c70
1e97
8000
1e98
3062
1e99
3075
1e9a
7c20
1e9b
00c6
1e9c
3072
1e9d
7c20
1e9e
00c6
1e9f
8477
1ea0
7c20
1ea1
00c6
1ea2
0f01
1ea3
8862
1ea4
0f01
1ea5
7c20
1ea6
280e
1ea7
7f81
1ea8
2026
1ea9
8b01
1eaa
8701
1eab
7c20
1eac
2039
1ead
5401
1eae
000a
1eaf
2021
1eb0
7c12
1eb1
029b
1eb2
7f81
1eb3
1ed3
1eb4
4061
1eb5
0001
1eb6
7c70
1eb7
0030
1eb8
8932
1eb9
8632
1eba
0001
1ebb
7f81
1ebc
1ed3
1ebd
7c70
1ebe
0040
1ebf
8132
1ec0
7f81
1ec1
1ed3
1ec2
7c70
1ec3
0040
1ec4
8932
1ec5
7f81
1ec6
1ed3
1ec7
7c71
1ec8
0070
1ec9
8532
1eca
7f81
1ecb
1ed3
1ecc
a472
1ecd
7f81
1ece
1ed7
1ecf
7c61
1ed0
02e9
1ed1
7f81
1ed2
2026
1ed3
7c61
1ed4
02e7
1ed5
7f81
1ed6
2026
1ed7
0301
1ed8
7f01
1ed9
03f5
1eda
7c20
1edb
29a6
1edc
8472
1edd
7f81
1ede
1ed3
1edf
7f81
1ee0
1ecf
1ee1
8f01
1ee2
8b01
1ee3
7c20
1ee4
2039
1ee5
5401
1ee6
000b
1ee7
5421
1ee8
000a
1ee9
a612
1eea
0001
1eeb
7f81
1eec
1ef3
1eed
9e10
1eee
0001
1eef
7f81
1ef0
1f17
1ef1
7c20
1ef2
00c6
1ef3
0301
1ef4
7c20
1ef5
28ca
1ef6
0ea1
1ef7
ffff
1ef8
0f01
1ef9
7c32
1efa
02e9
1efb
7f01
1efc
1f0f
1efd
7c32
1efe
02e7
1eff
7f01
1f00
1f07
1f01
7c20
1f02
28a8
1f03
5461
1f04
ffff
1f05
7f81
1f06
2026
1f07
8461
1f08
6b56
1f09
0001
1f0a
0002
1f0b
8861
1f0c
64c1
1f0d
9362
1f0e
1b81
1f0f
8461
1f10
6b54
1f11
0001
1f12
0002
1f13
8861
1f14
64c1
1f15
9362
1f16
1b81
1f17
0301
1f18
7c32
1f19
02e9
1f1a
7f01
1f1b
1f31
1f1c
7c32
1f1d
02e7
1f1e
7f01
1f1f
1f26
1f20
7c20
1f21
28a8
1f22
5461
1f23
000b
1f24
7f81
1f25
2026
1f26
60c1
1f27
7c20
1f28
1dc0
1f29
1b01
1f2a
8072
1f2b
7f81
1f2c
1f2f
1f2d
8461
1f2e
1b81
1f2f
8861
1f30
1b81
1f31
60c1
1f32
7c20
1f33
1dc0
1f34
1b01
1f35
8872
1f36
7f81
1f37
1f2f
1f38
8461
1f39
1b81
1f3a
8f01
1f3b
8f01
1f3c
7c20
1f3d
2039
1f3e
5401
1f3f
000b
1f40
5421
1f41
000a
1f42
7e12
1f43
0100
1f44
0001
1f45
9601
1f46
0001
1f47
7e12
1f48
0800
1f49
0001
1f4a
7f81
1f4b
1f88
1f4c
9612
1f4d
0001
1f4e
7f81
1f4f
1f92
1f50
7e12
1f51
0400
1f52
0001
1f53
7f81
1f54
1f7d
1f55
7e12
1f56
0200
1f57
0001
1f58
7f81
1f59
1f5c
1f5a
7c20
1f5b
00c6
1f5c
2001
1f5d
4081
1f5e
0001
1f5f
4041
1f60
0002
1f61
8a92
1f62
0001
1f63
7e50
1f64
00f8
1f65
0001
1f66
7f81
1f67
1f79
1f68
8e92
1f69
0001
1f6a
7e52
1f6b
0020
1f6c
0001
1f6d
7f81
1f6e
1f71
1f6f
7c20
1f70
00c6
1f71
1301
1f72
0b01
1f73
0701
1f74
7c20
1f75
2922
1f76
0461
1f77
7f81
1f78
2026
1f79
1301
1f7a
0b01
1f7b
7f81
1f7c
1f82
1f7d
2001
1f7e
4301
1f7f
0001
1f80
4301
1f81
0002
1f82
0701
1f83
7c20
1f84
2f54
1f85
0461
1f86
7f81
1f87
2026
1f88
7b01
1f89
0236
1f8a
0301
1f8b
0701
1f8c
9701
1f8d
7c20
1f8e
0096
1f8f
0461
1f90
7f81
1f91
2026
1f92
84c1
1f93
2041
1f94
2841
1f95
2481
1f96
0993
1f97
7c20
1f98
00c6
1f99
08d2
1f9a
7f81
1f9b
1fae
1f9c
2061
1f9d
1862
1f9e
4f01
1f9f
0001
1fa0
2461
1fa1
1862
1fa2
4f01
1fa3
0001
1fa4
a632
1fa5
0001
1fa6
7c20
1fa7
1fb1
1fa8
a633
1fa9
0001
1faa
7c20
1fab
1f3a
1fac
7f9e
1fad
1f99
1fae
0461
1faf
7f81
1fb0
2026
1fb1
8f01
1fb2
8b01
1fb3
7c20
1fb4
2039
1fb5
5401
1fb6
000b
1fb7
8b01
1fb8
a701
1fb9
7c20
1fba
2770
1fbb
0ea1
1fbc
ffff
1fbd
0c21
1fbe
2c41
1fbf
5641
1fc0
000a
1fc1
0001
1fc2
7e12
1fc3
0800
1fc4
0001
1fc5
7f81
1fc6
1f88
1fc7
7c81
1fc8
00c6
1fc9
7e12
1fca
0400
1fcb
0001
1fcc
7c81
1fcd
2f54
1fce
7e12
1fcf
0200
1fd0
0001
1fd1
7c81
1fd2
2922
1fd3
2001
1fd4
4301
1fd5
0001
1fd6
4301
1fd7
0002
1fd8
0701
1fd9
1020
1fda
0461
1fdb
7f81
1fdc
2026
1fdd
8b01
1fde
8b01
1fdf
7c20
1fe0
2039
1fe1
5401
1fe2
000a
1fe3
7e12
1fe4
0800
1fe5
0001
1fe6
7f81
1fe7
1ffe
1fe8
7c81
1fe9
00c6
1fea
7e12
1feb
0200
1fec
0001
1fed
7c81
1fee
2933
1fef
2001
1ff0
4021
1ff1
0001
1ff2
8a32
1ff3
0001
1ff4
7c81
1ff5
2f89
1ff6
0701
1ff7
4301
1ff8
0002
1ff9
1020
1ffa
7c61
1ffb
029b
1ffc
7f81
1ffd
2026
1ffe
7b01
1fff
0236
2000
0301
2001
7c20
2002
0079
2003
7c61
2004
029b
2005
7f81
2006
2026
2007
7e10
2008
0030
2009
0001
200a
7e32
200b
0040
200c
0001
200d
7f81
200e
2018
200f
7e30
2010
0030
2011
0001
2012
7e12
2013
0040
2014
0001
2015
7f81
2016
201f
2017
6381
2018
0301
2019
7c20
201a
1757
201b
0ea1
201c
ffff
201d
0c01
201e
6381
201f
0701
2020
7c20
2021
1757
2022
0ea1
2023
fffe
2024
0c21
2025
6381
2026
1761
2027
60a1
2028
6081
2029
60e1
202a
60c1
202b
6041
202c
6021
202d
6001
202e
8b62
202f
6f22
2030
8b22
2031
1701
2032
68a1
2033
0001
2034
69a1
2035
0002
2036
60a1
2037
6761
2038
6381
2039
6061
203a
0301
203b
0701
203c
0b01
203d
1b01
203e
1f01
203f
1301
2040
1701
2041
6ca1
2042
6cc1
2043
54c3
2044
0007
2045
1b72
2046
0f81
2047
8701
2048
7f81
2049
2045
204a
8b01
204b
8b01
204c
7c20
204d
2039
204e
7f81
204f
205b
2050
8b01
2051
8b01
2052
7c20
2053
2039
2054
8481
2055
5401
2056
000a
2057
a612
2058
0001
2059
7f81
205a
2063
205b
5701
205c
000a
205d
7c20
205e
2086
205f
0ea1
2060
ffff
2061
0c01
2062
8881
2063
8021
2064
8822
2065
7c20
2066
277f
2067
8472
2068
7f81
2069
2026
206a
8492
206b
7c72
206c
002f
206d
7f81
206e
2074
206f
0c41
2070
7c20
2071
2ef4
2072
7f81
2073
2064
2074
8822
2075
7c20
2076
277f
2077
7c72
2078
006e
2079
7f81
207a
2081
207b
7c41
207c
002f
207d
7c20
207e
2ef4
207f
7f81
2080
2067
2081
ac41
2082
7c20
2083
2ef4
2084
7f81
2085
2064
2086
8b01
2087
8b01
2088
7c20
2089
2039
208a
5461
208b
000a
208c
a672
208d
0001
208e
7f81
208f
20b6
2090
7e72
2091
0800
2092
0001
2093
7f81
2094
2026
2095
c672
2096
0001
2097
7f81
2098
20d7
2099
7e72
209a
0080
209b
0001
209c
7f81
209d
20e0
209e
7c81
209f
00c6
20a0
7e72
20a1
0020
20a2
0001
20a3
7c81
20a4
2371
20a5
7e72
20a6
0040
20a7
0001
20a8
7c81
20a9
19b6
20aa
9e70
20ab
0001
20ac
7c81
20ad
294c
20ae
8a72
20af
0001
20b0
7c81
20b1
2fd1
20b2
0f01
20b3
1020
20b4
7f81
20b5
2026
20b6
2c01
20b7
2001
20b8
8c02
20b9
0301
20ba
a701
20bb
7c20
20bc
21d3
20bd
0ea1
20be
ffff
20bf
5701
20c0
ffff
20c1
7f01
20c2
0027
20c3
7c20
20c4
27d8
20c5
5701
20c6
ffff
20c7
5701
20c8
000a
20c9
7c20
20ca
283b
20cb
0ea1
20cc
ffff
20cd
5701
20ce
ffff
20cf
7f01
20d0
0027
20d1
7c20
20d2
27d8
20d3
5461
20d4
ffff
20d5
7f81
20d6
2026
20d7
0c01
20d8
7c61
20d9
03ee
20da
7c12
20db
02e7
20dc
7c61
20dd
03f5
20de
7f81
20df
2026
20e0
7c61
20e1
03e7
20e2
7f81
20e3
2026
20e4
1a00
20e5
84d2
20e6
6381
20e7
88c3
20e8
1a20
20e9
7c12
20ea
f615
20eb
7c32
20ec
7349
20ed
1bc1
20ee
0250
20ef
7c12
20f0
7406
20f1
7c32
20f2
30cf
20f3
1bc1
20f4
024f
20f5
7c12
20f6
b402
20f7
7c32
20f8
12d0
20f9
1bc1
20fa
0251
20fb
7c12
20fc
24c5
20fd
7c32
20fe
4fd5
20ff
1bc1
2100
0252
2101
7f81
2102
20e5
2103
8801
2104
7a40
2105
024f
2106
8452
2107
7f81
2108
2103
2109
7c52
210a
0091
210b
7f81
210c
2103
210d
7c52
210e
0090
210f
7f81
2110
2103
2111
0b01
2112
8c01
2113
7c21
2114
0091
2115
7a40
2116
024f
2117
c04f
2118
604b
2119
6381
211a
8b01
211b
8b01
211c
7c20
211d
2039
211e
86b2
211f
000a
2120
7f81
2121
212c
2122
5701
2123
000a
2124
7c20
2125
1dfc
2126
0ea1
2127
ffff
2128
5701
2129
ffff
212a
7c20
212b
2050
212c
7881
212d
023a
212e
5021
212f
0002
2130
7c20
2131
2e21
2132
8801
2133
7a40
2134
024f
2135
8452
2136
7f81
2137
2132
2138
7c54
2139
007f
213a
7f81
213b
2132
213c
7c20
213d
2e21
213e
c852
213f
7f81
2140
2153
2141
c452
2142
0692
2143
0002
2144
7f81
2145
2130
2146
5001
2147
0001
2148
8803
2149
c453
214a
c853
214b
0292
214c
0002
214d
7c23
214e
0020
214f
7c20
2150
2ef4
2151
7f81
2152
2130
2153
5001
2154
0002
2155
0403
2156
8802
2157
0301
2158
a701
2159
7c20
215a
2770
215b
2ce1
215c
3ce2
215d
ade1
215e
50df
215f
0002
2160
04d6
2161
7f81
2162
2026
2163
39e1
2164
7dea
2165
007f
2166
7f9f
2167
2160
2168
8803
2169
8822
216a
8863
216b
0cfe
216c
3c61
216d
1c62
216e
2c41
216f
89f2
2170
6381
2171
05f3
2172
7f81
2173
216b
2174
00de
2175
39f2
2176
0cf6
2177
7f9e
2178
2175
2179
0cf2
217a
6381
217b
7f81
217c
216b
217d
7c61
217e
02e9
217f
7f81
2180
2026
2181
7c61
2182
02e7
2183
7f81
2184
2026
#include "stdlib.dasm16"
admiral.dasm16
7
285
2185
8f01
2186
8701
2187
7c20
2188
2039
2189
5441
218a
000b
218b
5401
218c
000a
218d
0256
218e
0002
218f
7f81
2190
2195
2191
0241
2192
0002
2193
7f81
2194
2026
2195
7861
2196
0255
2197
7863
2198
0254
2199
0076
219a
7c20
219b
2208
219c
78c1
219d
0254
219e
1802
219f
28e1
21a0
1c21
21a1
4822
21a2
0002
21a3
04f2
21a4
7f81
21a5
21a9
21a6
3dc1
21a7
7f9e
21a8
21a3
21a9
00d2
21aa
7f81
21ab
21af
21ac
85c1
21ad
7f9e
21ae
21a9
21af
0bd2
21b0
0257
21b1
7f81
21b2
21c7
21b3
7c21
21b4
0256
21b5
9023
21b6
0a32
21b7
0003
21b8
7f81
21b9
21be
21ba
4421
21bb
0003
21bc
7f81
21bd
21b6
21be
4a21
21bf
0003
21c0
0003
21c1
7821
21c2
0257
21c3
0bc1
21c4
0257
21c5
0a21
21c6
0003
21c7
7941
21c8
0254
21c9
5641
21ca
000a
21cb
0002
21cc
8641
21cd
0003
21ce
03c1
21cf
0254
21d0
0861
21d1
7f81
21d2
2026
21d3
0301
21d4
6801
21d5
0003
21d6
9402
21d7
7861
21d8
0255
21d9
7863
21da
0254
21db
0076
21dc
7c20
21dd
2208
21de
8bc3
21df
0253
21e0
83b2
21e1
7c20
21e2
2237
21e3
7861
21e4
0258
21e5
8472
21e6
7f81
21e7
2202
21e8
4fc1
21e9
0003
21ea
0258
21eb
7961
21ec
0254
21ed
6a61
21ee
0003
21ef
0002
21f0
6a61
21f1
0002
21f2
0001
21f3
8661
21f4
0003
21f5
6bc2
21f6
0003
21f7
0254
21f8
7801
21f9
0257
21fa
0fc1
21fb
0257
21fc
0e01
21fd
0003
21fe
6001
21ff
6321
2200
6321
2201
6381
2202
97c3
2203
0255
2204
7861
2205
0255
2206
7f81
2207
21eb
2208
7c20
2209
2237
220a
7c20
220b
2214
220c
7861
220d
0255
220e
7863
220f
0254
2210
0076
2211
7c20
2212
00c6
2213
6381
2214
8701
2215
8701
2216
7c20
2217
2039
2218
7cc1
2219
4000
221a
7c01
221b
0253
221c
4001
221d
0003
221e
8412
221f
7f81
2220
2231
2221
20e1
2222
18f6
2223
7c20
2224
00c6
2225
1821
2226
4022
2227
0002
2228
1901
2229
1cd2
222a
04c1
222b
04d2
222c
7f81
222d
221c
222e
3dde
222f
7f81
2230
222b
2231
1bc1
2232
0254
2233
7c20
2234
228b
2235
7f81
2236
2026
2237
8701
2238
8701
2239
7c20
223a
2039
223b
7fc1
223c
0028
223d
0253
223e
1481
223f
10c1
2240
50c3
2241
0007
2242
10d2
2243
7f81
2244
224a
2245
3b01
2246
7c20
2247
2274
2248
7f9e
2249
2242
224a
3081
224b
8493
224c
7f81
224d
223f
224e
7cc1
224f
0253
2250
78e1
2251
0256
2252
84f2
2253
7f81
2254
226e
2255
7ef1
2256
8000
2257
0001
2258
7f81
2259
2264
225a
7eec
225b
8000
225c
0001
225d
1ec1
225e
0003
225f
1cc1
2260
5ce1
2261
0003
2262
7f81
2263
2252
2264
5c61
2265
0003
2266
7ae1
2267
0258
2268
0003
2269
1fc1
226a
0258
226b
0ce1
226c
7f81
226d
2252
226e
86c1
226f
0003
2270
1bc1
2271
0257
2272
7f81
2273
2026
2274
6861
2275
0001
2276
6321
2277
7876
2278
0255
2279
6381
227a
7e70
227b
8000
227c
0001
227d
6381
227e
7e6b
227f
8000
2280
0001
2281
7e71
2282
2707
2283
0001
2284
6381
2285
0f01
2286
7f01
2287
2274
2288
7c20
2289
28e4
228a
6381
228b
084c
228c
7c21
228d
2296
228e
6c81
228f
7b61
2290
0255
2291
6c01
2292
1803
2293
a00a
2294
a403
2295
0383
2296
0b01
2297
0b01
2298
0b01
2299
0b01
229a
0b01
229b
0b01
229c
0b01
229d
0b01
229e
1b74
229f
0781
22a0
1361
22a1
6381
#include "memory.dasm16"
admiral.dasm16
8
1230
22a2
cb56
22a3
0001
22a4
7f81
22a5
22b5
22a6
8b01
22a7
7f50
22a8
8000
22a9
0002
22aa
8f21
22ab
7f01
22ac
0020
22ad
7c20
22ae
2770
22af
2c01
22b0
2002
22b1
6901
22b2
0001
22b3
6321
22b4
6381
22b5
6861
22b6
0001
22b7
8c6f
22b8
7c62
22b9
02a3
22ba
6321
22bb
6381
22bc
6861
22bd
0001
22be
2c61
22bf
2c62
22c0
2c61
22c1
6321
22c2
6381
22c3
8b01
22c4
8b01
22c5
7c20
22c6
2039
22c7
7ea1
22c8
02a3
22c9
ffff
22ca
5401
22cb
000a
22cc
8421
22cd
8481
22ce
7c20
22cf
277f
22d0
7e73
22d1
1c3b
22d2
0721
22d3
7f81
22d4
22d9
22d5
8881
22d6
8822
22d7
7c20
22d8
277f
22d9
7c73
22da
0030
22db
7f81
22dc
22e9
22dd
8822
22de
7c20
22df
277f
22e0
7c73
22e1
0078
22e2
7f81
22e3
22e9
22e4
8822
22e5
7c20
22e6
277f
22e7
7f81
22e8
232a
22e9
0c41
22ea
7e53
22eb
1ce3
22ec
0721
22ed
7f81
22ee
2308
22ef
7f01
22f0
02cb
22f1
5701
22f2
ffff
22f3
7c20
22f4
25c7
22f5
0ea1
22f6
ffff
22f7
7c43
22f8
0030
22f9
8c4f
22fa
7c42
22fb
02a3
22fc
5701
22fd
ffff
22fe
0b01
22ff
7c20
2300
254d
2301
0ea1
2302
ffff
2303
8822
2304
7c20
2305
277f
2306
7f81
2307
22e9
2308
5461
2309
ffff
230a
8492
230b
7f81
230c
2026
230d
5701
230e
ffff
230f
7c20
2310
24c3
2311
7f81
2312
2026
2313
8b01
2314
8b01
2315
7c20
2316
2039
2317
7ea1
2318
02a3
2319
ffff
231a
5401
231b
000a
231c
8421
231d
8481
231e
7c20
231f
277f
2320
7e73
2321
1c3b
2322
0721
2323
7f81
2324
2327
2325
8881
2326
8822
2327
8c22
2328
7c20
2329
277f
232a
0c41
232b
7c54
232c
002f
232d
7c56
232e
003a
232f
7f81
2330
233f
2331
7c54
2332
0060
2333
7c56
2334
0067
2335
7f81
2336
233f
2337
7c54
2338
0040
2339
7c56
233a
0047
233b
7f81
233c
233f
233d
7f81
233e
2308
233f
7f01
2340
02e3
2341
5701
2342
ffff
2343
7c20
2344
25c7
2345
0ea1
2346
ffff
2347
0861
2348
7c54
2349
002f
234a
7c56
234b
003a
234c
7c63
234d
0030
234e
7c54
234f
0060
2350
7c56
2351
0067
2352
7c63
2353
0057
2354
7c54
2355
0040
2356
7c56
2357
0047
2358
7c63
2359
0037
235a
8c6f
235b
7c62
235c
02a3
235d
5701
235e
ffff
235f
0f01
2360
7c20
2361
254d
2362
0ea1
2363
ffff
2364
8822
2365
7c20
2366
277f
2367
7f81
2368
232a
2369
8b01
236a
8b01
236b
7c20
236c
2039
236d
7c81
236e
02e3
236f
7f81
2370
2377
2371
8b01
2372
8b01
2373
7c20
2374
2039
2375
7c81
2376
02cb
2377
5701
2378
000a
2379
7c20
237a
24ab
237b
0ea1
237c
ffff
237d
84c1
237e
5701
237f
ffff
2380
1301
2381
7c20
2382
2639
2383
0ea1
2384
ffff
2385
2c01
2386
4021
2387
0002
2388
2421
2389
2422
238a
2421
238b
4421
238c
0400
238d
071e
238e
42a1
238f
0001
2390
ffff
2391
5701
2392
ffff
2393
7c20
2394
24df
2395
8473
2396
7f81
2397
237e
2398
7c92
2399
02cb
239a
7f81
239b
23a0
239c
7f1e
239d
0078
239e
7f1e
239f
0030
23a0
5701
23a1
000a
23a2
7c20
23a3
24df
23a4
8073
23a5
7f81
23a6
23a9
23a7
7f1e
23a8
002d
23a9
1b01
23aa
a701
23ab
7c20
23ac
2770
23ad
0ea1
23ae
ffff
23af
2c01
23b0
1802
23b1
2cfe
23b2
61e1
23b3
00f6
23b4
7f9e
23b5
23b2
23b6
7f81
23b7
2026
23b8
8f01
23b9
8f01
23ba
7c20
23bb
2039
23bc
5701
23bd
000a
23be
5701
23bf
000b
23c0
7c20
23c1
253b
23c2
0ea1
23c3
ffff
23c4
5401
23c5
ffff
23c6
2001
23c7
2301
23c8
7f01
23c9
0020
23ca
7c20
23cb
2770
23cc
0ea1
23cd
fffe
23ce
2c01
23cf
8802
23d0
2cc1
23d1
38c2
23d2
7c20
23d3
23ed
23d4
00d2
23d5
7c6a
23d6
7fff
23d7
0dc1
23d8
00d4
23d9
7f9f
23da
23d2
23db
5701
23dc
fffe
23dd
5701
23de
ffff
23df
7c20
23e0
2639
23e1
2c61
23e2
4ea1
23e3
0002
23e4
ffff
23e5
5701
23e6
000b
23e7
5701
23e8
ffff
23e9
7c20
23ea
254d
23eb
7f81
23ec
2026
23ed
7861
23ee
024a
23ef
886d
23f0
786b
23f1
024b
23f2
77c1
23f3
024b
23f4
87b3
23f5
786c
23f6
024c
23f7
0fc1
23f8
024a
23f9
6381
23fa
8f01
23fb
8f01
23fc
7c20
23fd
2039
23fe
7c81
23ff
23fa
2400
5401
2401
000b
2402
2001
2403
5421
2404
000a
2405
2421
2406
2041
2407
0934
2408
2441
2409
5701
240a
000a
240b
0b01
240c
7c20
240d
274d
240e
0ea1
240f
fffe
2410
5701
2411
000b
2412
0b01
2413
7c20
2414
274d
2415
0ea1
2416
ffff
2417
2c01
2418
00c1
2419
2002
241a
54e1
241b
fffe
241c
3cfe
241d
7c92
241e
23fa
241f
3dcb
2420
7c92
2421
242e
2422
3dcc
2423
7c92
2424
2436
2425
3dca
2426
00d6
2427
7f9e
2428
241d
2429
0f01
242a
7c20
242b
2716
242c
7f81
242d
2026
242e
8f01
242f
8f01
2430
7c20
2431
2039
2432
7c81
2433
242e
2434
7f81
2435
2400
2436
8f01
2437
8f01
2438
7c20
2439
2039
243a
7c81
243b
2436
243c
7f81
243d
2400
243e
8f01
243f
8b01
2440
7c20
2441
2039
2442
5701
2443
000a
2444
7c20
2445
22bc
2446
0c01
2447
c406
2448
0c21
2449
c428
244a
5441
244b
000b
244c
2841
244d
2841
244e
0042
244f
8842
2450
5701
2451
000b
2452
0b01
2453
7c20
2454
274d
2455
0ea1
2456
ffff
2457
2cc1
2458
2ce1
2459
2c42
245a
00e2
245b
8ce2
245c
06cf
245d
0001
245e
3c81
245f
85e1
2460
12c1
2461
0002
2462
06cf
2463
0002
2464
76cb
2465
0001
2466
08f6
2467
7f9e
2468
245e
2469
0f01
246a
7c20
246b
2716
246c
7f81
246d
2026
246e
8f01
246f
8b01
2470
7c20
2471
2039
2472
5461
2473
000a
2474
7f81
2475
247e
2476
8f01
2477
8b01
2478
7c20
2479
2039
247a
5701
247b
000a
247c
7c20
247d
22bc
247e
0c01
247f
c406
2480
0c21
2481
c428
2482
5441
2483
000b
2484
2841
2485
2841
2486
0816
2487
7f81
2488
248d
2489
7c61
248a
02a3
248b
7f81
248c
2026
248d
0043
248e
54c1
248f
000b
2490
38c1
2491
08c2
2492
0b01
2493
7f01
2494
0020
2495
7c20
2496
2770
2497
2c01
2498
8802
2499
2c42
249a
08e1
249b
39e1
249c
1c12
249d
05ee
249e
1c13
249f
05ed
24a0
1c53
24a1
76eb
24a2
0001
24a3
1c13
24a4
7f9f
24a5
249b
24a6
0f01
24a7
7c20
24a8
2716
24a9
7f81
24aa
2026
24ab
8b01
24ac
8701
24ad
7c20
24ae
2039
24af
5461
24b0
000a
24b1
2c01
24b2
7e11
24b3
8000
24b4
0001
24b5
7c20
24b6
2026
24b7
0f01
24b8
7c20
24b9
24c3
24ba
7c20
24bb
2026
24bc
8b01
24bd
8b01
24be
7c20
24bf
2039
24c0
8421
24c1
7f81
24c2
24c7
24c3
8b01
24c4
8b01
24c5
7c20
24c6
2039
24c7
54c1
24c8
000a
24c9
38c1
24ca
3b01
24cb
7f01
24cc
0020
24cd
7c20
24ce
2770
24cf
0ea1
24d0
ffff
24d1
2c01
24d2
38c2
24d3
00e1
24d4
20e2
24d5
8821
24d6
39e1
24d7
81ec
24d8
05e2
24d9
743f
24da
00f3
24db
7f81
24dc
24d6
24dd
7c20
24de
2026
24df
8b01
24e0
8701
24e1
7c20
24e2
2039
24e3
5401
24e4
000a
24e5
2001
24e6
7e10
24e7
8000
24e8
0001
24e9
8061
24ea
7e11
24eb
8000
24ec
0001
24ed
8861
24ee
8912
24ef
8612
24f0
0001
24f1
8461
24f2
7c20
24f3
2026
24f4
1b01
24f5
1f01
24f6
68c1
24f7
0004
24f8
38c1
24f9
68e1
24fa
0003
24fb
3ce1
24fc
7ed0
24fd
8000
24fe
0001
24ff
7ef1
2500
8000
2501
0001
2502
7f81
2503
2535
2504
7ed1
2505
8000
2506
0001
2507
7ef0
2508
8000
2509
0001
250a
7f81
250b
2538
250c
7ed0
250d
8000
250e
0001
250f
3dd4
2510
7f81
2511
2535
2512
7ed0
2513
8000
2514
0001
2515
3dd6
2516
7f81
2517
2538
2518
7ed1
2519
8000
251a
0001
251b
3dd4
251c
7f81
251d
2538
251e
7ed1
251f
8000
2520
0001
2521
3dd6
2522
7f81
2523
2535
2524
187e
2525
2c62
2526
3dd4
2527
7f81
2528
2538
2529
3dd6
252a
7f81
252b
2535
252c
0cd3
252d
7f9e
252e
2526
252f
0c63
2530
60e1
2531
60c1
2532
6321
2533
6321
2534
6381
2535
8061
2536
7f81
2537
2530
2538
8861
2539
7f81
253a
2530
253b
8f01
253c
8b01
253d
7c20
253e
2039
253f
5701
2540
000a
2541
7c20
2542
24c3
2543
0ea1
2544
ffff
2545
5701
2546
000b
2547
5701
2548
ffff
2549
7c20
254a
254d
254b
7c20
254c
2026
254d
8f01
254e
8b01
254f
7c20
2550
2039
2551
5401
2552
000b
2553
2001
2554
00c1
2555
20c2
2556
5421
2557
000a
2558
2421
2559
04e1
255a
24e2
255b
8841
255c
3881
255d
3c82
255e
7461
255f
1301
2560
0c9f
2561
4061
2562
0001
2563
c06e
2564
00d4
2565
3861
2566
0c82
2567
4461
2568
0001
2569
c06e
256a
04f4
256b
3c61
256c
0c82
256d
7461
256e
1301
256f
8842
2570
1816
2571
7f81
2572
2560
2573
1c36
2574
7f81
2575
2560
2576
0b01
2577
7f01
2578
0020
2579
7c20
257a
2770
257b
0ea1
257c
ffff
257d
2cde
257e
1842
257f
61de
2580
08d3
2581
7f81
2582
257f
2583
5701
2584
ffff
2585
7c20
2586
2716
2587
7c20
2588
2026
2589
8f01
258a
8f01
258b
7c20
258c
2039
258d
5701
258e
000a
258f
7c20
2590
24df
2591
8472
2592
7f81
2593
25c3
2594
8072
2595
7f81
2596
25bf
2597
5701
2598
000a
2599
7c20
259a
22bc
259b
0c41
259c
56a1
259d
000b
259e
ffff
259f
7ea1
25a0
02a7
25a1
fffe
25a2
8452
25a3
7f81
25a4
25bb
25a5
8851
25a6
7f81
25a7
25b0
25a8
5701
25a9
fffe
25aa
5701
25ab
ffff
25ac
7c20
25ad
25c7
25ae
0ea1
25af
fffe
25b0
5701
25b1
ffff
25b2
5701
25b3
ffff
25b4
7c20
25b5
25c7
25b6
0ea1
25b7
ffff
25b8
8c46
25b9
7f81
25ba
25a2
25bb
5461
25bc
fffe
25bd
7f81
25be
2026
25bf
7c61
25c0
02a3
25c1
7f81
25c2
2026
25c3
7c61
25c4
02a7
25c5
7f81
25c6
2026
25c7
8f01
25c8
9301
25c9
7c20
25ca
2039
25cb
5701
25cc
000b
25cd
7c20
25ce
24ab
25cf
0ea1
25d0
ffff
25d1
2c01
25d2
00c1
25d3
20c2
25d4
5701
25d5
000a
25d6
7c20
25d7
24ab
25d8
0ea1
25d9
fffe
25da
2c21
25db
04e1
25dc
24e2
25dd
2041
25de
2442
25df
0b01
25e0
7f01
25e1
0020
25e2
7c20
25e3
2770
25e4
0ea1
25e5
fffd
25e6
2c41
25e7
2842
25e8
3c61
25e9
3864
25ea
7481
25eb
0d42
25ec
125a
25ed
ffff
25ee
7461
25ef
0881
25f0
8c83
25f1
8472
25f2
7f81
25f3
25f9
25f4
0d82
25f5
7461
25f6
8883
25f7
7f81
25f8
25f1
25f9
88e3
25fa
8843
25fb
04f3
25fc
7f81
25fd
25e8
25fe
24e2
25ff
2442
2600
88c3
2601
8843
2602
00d3
2603
7f81
2604
25e8
2605
5701
2606
fffd
2607
7c20
2608
2716
2609
0ea1
260a
fffd
260b
5701
260c
000a
260d
7c20
260e
24df
260f
0c01
2610
5701
2611
000b
2612
7c20
2613
24df
2614
0c0c
2615
5461
2616
fffd
2617
7c11
2618
8000
2619
7c20
261a
2026
261b
5701
261c
fffd
261d
7c20
261e
24c3
261f
7c20
2620
2026
2621
6b01
2622
0002
2623
6b01
2624
0002
2625
7c20
2626
2639
2627
2c61
2628
4c61
2629
0001
262a
6321
262b
6321
262c
6381
262d
6b01
262e
0002
262f
6b01
2630
0002
2631
7c20
2632
2639
2633
2c61
2634
4c61
2635
0002
2636
6321
2637
6321
2638
6381
2639
8f01
263a
9301
263b
7c20
263c
2039
263d
5701
263e
000b
263f
7c20
2640
24ab
2641
0ea1
2642
ffff
2643
2c01
2644
5701
2645
000a
2646
7c20
2647
24ab
2648
0ea1
2649
fffe
264a
2c21
264b
2041
264c
2134
264d
2441
264e
5701
264f
ffff
2650
0b01
2651
7c20
2652
274d
2653
0ea1
2654
ffff
2655
2c01
2656
5701
2657
fffe
2658
0b01
2659
7c20
265a
274d
265b
0ea1
265c
fffe
265d
2c21
265e
0b01
265f
7f01
2660
0020
2661
7c20
2662
2770
2663
0ea1
2664
fffd
2665
2c41
2666
8912
2667
8932
2668
7f81
2669
26a6
266a
8932
266b
7e31
266c
ff00
266d
0001
266e
7f81
266f
26b1
2670
2081
2671
948f
2672
8492
2673
7f81
2674
26d8
2675
8883
2676
08c1
2677
0861
2678
2862
2679
8acf
267a
0001
267b
08d3
267c
75cb
267d
88c2
267e
0cd3
267f
7f81
2680
2679
2681
00c1
2682
00e1
2683
20e2
2684
8acf
2685
0001
2686
00d2
2687
756b
2688
00d3
2689
75cb
268a
88c2
268b
1cd3
268c
7f81
268d
2684
268e
08c1
268f
04e1
2690
0c7e
2691
3dd6
2692
7f81
2693
2672
2694
3dd2
2695
0cd3
2696
7f81
2697
2690
2698
08c1
2699
28c2
269a
04e1
269b
24e2
269c
3ddb
269d
0c7f
269e
08d3
269f
7f81
26a0
269c
26a1
0061
26a2
2062
26a3
896b
26a4
7f81
26a5
2672
26a6
4241
26a7
0001
26a8
0001
26a9
4606
26aa
0001
26ab
0001
26ac
4648
26ad
0001
26ae
0001
26af
7f81
26b0
26e4
26b1
54c1
26b2
ffff
26b3
38c1
26b4
1861
26b5
2c62
26b6
88c2
26b7
5481
26b8
fffe
26b9
3081
26ba
5081
26bb
0001
26bc
8421
26bd
a42f
26be
3801
26bf
a40d
26c0
040b
26c1
0021
26c2
1006
26c3
1028
26c4
a40f
26c5
0041
26c6
a42f
26c7
3801
26c8
7c0a
26c9
00ff
26ca
040b
26cb
0021
26cc
1006
26cd
1028
26ce
004b
26cf
09c1
26d0
0cd3
26d1
7f9e
26d2
26bd
26d3
5461
26d4
fffd
26d5
2c61
26d6
2c62
26d7
0561
26d8
5701
26d9
ffff
26da
7c20
26db
2716
26dc
0ea1
26dd
ffff
26de
5701
26df
fffd
26e0
7c20
26e1
2716
26e2
0ea1
26e3
fffd
26e4
54c1
26e5
000b
26e6
38c1
26e7
58c1
26e8
0001
26e9
54e1
26ea
000a
26eb
3ce1
26ec
5ce1
26ed
0001
26ee
1ccc
26ef
7cd1
26f0
8000
26f1
7f81
26f2
2701
26f3
5701
26f4
ffff
26f5
7c20
26f6
24c3
26f7
0ea1
26f8
ffff
26f9
5701
26fa
fffe
26fb
5701
26fc
fffd
26fd
7c20
26fe
253b
26ff
0ea1
2700
fffd
2701
7cf1
2702
8000
2703
7f81
2704
270b
2705
5701
2706
fffd
2707
7c20
2708
24c3
2709
0ea1
270a
fffd
270b
8f01
270c
9701
270d
7c20
270e
2770
270f
2cde
2710
55de
2711
ffff
2712
55c1
2713
fffd
2714
7c20
2715
2026
2716
8b01
2717
8b01
2718
7c20
2719
2039
271a
5421
271b
000a
271c
2401
271d
00c1
271e
2002
271f
88c2
2720
00d2
2721
7f81
2722
272f
2723
81d2
2724
7ed0
2725
8000
2726
0001
2727
7f81
2728
271f
2729
85d2
272a
7ed1
272b
8000
272c
0001
272d
7f81
272e
271f
272f
8802
2730
0041
2731
1843
2732
24c3
2733
0461
2734
2421
2735
0932
2736
7c20
2737
2026
2738
0b01
2739
7f01
273a
0020
273b
7c20
273c
2770
273d
0ea1
273e
ffff
273f
5401
2740
000a
2741
2001
2742
00c2
2743
2002
2744
8802
2745
2ce1
2746
88e2
2747
39fe
2748
00d3
2749
7f81
274a
2747
274b
7c20
274c
2026
274d
0301
274e
1b01
274f
1f01
2750
6b01
2751
0004
2752
7f01
2753
0020
2754
7c20
2755
2770
2756
2ce1
2757
3ce2
2758
6801
2759
0005
275a
20c1
275b
38c2
275c
39ff
275d
20d4
275e
7f81
275f
275c
2760
2cf2
2761
7f81
2762
276a
2763
5801
2764
0001
2765
c00e
2766
01ff
2767
2cf4
2768
7f81
2769
2766
276a
60e1
276b
60c1
276c
6001
276d
6321
276e
6321
276f
6381
#include "integer.dasm16"
admiral.dasm16
9
419
2770
6b01
2771
0002
2772
8b22
2773
6b01
2774
0002
2775
7c20
2776
21d3
2777
0f01
2778
2c61
2779
6961
277a
0003
277b
6061
277c
6321
277d
6321
277e
6381
277f
7c20
2780
27a1
2781
8473
2782
2c61
2783
6381
2784
7c20
2785
27a1
2786
8472
2787
7c20
2788
00c6
2789
0961
278a
6381
278b
7c20
278c
27a1
278d
8472
278e
7c20
278f
00c6
2790
1b01
2791
1f01
2792
0cc1
2793
0ce1
2794
88e2
2795
2061
2796
8963
2797
2c62
2798
0cd4
2799
7f81
279a
279e
279b
3dc1
279c
7f9e
279d
2798
279e
60e1
279f
60c1
27a0
6381
27a1
0301
27a2
2001
27a3
0461
27a4
7c30
27a5
8000
27a6
2062
27a7
7c70
27a8
8000
27a9
7f81
27aa
27b2
27ab
8862
27ac
2074
27ad
7f81
27ae
27b2
27af
0062
27b0
6001
27b1
6381
27b2
6001
27b3
8461
27b4
6381
27b5
9301
27b6
8701
27b7
7c20
27b8
2039
27b9
5401
27ba
000c
27bb
2041
27bc
5421
27bd
000b
27be
7c30
27bf
8000
27c0
2822
27c1
7c30
27c2
8000
27c3
8421
27c4
2834
27c5
2821
27c6
7c20
27c7
2803
27c8
20c1
27c9
38c2
27ca
20e1
27cb
3ce2
27cc
88e3
27cd
2022
27ce
04f2
27cf
7f81
27d0
27d4
27d1
3dc1
27d2
7f9f
27d3
27ce
27d4
55c1
27d5
000a
27d6
7c20
27d7
2026
27d8
0301
27d9
6801
27da
0003
27db
7c20
27dc
2803
27dd
2001
27de
2002
27df
6901
27e0
0002
27e1
6001
27e2
6861
27e3
0002
27e4
6321
27e5
6321
27e6
6381
27e7
0301
27e8
0701
27e9
6801
27ea
0003
27eb
2061
27ec
2f01
27ed
0423
27ee
6432
27ef
7f81
27f0
27fb
27f1
7c20
27f2
277f
27f3
6b01
27f4
0005
27f5
0f01
27f6
7c20
27f7
27d8
27f8
8822
27f9
7f81
27fa
27ee
27fb
6861
27fc
0005
27fd
8b62
27fe
6021
27ff
6001
2800
6321
2801
6321
2802
6381
2803
2061
2804
8962
2805
4176
2806
0002
2807
6381
2808
0301
2809
2f01
280a
ab22
280b
7c20
280c
2185
280d
6381
280e
9301
280f
8b01
2810
7c20
2811
2039
2812
5401
2813
000c
2814
2021
2815
54e1
2816
000b
2817
84f7
2818
24e2
2819
84f7
281a
1cec
281b
5441
281c
000a
281d
8457
281e
2442
281f
8457
2820
084c
2821
2455
2822
2441
2823
08f5
2824
08e1
2825
0881
2826
1c83
2827
1301
2828
4301
2829
0001
282a
7c20
282b
2770
282c
0ea1
282d
ffff
282e
2021
282f
04e2
2830
0442
2831
2cc1
2832
11c1
2833
08f2
2834
7c20
2835
2026
2836
5ede
2837
0001
2838
0001
2839
7f81
283a
2833
283b
8f01
283c
8b01
283d
7c20
283e
2039
283f
5401
2840
000b
2841
5421
2842
000a
2843
2041
2844
2841
2845
2461
2846
2c42
2847
0b01
2848
4301
2849
0001
284a
7c20
284b
2770
284c
0ea1
284d
ffff
284e
20c1
284f
2041
2850
2842
2851
2cfe
2852
08d4
2853
7f81
2854
2858
2855
39fe
2856
7f81
2857
2852
2858
24c1
2859
88c2
285a
2441
285b
2842
285c
08d4
285d
7c20
285e
2026
285f
39fe
2860
7f81
2861
285c
2862
9301
2863
8701
2864
7c20
2865
2039
2866
54c1
2867
000c
2868
38c1
2869
1801
286a
2002
286b
54e1
286c
000b
286d
3ce1
286e
1c3e
286f
2422
2870
00d4
2871
7f81
2872
287f
2873
04f4
2874
7f81
2875
2884
2876
3b01
2877
3f01
2878
5420
2879
000a
287a
8472
287b
7f9e
287c
2870
287d
7c20
287e
2026
287f
8061
2880
04f4
2881
8461
2882
7c20
2883
2026
2884
8861
2885
7c20
2886
2026
2887
8f01
2888
8701
2889
7c20
288a
2039
288b
5701
288c
000a
288d
7c20
288e
22bc
288f
0c41
2890
7c50
2891
8000
2892
8441
2893
5401
2894
000b
2895
2021
2896
2481
2897
0884
2898
1301
2899
4301
289a
0001
289b
7c20
289c
2770
289d
2ce1
289e
3ce2
289f
20c1
28a0
2cf2
28a1
7c20
28a2
2026
28a3
20d2
28a4
38c2
28a5
39ff
28a6
7f81
28a7
28a0
28a8
8f01
28a9
8701
28aa
7c20
28ab
2039
28ac
5401
28ad
000b
28ae
5421
28af
000a
28b0
2001
28b1
0041
28b2
2042
28b3
8802
28b4
0812
28b5
7c20
28b6
2026
28b7
0081
28b8
00fe
28b9
08f4
28ba
7f81
28bb
28c5
28bc
3f01
28bd
3301
28be
0420
28bf
8472
28c0
7f9e
28c1
28b9
28c2
1c81
28c3
7f9e
28c4
28b9
28c5
3061
28c6
2181
28c7
0d01
28c8
7f9e
28c9
28b3
28ca
0301
28cb
1b01
28cc
1f01
28cd
6801
28ce
0004
28cf
2061
28d0
2f01
28d1
4301
28d2
0001
28d3
7c20
28d4
2770
28d5
2ce1
28d6
20de
28d7
2001
28d8
2002
28d9
00d4
28da
7f81
28db
28df
28dc
39e1
28dd
7f9e
28de
28d9
28df
60e1
28e0
60c1
28e1
6001
28e2
6321
28e3
6381
28e4
0301
28e5
0701
28e6
6801
28e7
0004
28e8
2001
28e9
0021
28ea
2002
28eb
8822
28ec
0034
28ed
7f81
28ee
28f4
28ef
2701
28f0
6820
28f1
0004
28f2
7f81
28f3
28eb
28f4
6021
28f5
6001
28f6
6321
28f7
6321
28f8
6381
28f9
8f01
28fa
8701
28fb
7c20
28fc
2039
28fd
5401
28fe
000b
28ff
5421
2900
000a
2901
2081
2902
10fe
2903
3082
2904
84c1
2905
8061
2906
10f4
2907
7f81
2908
2026
2909
3f01
290a
0701
290b
7c20
290c
1dc0
290d
8473
290e
7f9e
290f
2905
2910
1861
2911
7c20
2912
2026
#include "array.dasm16"
admiral.dasm16
10
129
2913
8f01
2914
8701
2915
7c20
2916
2039
2917
5401
2918
000b
2919
5701
291a
000a
291b
7c20
291c
22bc
291d
0c21
291e
7c20
291f
277f
2920
7c20
2921
2026
2922
9301
2923
8701
2924
7c20
2925
2039
2926
5401
2927
000c
2928
5701
2929
000b
292a
7c20
292b
22bc
292c
0c21
292d
5441
292e
000a
292f
7c20
2930
2784
2931
7c20
2932
2026
2933
8f01
2934
8701
2935
7c20
2936
2039
2937
5401
2938
000b
2939
8e11
293a
0001
293b
7c20
293c
00c6
293d
5701
293e
000a
293f
7c20
2940
22bc
2941
0c21
2942
7c20
2943
278b
2944
7c20
2945
2026
2946
6701
2947
7f41
2948
1dc0
2949
0001
294a
7f81
294b
2862
294c
8b01
294d
8f01
294e
7c20
294f
2039
2950
5481
2951
000a
2952
af01
2953
a701
2954
7c20
2955
21d3
2956
0ea1
2957
ffff
2958
0f01
2959
9692
295a
0001
295b
7f01
295c
0028
295d
8e92
295e
0001
295f
7f01
2960
005b
2961
7c20
2962
27d8
2963
84c1
2964
3021
2965
2421
2966
04d2
2967
7f81
2968
2984
2969
84d2
296a
7f81
296b
2972
296c
5701
296d
ffff
296e
7f01
296f
002c
2970
7c20
2971
27d8
2972
3061
2973
1862
2974
4f01
2975
0001
2976
7c20
2977
2086
2978
0ea1
2979
fffe
297a
5701
297b
ffff
297c
5701
297d
fffe
297e
7c20
297f
283b
2980
0ea1
2981
ffff
2982
7f9e
2983
2966
2984
5701
2985
ffff
2986
9692
2987
0001
2988
7f01
2989
0029
298a
8e92
298b
0001
298c
7f01
298d
005d
298e
7c20
298f
27d8
2990
5461
2991
ffff
2992
7c20
2993
2026
#include "list.dasm16"
admiral.dasm16
11
589
2994
6701
2995
7f41
2996
299a
2997
0001
2998
7f81
2999
2862
299a
8461
299b
6b56
299c
0001
299d
0002
299e
8061
299f
6b54
29a0
0001
29a1
0002
29a2
8861
29a3
6321
29a4
6321
29a5
6381
29a6
6701
29a7
7f41
29a8
29ac
29a9
0001
29aa
7f81
29ab
2862
29ac
7f54
29ad
0040
29ae
0002
29af
7f56
29b0
005b
29b1
0002
29b2
7f42
29b3
0020
29b4
0002
29b5
7f54
29b6
0040
29b7
0001
29b8
7f56
29b9
005b
29ba
0001
29bb
7f42
29bc
0020
29bd
0001
29be
7f81
29bf
299a
29c0
9701
29c1
8701
29c2
7c20
29c3
2039
29c4
5401
29c5
000d
29c6
2001
29c7
5461
29c8
000b
29c9
8477
29ca
2062
29cb
8477
29cc
0c63
29cd
2075
29ce
2061
29cf
5701
29d0
000a
29d1
8737
29d2
2322
29d3
8737
29d4
6723
29d5
2335
29d6
2321
29d7
5421
29d8
000c
29d9
2421
29da
0481
29db
2482
29dc
7f81
29dd
29ec
29de
8f01
29df
8701
29e0
7c20
29e1
2039
29e2
8461
29e3
5401
29e4
000b
29e5
2001
29e6
2301
29e7
5421
29e8
000a
29e9
2421
29ea
0481
29eb
2482
29ec
0c41
29ed
2442
29ee
6454
29ef
7f81
29f0
2a00
29f1
00c1
29f2
0cc2
29f3
04e1
29f4
5ed2
29f5
0001
29f6
0001
29f7
10f6
29f8
7f9e
29f9
29f4
29fa
10f2
29fb
7c20
29fc
2026
29fd
8862
29fe
7f81
29ff
29ec
2a00
8061
2a01
7c20
2a02
2026
2a03
7c20
2a04
10e2
2a05
84d3
2a06
7c20
2a07
00c6
2a08
20c1
2a09
85d2
2a0a
7f81
2a0b
2181
2a0c
38c2
2a0d
20d2
2a0e
7f81
2a0f
217d
2a10
7dd4
2a11
0040
2a12
7dd6
2a13
005b
2a14
7f9f
2a15
2a0d
2a16
7dd4
2a17
0060
2a18
7dd6
2a19
007b
2a1a
7f9f
2a1b
2a0d
2a1c
7f81
2a1d
2181
2a1e
7c20
2a1f
10e2
2a20
84d3
2a21
7c20
2a22
00c6
2a23
20c1
2a24
85d2
2a25
7f81
2a26
2181
2a27
38c2
2a28
20d2
2a29
7f81
2a2a
217d
2a2b
7dd4
2a2c
002f
2a2d
7dd6
2a2e
003a
2a2f
7f9f
2a30
2a28
2a31
7f81
2a32
2181
2a33
7c20
2a34
10e2
2a35
84d3
2a36
7c20
2a37
00c6
2a38
0301
2a39
7c20
2a3a
28ca
2a3b
2cc1
2a3c
38c2
2a3d
2cd2
2a3e
7f81
2a3f
2026
2a40
7dd4
2a41
0040
2a42
7dd6
2a43
005b
2a44
7dc2
2a45
0020
2a46
7f9f
2a47
2a3d
2a48
7f81
2a49
2026
2a4a
7c20
2a4b
10e2
2a4c
84d3
2a4d
7c20
2a4e
00c6
2a4f
0301
2a50
7c20
2a51
28ca
2a52
2cc1
2a53
38c2
2a54
2cd2
2a55
7f81
2a56
2026
2a57
7dd4
2a58
0060
2a59
7dd6
2a5a
007b
2a5b
7dc3
2a5c
0020
2a5d
7f9f
2a5e
2a54
2a5f
7c20
2a60
10e2
2a61
0301
2a62
2001
2a63
84d2
2a64
7c20
2a65
00c6
2a66
90d4
2a67
7c20
2a68
00c6
2a69
5461
2a6a
ffff
2a6b
a673
2a6c
0001
2a6d
7c20
2a6e
00c6
2a6f
0f01
2a70
88d2
2a71
7f81
2a72
2a8e
2a73
5461
2a74
fffe
2a75
7e73
2a76
0020
2a77
0001
2a78
7c20
2a79
00c6
2a7a
0f01
2a7b
7c20
2a7c
22bc
2a7d
0f01
2a7e
8cd2
2a7f
7f81
2a80
2a8f
2a81
5461
2a82
fffd
2a83
7e73
2a84
0020
2a85
0001
2a86
7c20
2a87
00c6
2a88
0f01
2a89
7c20
2a8a
22bc
2a8b
0f01
2a8c
7f81
2a8d
2a90
2a8e
8701
2a8f
2301
2a90
7c20
2a91
29c0
2a92
0f01
2a93
7c61
2a94
029f
2a95
7f31
2a96
8000
2a97
7c20
2a98
22a2
2a99
7f81
2a9a
2026
2a9b
7c81
2a9c
2acf
2a9d
7f81
2a9e
2aa1
2a9f
7c81
2aa0
2ac3
2aa1
7c20
2aa2
10e2
2aa3
88d3
2aa4
7c20
2aa5
00c6
2aa6
5421
2aa7
ffff
2aa8
a630
2aa9
0001
2aaa
7f81
2aab
2ac0
2aac
9e30
2aad
0001
2aae
7f81
2aaf
2ab2
2ab0
7c20
2ab1
00c6
2ab2
2441
2ab3
08c1
2ab4
38c2
2ab5
08d2
2ab6
7f81
2ab7
2181
2ab8
3821
2ab9
a633
2aba
0001
2abb
7c20
2abc
00c6
2abd
1020
2abe
7f9f
2abf
2ab5
2ac0
1020
2ac1
7f81
2ac2
2181
2ac3
0301
2ac4
0701
2ac5
8701
2ac6
2461
2ac7
2f01
2ac8
7c20
2ac9
29c0
2aca
8472
2acb
7f81
2acc
217d
2acd
8461
2ace
6381
2acf
0301
2ad0
0701
2ad1
2461
2ad2
2f01
2ad3
832c
2ad4
8b22
2ad5
7f01
2ad6
7fff
2ad7
7c20
2ad8
29c0
2ad9
8073
2ada
7f81
2adb
217d
2adc
8461
2add
6381
2ade
7c20
2adf
10e2
2ae0
88d3
2ae1
7c20
2ae2
00c6
2ae3
0301
2ae4
7c20
2ae5
28ca
2ae6
0ea1
2ae7
fffe
2ae8
7c81
2ae9
32dd
2aea
7f81
2aeb
2b05
2aec
7c20
2aed
10e2
2aee
88d3
2aef
7c20
2af0
00c6
2af1
0301
2af2
7c20
2af3
28ca
2af4
0ea1
2af5
fffe
2af6
7801
2af7
0255
2af8
0021
2af9
c422
2afa
9423
2afb
5701
2afc
fffe
2afd
2701
2afe
7c20
2aff
27d8
2b00
0034
2b01
7f81
2b02
2afa
2b03
7c81
2b04
3281
2b05
5401
2b06
fffe
2b07
2001
2b08
9503
2b09
2301
2b0a
2002
2b0b
8802
2b0c
5441
2b0d
fffe
2b0e
2841
2b0f
8842
2b10
5421
2b11
ffff
2b12
2421
2b13
a533
2b14
7c20
2b15
00c6
2b16
8822
2b17
1020
2b18
5461
2b19
fffe
2b1a
7c92
2b1b
32dd
2b1c
7f81
2b1d
2026
2b1e
2c01
2b1f
9502
2b20
7f81
2b21
2026
2b22
7c20
2b23
10e2
2b24
8cd3
2b25
7c20
2b26
00c6
2b27
5461
2b28
ffff
2b29
a671
2b2a
0001
2b2b
7c20
2b2c
00c6
2b2d
2c41
2b2e
2841
2b2f
5461
2b30
fffe
2b31
a671
2b32
0001
2b33
7c20
2b34
00c6
2b35
02a1
2b36
fffd
2b37
4301
2b38
0002
2b39
a701
2b3a
7c20
2b3b
21d3
2b3c
0ea1
2b3d
fffc
2b3e
84c1
2b3f
5701
2b40
fffd
2b41
5701
2b42
ffff
2b43
1b01
2b44
7f01
2b45
7fff
2b46
7c20
2b47
29c0
2b48
0ce1
2b49
1cd2
2b4a
7f81
2b4b
2b5c
2b4c
5401
2b4d
fffd
2b4e
1821
2b4f
7c20
2b50
277f
2b51
8472
2b52
7f81
2b53
2b65
2b54
5701
2b55
fffc
2b56
0f01
2b57
7c20
2b58
27d8
2b59
88c2
2b5a
7f81
2b5b
2b49
2b5c
5701
2b5d
fffc
2b5e
5701
2b5f
fffe
2b60
7c20
2b61
27e7
2b62
08c2
2b63
7f81
2b64
2b3f
2b65
5461
2b66
fffc
2b67
7f81
2b68
2026
2b69
7c20
2b6a
10e2
2b6b
02a1
2b6c
fffe
2b6d
af01
2b6e
8f01
2b6f
7c20
2b70
21d3
2b71
0ea1
2b72
fffd
2b73
8421
2b74
84d2
2b75
7f81
2b76
2ba6
2b77
88d3
2b78
7c20
2b79
00c6
2b7a
5461
2b7b
ffff
2b7c
a671
2b7d
0001
2b7e
7c20
2b7f
00c6
2b80
2c41
2b81
2841
2b82
5701
2b83
fffe
2b84
5701
2b85
ffff
2b86
0701
2b87
7f01
2b88
7fff
2b89
7c20
2b8a
29c0
2b8b
0ce1
2b8c
80f2
2b8d
7ce1
2b8e
7fff
2b8f
5701
2b90
fffe
2b91
0701
2b92
1f01
2b93
7c20
2b94
280e
2b95
0ea1
2b96
fffc
2b97
1c21
2b98
5701
2b99
fffd
2b9a
0f01
2b9b
7c20
2b9c
27d8
2b9d
5461
2b9e
fffd
2b9f
7cf2
2ba0
7fff
2ba1
7f81
2ba2
2026
2ba3
0822
2ba4
7f81
2ba5
2b82
2ba6
7c20
2ba7
277f
2ba8
8822
2ba9
8472
2baa
7f81
2bab
2bd3
2bac
7c72
2bad
0020
2bae
7f81
2baf
2bc5
2bb0
c872
2bb1
7f81
2bb2
2bc5
2bb3
0c41
2bb4
86b3
2bb5
ffff
2bb6
7f81
2bb7
2bbe
2bb8
9f01
2bb9
a701
2bba
7c20
2bbb
21d3
2bbc
0ea1
2bbd
ffff
2bbe
5701
2bbf
ffff
2bc0
0b01
2bc1
7c20
2bc2
27d8
2bc3
7f81
2bc4
2ba6
2bc5
86b2
2bc6
ffff
2bc7
7f81
2bc8
2ba6
2bc9
5701
2bca
fffd
2bcb
5701
2bcc
ffff
2bcd
7c20
2bce
27d8
2bcf
86a1
2bd0
ffff
2bd1
7f81
2bd2
2ba6
2bd3
86b2
2bd4
ffff
2bd5
7f81
2bd6
2bdd
2bd7
5701
2bd8
fffd
2bd9
5701
2bda
ffff
2bdb
7c20
2bdc
27d8
2bdd
5461
2bde
fffd
2bdf
7f81
2be0
2026
#include "string2.dasm16"
admiral.dasm16
12
551
2be1
8b01
2be2
8b01
2be3
7c20
2be4
2039
2be5
87c1
2be6
0267
2be7
87c1
2be8
0268
2be9
87c1
2bea
0269
2beb
7c20
2bec
2e10
2bed
7c20
2bee
2ee2
2bef
7f01
2bf0
0400
2bf1
a701
2bf2
7c20
2bf3
21d3
2bf4
0ea1
2bf5
ffff
2bf6
2c61
2bf7
0fc1
2bf8
025f
2bf9
0fc1
2bfa
0261
2bfb
0fc1
2bfc
0265
2bfd
0fc1
2bfe
0263
2bff
0fc1
2c00
0266
2c01
7c62
2c02
0400
2c03
0fc1
2c04
0260
2c05
0fc1
2c06
0262
2c07
5461
2c08
000a
2c09
2c61
2c0a
0c81
2c0b
8882
2c0c
2c62
2c0d
0c94
2c0e
7f81
2c0f
2c16
2c10
3041
2c11
7c20
2c12
2d43
2c13
8882
2c14
7f81
2c15
2c0d
2c16
7c20
2c17
2db5
2c18
7c20
2c19
2ce6
2c1a
7b01
2c1b
0267
2c1c
7b01
2c1d
0268
2c1e
7c20
2c1f
2e28
2c20
7841
2c21
0269
2c22
7c20
2c23
2e21
2c24
7c20
2c25
2103
2c26
7c20
2c27
2e21
2c28
0bc1
2c29
0269
2c2a
7c52
2c2b
0080
2c2c
7f81
2c2d
2c74
2c2e
7c52
2c2f
0081
2c30
7f81
2c31
2c84
2c32
7c52
2c33
0082
2c34
7f81
2c35
2c9c
2c36
7c52
2c37
0083
2c38
7f81
2c39
2ca9
2c3a
d052
2c3b
7f81
2c3c
2cbc
2c3d
c452
2c3e
7f81
2c3f
2cc3
2c40
c852
2c41
7f81
2c42
2cd8
2c43
7c52
2c44
8058
2c45
7f81
2c46
2c52
2c47
7c52
2c48
8043
2c49
7f81
2c4a
2c52
2c4b
e854
2c4c
7c56
2c4d
007f
2c4e
7f81
2c4f
2cd4
2c50
7f81
2c51
2c16
2c52
7c20
2c53
2e08
2c54
5461
2c55
000a
2c56
7c52
2c57
8043
2c58
7f81
2c59
2026
2c5a
7841
2c5b
0260
2c5c
7843
2c5d
025f
2c5e
7842
2c5f
0261
2c60
7843
2c61
0262
2c62
0b01
2c63
a701
2c64
7c20
2c65
2770
2c66
2cfe
2c67
78c1
2c68
025f
2c69
78d2
2c6a
0261
2c6b
78c1
2c6c
0262
2c6d
78d2
2c6e
0260
2c6f
7f81
2c70
2026
2c71
39fe
2c72
7f81
2c73
2c69
2c74
7801
2c75
0266
2c76
7c20
2c77
2d82
2c78
03c1
2c79
0266
2c7a
7821
2c7b
0267
2c7c
7822
2c7d
0264
2c7e
7c20
2c7f
2d99
2c80
03c1
2c81
0265
2c82
7f81
2c83
2c16
2c84
7801
2c85
0265
2c86
7c20
2c87
2d72
2c88
7812
2c89
0260
2c8a
7f81
2c8b
2c16
2c8c
7801
2c8d
0266
2c8e
7c20
2c8f
2d8f
2c90
03c1
2c91
0266
2c92
7821
2c93
0267
2c94
7822
2c95
0264
2c96
7c20
2c97
2d99
2c98
03c1
2c99
0265
2c9a
7f81
2c9b
2c16
2c9c
7bd2
2c9d
0262
2c9e
0265
2c9f
7bc1
2ca0
0261
2ca1
0265
2ca2
7bd4
2ca3
025f
2ca4
0265
2ca5
8bc3
2ca6
0265
2ca7
7f81
2ca8
2c16
2ca9
7bd2
2caa
0261
2cab
0265
2cac
7bc1
2cad
0262
2cae
0265
2caf
7bd6
2cb0
0260
2cb1
0265
2cb2
8bc2
2cb3
0265
2cb4
7bd2
2cb5
0261
2cb6
0265
2cb7
7bc1
2cb8
0262
2cb9
0265
2cba
7f81
2cbb
2c16
2cbc
7bd6
2cbd
0260
2cbe
0265
2cbf
7c20
2cc0
2d4f
2cc1
7f81
2cc2
2c16
2cc3
7bd2
2cc4
0262
2cc5
0265
2cc6
7bc1
2cc7
0261
2cc8
0265
2cc9
7bd2
2cca
025f
2ccb
0265
2ccc
7f81
2ccd
2c16
2cce
8bc3
2ccf
0265
2cd0
7c20
2cd1
2d4f
2cd2
7f81
2cd3
2c16
2cd4
7c20
2cd5
2d43
2cd6
7f81
2cd7
2c16
2cd8
7c20
2cd9
2d43
2cda
7821
2cdb
0266
2cdc
7c41
2cdd
0020
2cde
0933
2cdf
7f81
2ce0
2c16
2ce1
7c20
2ce2
2d43
2ce3
8822
2ce4
7f81
2ce5
2cde
2ce6
7801
2ce7
023a
2ce8
78c1
2ce9
0263
2cea
20e1
2ceb
7c20
2cec
2cf2
2ced
40f6
2cee
0001
2cef
7f81
2cf0
2ceb
2cf1
6381
2cf2
8441
2cf3
78d2
2cf4
0261
2cf5
78c1
2cf6
0262
2cf7
7852
2cf8
0264
2cf9
7f81
2cfa
2d06
2cfb
78d2
2cfc
0260
2cfd
7f81
2cfe
2d06
2cff
c9d2
2d00
7f81
2d01
2d06
2d02
88c2
2d03
8842
2d04
7f81
2d05
2cf3
2d06
1c41
2d07
7c42
2d08
0020
2d09
85e1
2d0a
78d2
2d0b
0260
2d0c
7f81
2d0d
2d19
2d0e
c9d2
2d0f
7f81
2d10
2d19
2d11
39e1
2d12
7deb
2d13
7000
2d14
88c2
2d15
78d2
2d16
0261
2d17
78c1
2d18
0262
2d19
88e2
2d1a
08f6
2d1b
7f81
2d1c
2d09
2d1d
7c41
2d1e
2d1f
2d1f
78d2
2d20
0260
2d21
6381
2d22
c9d2
2d23
6041
2d24
88c2
2d25
78d2
2d26
0261
2d27
78c1
2d28
0262
2d29
0b81
2d2a
78c1
2d2b
0261
2d2c
78e1
2d2d
0262
2d2e
78f6
2d2f
0265
2d30
3dde
2d31
78d4
2d32
0265
2d33
5aff
2d34
ffff
2d35
ffff
2d36
78d3
2d37
0265
2d38
78f3
2d39
0265
2d3a
7f81
2d3b
2d2e
2d3c
1bc1
2d3d
0261
2d3e
1fc1
2d3f
0262
2d40
1fc1
2d41
0265
2d42
6381
2d43
7bd2
2d44
0262
2d45
0261
2d46
6381
2d47
7c20
2d48
2d2a
2d49
7801
2d4a
0261
2d4b
0901
2d4c
8bc2
2d4d
0261
2d4e
6381
2d4f
7bd2
2d50
0260
2d51
0265
2d52
6381
2d53
7bd2
2d54
025f
2d55
0261
2d56
7bd2
2d57
0260
2d58
0262
2d59
6381
2d5a
7c20
2d5b
2d2a
2d5c
8bc2
2d5d
0262
2d5e
8bc2
2d5f
0265
2d60
6381
2d61
7812
2d62
0262
2d63
7801
2d64
0261
2d65
7812
2d66
025f
2d67
6381
2d68
8803
2d69
c913
2d6a
7f81
2d6b
2d61
2d6c
8802
2d6d
7812
2d6e
0261
2d6f
7801
2d70
0262
2d71
6381
2d72
7812
2d73
0261
2d74
7801
2d75
0262
2d76
7812
2d77
0260
2d78
6381
2d79
c912
2d7a
6381
2d7b
8802
2d7c
7812
2d7d
0261
2d7e
7801
2d7f
0262
2d80
7f81
2d81
2d72
2d82
7c20
2d83
2d61
2d84
7812
2d85
025f
2d86
6381
2d87
7812
2d88
0262
2d89
7801
2d8a
0261
2d8b
8803
2d8c
7c20
2d8d
2d61
2d8e
6381
2d8f
7c20
2d90
2d72
2d91
7816
2d92
0260
2d93
8802
2d94
7812
2d95
0261
2d96
7801
2d97
0262
2d98
6381
2d99
8432
2d9a
6381
2d9b
7812
2d9c
0260
2d9d
6381
2d9e
c912
2d9f
6381
2da0
8823
2da1
8802
2da2
7812
2da3
0261
2da4
7801
2da5
0262
2da6
7f81
2da7
2d99
2da8
8441
2da9
0412
2daa
6381
2dab
7812
2dac
0261
2dad
7801
2dae
0262
2daf
0412
2db0
6381
2db1
8842
2db2
8802
2db3
7f81
2db4
2dab
2db5
7801
2db6
0265
2db7
7c20
2db8
2d61
2db9
03c1
2dba
0266
2dbb
7bd2
2dbc
0263
2dbd
0266
2dbe
7f81
2dbf
2dcd
2dc0
7bd4
2dc1
0263
2dc2
0266
2dc3
7f81
2dc4
2dcd
2dc5
7801
2dc6
0263
2dc7
7c20
2dc8
2d82
2dc9
03c1
2dca
0263
2dcb
7f81
2dcc
2dbb
2dcd
87c1
2dce
0268
2dcf
7801
2dd0
0263
2dd1
7812
2dd2
0266
2dd3
7f81
2dd4
2ddb
2dd5
7c20
2dd6
2d8f
2dd7
8bc2
2dd8
0268
2dd9
7f81
2dda
2dd1
2ddb
7801
2ddc
0263
2ddd
b7d6
2dde
0268
2ddf
7f81
2de0
2de7
2de1
7c20
2de2
2d8f
2de3
8bc3
2de4
0268
2de5
7f81
2de6
2ddd
2de7
03c1
2de8
0263
2de9
7801
2dea
0266
2deb
7821
2dec
0265
2ded
7c20
2dee
2da8
2def
7843
2df0
0264
2df1
0bc1
2df2
0267
2df3
7fd1
2df4
8000
2df5
0267
2df6
7f81
2df7
2dfe
2df8
a7c2
2df9
0267
2dfa
a7c3
2dfb
0264
2dfc
7f81
2dfd
2df3
2dfe
7fd6
2dff
0020
2e00
0267
2e01
6381
2e02
a7c3
2e03
0267
2e04
a7c2
2e05
0264
2e06
7f81
2e07
2dfe
#include "edit.dasm16"
admiral.dasm16
13
294
2e08
7fd2
2e09
023b
2e0a
023a
2e0b
6381
2e0c
93c3
2e0d
023a
2e0e
7f81
2e0f
2e16
2e10
7fd2
2e11
0241
2e12
023a
2e13
6381
2e14
93c2
2e15
023a
2e16
0301
2e17
0701
2e18
8401
2e19
7821
2e1a
023a
2e1b
2421
2e1c
7a40
2e1d
0250
2e1e
6021
2e1f
6001
2e20
6381
2e21
7861
2e22
023a
2e23
4c61
2e24
0002
2e25
7d6c
2e26
ff80
2e27
6381
2e28
7861
2e29
023a
2e2a
2e61
2e2b
0002
2e2c
7f44
2e2d
0020
2e2e
0001
2e2f
6a62
2e30
0001
2e31
0002
2e32
6a62
2e33
0002
2e34
0002
2e35
6321
2e36
6321
2e37
6381
2e38
8f01
2e39
8701
2e3a
7c20
2e3b
2039
2e3c
86b2
2e3d
000a
2e3e
86b2
2e3f
000b
2e40
7f81
2e41
2026
2e42
7eb5
2e43
0020
2e44
000b
2e45
7ea1
2e46
0020
2e47
000b
2e48
7eb7
2e49
ffe0
2e4a
000b
2e4b
7ea1
2e4c
ffe0
2e4d
000b
2e4e
b6b5
2e4f
000a
2e50
b6a1
2e51
000a
2e52
7eb7
2e53
fff4
2e54
000a
2e55
7ea1
2e56
fff4
2e57
000a
2e58
8821
2e59
86b5
2e5a
000a
2e5b
8021
2e5c
86b2
2e5d
000a
2e5e
86b5
2e5f
000b
2e60
8021
2e61
0c63
2e62
5463
2e63
000b
2e64
1083
2e65
5483
2e66
000a
2e67
0843
2e68
7801
2e69
023a
2e6a
20c1
2e6b
10e1
2e6c
7ce5
2e6d
0020
2e6e
0ce2
2e6f
18e2
2e70
8832
2e71
7f81
2e72
2e7a
2e73
7cc2
2e74
017f
2e75
7ce2
2e76
017f
2e77
7c62
2e78
001f
2e79
b082
2e7a
8401
2e7b
8075
2e7c
7c77
2e7d
0020
2e7e
8095
2e7f
b497
2e80
3c01
2e81
01c1
2e82
0462
2e83
04c2
2e84
04e2
2e85
8842
2e86
7c52
2e87
0180
2e88
7f81
2e89
2026
2e8a
0801
2e8b
7c08
2e8c
0020
2e8d
8413
2e8e
7f81
2e8f
2e7a
2e90
0482
2e91
0401
2e92
7c05
2e93
0020
2e94
0063
2e95
7f81
2e96
2e7a
2e97
7f44
2e98
0020
2e99
0001
2e9a
6b42
2e9b
0002
2e9c
0001
2e9d
7861
2e9e
023a
2e9f
2f42
2ea0
0001
2ea1
6861
2ea2
0001
2ea3
2c61
2ea4
7c6a
2ea5
007f
2ea6
6321
2ea7
6321
2ea8
6381
2ea9
7f44
2eaa
0020
2eab
0002
2eac
6b42
2ead
0003
2eae
0002
2eaf
7861
2eb0
023a
2eb1
2f42
2eb2
0002
2eb3
7f4b
2eb4
7000
2eb5
0001
2eb6
6861
2eb7
0002
2eb8
6961
2eb9
0001
2eba
6321
2ebb
6321
2ebc
6321
2ebd
6381
2ebe
8701
2ebf
8b01
2ec0
7c20
2ec1
2039
2ec2
7821
2ec3
023a
2ec4
4401
2ec5
0002
2ec6
2403
2ec7
8f01
2ec8
9701
2ec9
7c20
2eca
2770
2ecb
0ea1
2ecc
ffff
2ecd
2c21
2ece
0041
2ecf
7c48
2ed0
0020
2ed1
0b01
2ed2
7c20
2ed3
22a2
2ed4
0e21
2ed5
0001
2ed6
0041
2ed7
7c46
2ed8
0020
2ed9
0b01
2eda
7c20
2edb
22a2
2edc
0e21
2edd
0002
2ede
5461
2edf
ffff
2ee0
7f81
2ee1
2026
2ee2
0301
2ee3
1b01
2ee4
1f01
2ee5
7801
2ee6
023a
2ee7
2201
2ee8
0002
2ee9
20c1
2eea
4001
2eeb
0001
2eec
85c1
2eed
00d6
2eee
7f9e
2eef
2eec
2ef0
60e1
2ef1
60c1
2ef2
6001
2ef3
6381
2ef4
0301
2ef5
1b01
2ef6
1f01
2ef7
7801
2ef8
023a
2ef9
40c1
2efa
0002
2efb
7e52
2efc
1bcc
2efd
0721
2efe
7f81
2eff
2f08
2f00
c452
2f01
7f81
2f02
2f27
2f03
09c1
2f04
7dcb
2f05
7000
2f06
7f9e
2f07
2f0c
2f08
7cca
2f09
ffe0
2f0a
7cc2
2f0b
0020
2f0c
1a01
2f0d
0002
2f0e
40d6
2f0f
0001
2f10
7f81
2f11
2f23
2f12
7e03
2f13
0020
2f14
0002
2f15
20c1
2f16
20e1
2f17
7ce2
2f18
0020
2f19
3dde
2f1a
40f6
2f1b
0001
2f1c
7f81
2f1d
2f19
2f1e
85de
2f1f
40d6
2f20
0001
2f21
7f81
2f22
2f1e
2f23
60e1
2f24
60c1
2f25
6001
2f26
6381
2f27
20d3
2f28
86df
2f29
ffff
2f2a
1a01
2f2b
0002
2f2c
7f81
2f2d
2f23
#include "screen.dasm16"
admiral.dasm16
14
250
2f2e
8f01
2f2f
8f01
2f30
7c20
2f31
2039
2f32
56a1
2f33
000b
2f34
ffff
2f35
5461
2f36
000a
2f37
0ea1
2f38
fffe
2f39
4f01
2f3a
0001
2f3b
7f32
2f3c
0800
2f3d
a661
2f3e
0001
2f3f
7c21
2f40
026f
2f41
7f81
2f42
2fad
2f43
5401
2f44
fffe
2f45
6201
2f46
0001
2f47
2861
2f48
2c61
2f49
4c61
2f4a
0002
2f4b
7c20
2f4c
2026
2f4d
5401
2f4e
fffe
2f4f
6201
2f50
0001
2f51
8461
2f52
7f81
2f53
2026
2f54
9301
2f55
9301
2f56
7c20
2f57
2039
2f58
56a1
2f59
000c
2f5a
ffff
2f5b
5461
2f5c
000b
2f5d
0ea1
2f5e
fffe
2f5f
7e73
2f60
0800
2f61
0001
2f62
7f81
2f63
2f6b
2f64
0f01
2f65
7c20
2f66
28ca
2f67
a661
2f68
0001
2f69
0ea1
2f6a
fffe
2f6b
8f01
2f6c
9701
2f6d
7c20
2f6e
2770
2f6f
0ea1
2f70
fffd
2f71
2cde
2f72
55de
2f73
fffe
2f74
55c1
2f75
000a
2f76
7c21
2f77
0271
2f78
7f81
2f79
2fad
2f7a
5541
2f7b
fffd
2f7c
7f81
2f7d
2026
2f7e
00c3
2f7f
88c3
2f80
5701
2f81
000c
2f82
1b01
2f83
5701
2f84
fffd
2f85
7c20
2f86
27b5
2f87
7f81
2f88
2026
2f89
8f01
2f8a
8f01
2f8b
7c20
2f8c
2039
2f8d
56a1
2f8e
000b
2f8f
ffff
2f90
5461
2f91
000a
2f92
0ea1
2f93
fffe
2f94
4f01
2f95
0001
2f96
7f32
2f97
0800
2f98
a661
2f99
0001
2f9a
7c21
2f9b
2f9e
2f9c
7f81
2f9d
2fad
2f9e
2fa0
2f9f
2f4d
2fa0
5421
2fa1
fffe
2fa2
6221
2fa3
0001
2fa4
0043
2fa5
8843
2fa6
5401
2fa7
ffff
2fa8
0821
2fa9
7c20
2faa
278b
2fab
7c20
2fac
2026
2fad
5401
2fae
ffff
2faf
2001
2fb0
00de
2fb1
00e1
2fb2
20e2
2fb3
1cd4
2fb4
4781
2fb5
0001
2fb6
1c41
2fb7
1843
2fb8
8c46
2fb9
1842
2fba
2881
2fbb
3081
2fbc
5701
2fbd
fffe
2fbe
5301
2fbf
0001
2fc0
7c20
2fc1
1dc0
2fc2
8872
2fc3
7f81
2fc4
2fc9
2fc5
8072
2fc6
7f81
2fc7
2fcd
2fc8
2781
2fc9
08c1
2fca
88c2
2fcb
7f81
2fcc
2fb3
2fcd
08e1
2fce
88e3
2fcf
7f81
2fd0
2fb3
2fd1
8b01
2fd2
8f01
2fd3
7c20
2fd4
2039
2fd5
5481
2fd6
000a
2fd7
af01
2fd8
a701
2fd9
7c20
2fda
21d3
2fdb
0ea1
2fdc
ffff
2fdd
0f01
2fde
7f01
2fdf
007b
2fe0
7c20
2fe1
27d8
2fe2
84c1
2fe3
3021
2fe4
2421
2fe5
04d2
2fe6
7f81
2fe7
301e
2fe8
84d2
2fe9
7f81
2fea
2ff1
2feb
5701
2fec
ffff
2fed
7f01
2fee
002c
2fef
7c20
2ff0
27d8
2ff1
3061
2ff2
1862
2ff3
4c41
2ff4
0001
2ff5
2861
2ff6
4c61
2ff7
0001
2ff8
2861
2ff9
4f01
2ffa
0001
2ffb
7c20
2ffc
2086
2ffd
0ea1
2ffe
fffe
2fff
5701
3000
ffff
3001
5701
3002
fffe
3003
7c20
3004
283b
3005
0ea1
3006
ffff
3007
5701
3008
ffff
3009
7f01
300a
003a
300b
7c20
300c
27d8
300d
2861
300e
4f01
300f
0002
3010
7c20
3011
2086
3012
0ea1
3013
fffe
3014
5701
3015
ffff
3016
5701
3017
fffe
3018
7c20
3019
283b
301a
0ea1
301b
ffff
301c
7f9e
301d
2fe5
301e
5701
301f
ffff
3020
7f01
3021
007d
3022
7c20
3023
27d8
3024
5461
3025
ffff
3026
7c20
3027
2026
#include "dict2.dasm16"
admiral.dasm16
15
601
3028
8701
3029
8b01
302a
7c20
302b
2039
302c
8401
302d
7a40
302e
0252
302f
8833
3030
7c20
3031
00c6
3032
8bc1
3033
0246
3034
7fc1
3035
059f
3036
0247
3037
8bc1
3038
0248
3039
8bc1
303a
0249
303b
88c1
303c
8ce1
303d
7cf2
303e
05a0
303f
84e1
3040
1fc1
3041
d980
3042
1b01
3043
7c20
3044
311d
3045
84f3
3046
7f9e
3047
303d
3048
8701
3049
8b01
304a
7c20
304b
2770
304c
0ea1
304d
ffff
304e
5701
304f
ffff
3050
7c20
3051
316e
3052
7c20
3053
310d
3054
5461
3055
ffff
3056
7f81
3057
2026
3058
7c20
3059
30fd
305a
7b01
305b
0248
305c
7b01
305d
0249
305e
7c20
305f
31d9
3060
6381
3061
8f01
3062
8f01
3063
7c20
3064
2039
3065
7c20
3066
30fd
3067
5701
3068
000a
3069
7c20
306a
316e
306b
0ea1
306c
ffff
306d
7b01
306e
0248
306f
7b01
3070
0249
3071
7c20
3072
31d9
3073
0ea1
3074
fffe
3075
0f01
3076
5701
3077
000b
3078
7c20
3079
2f2e
307a
8472
307b
7f81
307c
3082
307d
0f01
307e
7f01
307f
315a
3080
7c20
3081
3145
3082
5701
3083
fffe
3084
5701
3085
000b
3086
5701
3087
ffff
3088
7c20
3089
2f54
308a
5701
308b
fffe
308c
7c20
308d
30dc
308e
7c20
308f
310d
3090
5461
3091
ffff
3092
7f81
3093
2026
3094
8b01
3095
8b01
3096
7c20
3097
2039
3098
7c20
3099
30fd
309a
7b01
309b
0248
309c
7b01
309d
0249
309e
7c20
309f
31d9
30a0
0ea1
30a1
ffff
30a2
0f01
30a3
5701
30a4
000a
30a5
7c20
30a6
2f2e
30a7
8472
30a8
7c20
30a9
00c6
30aa
0f01
30ab
7f01
30ac
31d9
30ad
7c20
30ae
3145
30af
7f81
30b0
2026
30b1
8b01
30b2
8f01
30b3
7c20
30b4
2039
30b5
7c20
30b6
30fd
30b7
7b01
30b8
0248
30b9
7b01
30ba
0249
30bb
7c20
30bc
31d9
30bd
0ea1
30be
ffff
30bf
0f01
30c0
5701
30c1
000a
30c2
7c20
30c3
2f2e
30c4
8472
30c5
7c20
30c6
00c6
30c7
0f01
30c8
7f01
30c9
315a
30ca
7c20
30cb
3145
30cc
5701
30cd
ffff
30ce
5701
30cf
000a
30d0
7c20
30d1
2f89
30d2
5701
30d3
ffff
30d4
7c20
30d5
30dc
30d6
7c20
30d7
310d
30d8
5461
30d9
ffff
30da
7f81
30db
2026
30dc
8b01
30dd
8b01
30de
7c20
30df
2039
30e0
5701
30e1
000a
30e2
7c20
30e3
316e
30e4
0ea1
30e5
ffff
30e6
2c81
30e7
7b01
30e8
0248
30e9
7b01
30ea
0249
30eb
7c20
30ec
315a
30ed
5301
30ee
0001
30ef
7c20
30f0
22bc
30f1
0fc1
30f2
0248
30f3
5301
30f4
0002
30f5
7c20
30f6
22bc
30f7
0fc1
30f8
0249
30f9
5461
30fa
ffff
30fb
7f81
30fc
2026
30fd
8701
30fe
7c20
30ff
312c
3100
7bc1
3101
d980
3102
0246
3103
7bc1
3104
d981
3105
0247
3106
7bc1
3107
d982
3108
0248
3109
7bc1
310a
d983
310b
0249
310c
6381
310d
7bc1
310e
0246
310f
d980
3110
7bc1
3111
0247
3112
d981
3113
7bc1
3114
0248
3115
d982
3116
7bc1
3117
0249
3118
d983
3119
8701
311a
7c20
311b
311d
311c
6381
311d
8b01
311e
8701
311f
7c20
3120
2039
3121
9001
3122
5461
3123
000a
3124
7c81
3125
d980
3126
7a40
3127
0252
3128
7c20
3129
313e
312a
7f81
312b
2026
312c
8b01
312d
8701
312e
7c20
312f
2039
3130
8c01
3131
5461
3132
000a
3133
7c81
3134
d980
3135
7a40
3136
0252
3137
7c20
3138
313e
3139
7fc1
313a
d981
313b
0245
313c
7f81
313d
2026
313e
8401
313f
7a40
3140
0252
3141
9032
3142
7f81
3143
313f
3144
6381
3145
8f01
3146
8701
3147
7c20
3148
2039
3149
5401
314a
000b
314b
2001
314c
4301
314d
0001
314e
7c20
314f
22bc
3150
0f01
3151
4301
3152
0002
3153
7c20
3154
22bc
3155
0f01
3156
5420
3157
000a
3158
7f81
3159
2026
315a
8f01
315b
8701
315c
7c20
315d
2039
315e
7b01
315f
0247
3160
7c20
3161
312c
3162
57c1
3163
000b
3164
d980
3165
7b01
3166
0247
3167
7c20
3168
311d
3169
57c1
316a
000a
316b
0247
316c
7f81
316d
2026
316e
8b01
316f
8b01
3170
7c20
3171
2039
3172
7801
3173
0246
3174
0301
3175
7c20
3176
3243
3177
5701
3178
000a
3179
7c20
317a
319b
317b
7821
317c
0246
317d
7841
317e
0244
317f
7c20
3180
324b
3181
9301
3182
9701
3183
7c20
3184
2770
3185
0ea1
3186
ffff
3187
2c81
3188
0301
3189
7c20
318a
22a2
318b
0e81
318c
0001
318d
0701
318e
7c20
318f
22a2
3190
0e81
3191
0002
3192
0b01
3193
7c20
3194
22a2
3195
0e81
3196
0003
3197
5461
3198
ffff
3199
7f81
319a
2026
319b
8b01
319c
8701
319d
7c20
319e
2039
319f
6c01
31a0
6c21
31a1
5701
31a2
000a
31a3
8823
31a4
2481
31a5
1301
31a6
7c20
31a7
3256
31a8
5041
31a9
0001
31aa
0b01
31ab
7c20
31ac
3256
31ad
3081
31ae
30e1
31af
88e2
31b0
7c50
31b1
0040
31b2
94e1
31b3
1f01
31b4
7c20
31b5
3256
31b6
10c1
31b7
7c51
31b8
0040
31b9
88c2
31ba
1c82
31bb
10d2
31bc
0776
31bd
7f81
31be
31a3
31bf
10d2
31c0
7f81
31c1
31d4
31c2
3b01
31c3
7c20
31c4
3256
31c5
7c51
31c6
2707
31c7
7f9e
31c8
31bb
31c9
00e1
31ca
88e3
31cb
39f2
31cc
7f9e
31cd
31bb
31ce
6cf4
31cf
7f81
31d0
31ca
31d1
3b01
31d2
7f9e
31d3
31bb
31d4
8701
31d5
7c20
31d6
3256
31d7
7f81
31d8
2026
31d9
8f01
31da
8b01
31db
7c20
31dc
2039
31dd
5701
31de
000b
31df
7c20
31e0
3243
31e1
7c20
31e2
31e5
31e3
7f81
31e4
2026
31e5
8701
31e6
8b01
31e7
7c20
31e8
2039
31e9
8701
31ea
7c20
31eb
3270
31ec
8472
31ed
7f81
31ee
3236
31ef
0c01
31f0
7c20
31f1
323a
31f2
7c20
31f3
3270
31f4
0c21
31f5
7c20
31f6
3270
31f7
0c41
31f8
85f3
31f9
7f81
31fa
3205
31fb
0b01
31fc
0701
31fd
7c20
31fe
21d3
31ff
0ea1
3200
ffff
3201
0f01
3202
0301
3203
7f81
3204
320c
3205
5f01
3206
0001
3207
0b01
3208
7c20
3209
2185
320a
0661
320b
0001
320c
2cc1
320d
7c30
320e
0040
320f
7f81
3210
3214
3211
09c1
3212
89c3
3213
88c2
3214
2c42
3215
08d2
3216
7f81
3217
31ea
3218
7c20
3219
3270
321a
7c30
321b
2707
321c
7f81
321d
3221
321e
0dc1
321f
7f9e
3220
3215
3221
7c20
3222
323a
3223
85f2
3224
7f81
3225
322a
3226
5dc1
3227
0001
3228
7f9e
3229
3215
322a
8701
322b
0f01
322c
8701
322d
7f01
322e
0080
322f
7c20
3230
21d3
3231
0f41
3232
0001
3233
0dc1
3234
7f9e
3235
3215
3236
5461
3237
ffff
3238
7f81
3239
2026
323a
6ce1
323b
88e3
323c
8ce2
323d
85f2
323e
6381
323f
0df3
3240
7f81
3241
323c
3242
6381
3243
6b01
3244
0001
3245
7c20
3246
312c
3247
87c1
3248
0244
3249
6321
324a
6381
324b
7b01
324c
d980
324d
87c1
324e
d980
324f
7b01
3250
0246
3251
7c20
3252
311d
3253
63c1
3254
0246
3255
6381
3256
7fd6
3257
db80
3258
0245
3259
7f81
325a
3266
325b
7b01
325c
0246
325d
7c20
325e
311d
325f
7bc1
3260
d980
3261
0246
3262
7b01
3263
d980
3264
7c20
3265
312c
3266
7861
3267
0245
3268
6961
3269
0001
326a
8bc2
326b
0245
326c
8bc2
326d
0244
326e
6321
326f
6381
3270
7fd6
3271
db80
3272
0245
3273
7f81
3274
3279
3275
7b01
3276
d980
3277
7c20
3278
312c
3279
7861
327a
0245
327b
2c61
327c
8bc2
327d
0245
327e
8bc2
327f
0244
3280
6381
#include "floppy.dasm16"
admiral.dasm16
16
413
3281
1f01
3282
0f01
3283
1301
3284
1701
3285
1b01
3286
7c20
3287
334b
3288
68c1
3289
0006
328a
7ce1
328b
0273
328c
3c01
328d
2802
328e
7c20
328f
33a4
3290
9422
3291
0061
3292
5c01
3293
0001
3294
0c02
3295
5d2c
3296
0004
3297
5e2c
3298
0005
3299
0001
329a
5e2c
329b
0006
329c
0002
329d
5e2c
329e
0007
329f
0003
32a0
7c20
32a1
33a4
32a2
5d2c
32a3
0004
32a4
5e2c
32a5
0005
32a6
0001
32a7
5e2c
32a8
0006
32a9
0002
32aa
5e2c
32ab
0007
32ac
0003
32ad
9423
32ae
0081
32af
5c01
32b0
0002
32b1
1002
32b2
5d2c
32b3
0004
32b4
5e2c
32b5
0005
32b6
0001
32b7
5e2c
32b8
0006
32b9
0002
32ba
5e2c
32bb
0007
32bc
0003
32bd
7c20
32be
33a4
32bf
5d2c
32c0
0004
32c1
5e2c
32c2
0005
32c3
0001
32c4
5e2c
32c5
0006
32c6
0002
32c7
5e2c
32c8
0007
32c9
0003
32ca
9422
32cb
00a1
32cc
5c01
32cd
0003
32ce
1402
32cf
7c20
32d0
33a4
32d1
9423
32d2
3c02
32d3
0141
32d4
8842
32d5
88c3
32d6
84d2
32d7
7f81
32d8
3406
32d9
7c20
32da
3336
32db
7f81
32dc
328a
32dd
1f01
32de
0f01
32df
1301
32e0
1701
32e1
1b01
32e2
7c20
32e3
334b
32e4
68c1
32e5
0006
32e6
7ce1
32e7
0273
32e8
2801
32e9
3c03
32ea
9422
32eb
7c20
32ec
33c0
32ed
5c03
32ee
0003
32ef
00a1
32f0
9423
32f1
5d2c
32f2
0004
32f3
5e2c
32f4
0005
32f5
0001
32f6
5e2c
32f7
0006
32f8
0002
32f9
5e2c
32fa
0007
32fb
0003
32fc
7c20
32fd
33c0
32fe
5d2c
32ff
0004
3300
5e2c
3301
0005
3302
0001
3303
5e2c
3304
0006
3305
0002
3306
5e2c
3307
0007
3308
0003
3309
5c03
330a
0002
330b
0081
330c
9422
330d
5d2c
330e
0004
330f
5e2c
3310
0005
3311
0001
3312
5e2c
3313
0006
3314
0002
3315
5e2c
3316
0007
3317
0003
3318
7c20
3319
33c0
331a
5d2c
331b
0004
331c
5e2c
331d
0005
331e
0001
331f
5e2c
3320
0006
3321
0002
3322
5e2c
3323
0007
3324
0003
3325
5c03
3326
0001
3327
0061
3328
9423
3329
7c20
332a
33c0
332b
3c03
332c
0141
332d
88c3
332e
8842
332f
84d2
3330
7f81
3331
3406
3332
7c20
3333
3336
3334
7f81
3335
32e6
3336
15e2
3337
0ee2
3338
0001
3339
12e2
333a
0002
333b
3ee2
333c
0003
333d
0ee2
333e
0003
333f
3eec
3340
0004
3341
5eec
3342
0001
3343
0005
3344
5eec
3345
0002
3346
0006
3347
5eec
3348
0003
3349
0007
334a
6381
334b
0b01
334c
7c41
334d
0273
334e
2141
334f
4241
3350
0001
3351
0001
3352
4241
3353
0002
3354
0002
3355
4241
3356
0003
3357
0003
3358
2241
3359
0004
335a
4241
335b
0001
335c
0005
335d
4241
335e
0002
335f
0006
3360
4241
3361
0003
3362
0007
3363
84c1
3364
2801
3365
1802
3366
7c20
3367
33a4
3368
00e1
3369
4801
336a
0001
336b
1c02
336c
7c20
336d
33a4
336e
0061
336f
4801
3370
0002
3371
0c02
3372
7c20
3373
33a4
3374
0081
3375
4801
3376
0003
3377
1002
3378
7c20
3379
33a4
337a
00a1
337b
2801
337c
1402
337d
900f
337e
740b
337f
0141
3380
8842
3381
2801
3382
1c02
3383
880d
3384
740b
3385
0141
3386
8842
3387
2801
3388
0c02
3389
a40f
338a
740b
338b
0141
338c
8842
338d
2801
338e
1002
338f
880f
3390
740b
3391
0141
3392
9043
3393
2a4c
3394
0004
3395
4a4c
3396
0001
3397
0005
3398
4a4c
3399
0002
339a
0006
339b
4a4c
339c
0003
339d
0007
339e
88c2
339f
94d6
33a0
7f81
33a1
3364
33a2
6041
33a3
6381
33a4
1b01
33a5
0701
33a6
84c1
33a7
240c
33a8
7c20
33a9
33b2
33aa
88c2
33ab
8822
33ac
94d3
33ad
7f81
33ae
33a7
33af
6021
33b0
60c1
33b1
6381
33b2
0701
33b3
7c21
33b4
027b
33b5
7c20
33b6
33e5
33b7
0021
33b8
9c2f
33b9
742b
33ba
002c
33bb
ac0f
33bc
740b
33bd
040c
33be
6021
33bf
6381
33c0
1b01
33c1
84c1
33c2
9422
33c3
8823
33c4
7c20
33c5
33cd
33c6
240c
33c7
88c2
33c8
94d3
33c9
7f81
33ca
33c3
33cb
60c1
33cc
6381
33cd
0701
33ce
0b01
33cf
0021
33d0
0041
33d1
8c2f
33d2
742b
33d3
002c
33d4
944f
33d5
744b
33d6
082c
33d7
0041
33d8
b44f
33d9
744b
33da
082c
33db
bc0f
33dc
740b
33dd
040c
33de
7c21
33df
028b
33e0
7c20
33e1
33e5
33e2
6041
33e3
6021
33e4
6381
33e5
0b01
33e6
1b01
33e7
0f01
33e8
1301
33e9
1701
33ea
0041
33eb
8401
33ec
84c1
33ed
88c2
33ee
944f
33ef
7461
33f0
8c6d
33f1
7481
33f2
bc8d
33f3
0462
33f4
8882
33f5
9484
33f6
2ca1
33f7
10af
33f8
74a1
33f9
c0aa
33fa
940f
33fb
140b
33fc
9422
33fd
94d6
33fe
7f81
33ff
33ed
3400
60a1
3401
6081
3402
6061
3403
60c1
3404
6041
3405
6381
3406
85e1
3407
86e1
3408
0001
3409
86e1
340a
0002
340b
86e1
340c
0003
340d
86e1
340e
0004
340f
86e1
3410
0005
3411
86e1
3412
0006
3413
86e1
3414
0007
3415
0801
3416
60c1
3417
60a1
3418
6081
3419
6061
341a
60e1
341b
6041
341c
6003
341d
0b81
#include "crypt.dasm16"
admiral.dasm16
17
0

